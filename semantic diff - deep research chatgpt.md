
 
Semantic Code Differencing: Language-Aware Diff Techniques
==========================================================

Background: Textual vs. Semantic Code Diffs
-------------------------------------------

Traditional diff tools (like the Unix `diff` or GitHub's diff) operate at the text line level, which often misrepresents code changes[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=text%20line%20granularity%20%28Nugroho%20et%C2%A0al,to%20new%20locations%20relatively%20far). These **line-based diffs** treat code as plain text – e.g. adding a line break can appear as a change even if the code logic is unchanged. In contrast, **semantic code differencing** uses the code’s structure and meaning (via Abstract Syntax Trees, parse trees, or program semantics) to produce more meaningful diffs. Semantic or _language-aware_ diffs ignore superficial changes (whitespace, formatting) and highlight only real code modifications[difftastic.wilfred.me.uk](https://difftastic.wilfred.me.uk/#:~:text=Difftastic%20is%20a%20CLI%20diff,easier%20for%20humans%20to%20read)[difftastic.wilfred.me.uk](https://difftastic.wilfred.me.uk/#:~:text=Difftastic%20parses%20your%20code%20with,inner%20expression%20hasn%27t%20changed%20here). For example, a semantic diff can recognize when an inner expression hasn’t changed or when code is just reformatted, whereas a line diff would flag many lines as changed[difftastic.wilfred.me.uk](https://difftastic.wilfred.me.uk/#:~:text=Difftastic%20parses%20your%20code%20with,inner%20expression%20hasn%27t%20changed%20here). By understanding code syntax and structure, semantic diffs make it easier for developers to see _what actually changed_ in terms of the code’s logic rather than its text presentation[difftastic.wilfred.me.uk](https://difftastic.wilfred.me.uk/#:~:text=Difftastic%20is%20a%20CLI%20diff,easier%20for%20humans%20to%20read)[difftastic.wilfred.me.uk](https://difftastic.wilfred.me.uk/#:~:text=Difftastic%20parses%20your%20code%20with,inner%20expression%20hasn%27t%20changed%20here).

Foundational Research on Semantic Differencing
----------------------------------------------

Academic interest in _semantic differencing_ goes back decades. A seminal early approach by **Horwitz (1990)** introduced an algorithm to identify both textual and _semantic differences_ between program versions using Program Dependence Graphs[diva-portal.org](https://www.diva-portal.org/smash/get/diva2:210981/FULLTEXT01.pdf#:~:text=Horwitz%E2%80%98s%20approach%20finds%20both%20the,while%20loops%20and%20output%20statement). This method could determine if two versions produce different behaviors (semantic changes) beyond just textual edits. Building on that idea, **Binkley (1992)** applied semantic differencing to regression testing: by constructing System Dependence Graphs of two program versions and slicing around changed nodes, they could detect changes in behavior and thus reduce the cost of retesting[diva-portal.org](https://www.diva-portal.org/smash/get/diva2:210981/FULLTEXT01.pdf#:~:text=Binkley%E2%80%98s%20approach%20is%20used%20to,to%20reduce%20cost%20regression%20testing). These foundational works treated programs as graphs of computations to find differences that truly affect program outputs. Another early approach by Jackson and Ladd (1994) compared input-output dependencies of each procedure in two versions to spot semantic changes[diva-portal.org](https://www.diva-portal.org/smash/get/diva2:210981/FULLTEXT01.pdf#:~:text=Semantic%20diff%20by%20Jackson%20and,output%20dependencies). While these techniques were powerful, they were often language-specific and computationally heavy, so later research shifted toward more practical syntactic (AST-based) differencing for everyday development use.

AST-Based Code Differencing (Language-Aware Diffs)
--------------------------------------------------

To overcome the limitations of raw text diffs, researchers developed **AST differencing** tools that align code changes with programming language structure. An AST diff parses the source code into its syntax tree and computes changes as tree edits (insertions, deletions, moves, updates) rather than line edits[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=text%20line%20granularity%20%28Nugroho%20et%C2%A0al,to%20new%20locations%20relatively%20far)[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=developed,Escobar%20et%C2%A0al). This fine-grained approach can detect when a code element (e.g. a function or block) was moved or renamed, which line-based diffs would miss. Crucially, AST-based diffs ignore irrelevant formatting changes and focus on meaningful edits aligned with language grammar[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=text%20line%20granularity%20%28Nugroho%20et%C2%A0al,to%20new%20locations%20relatively%20far)[difftastic.wilfred.me.uk](https://difftastic.wilfred.me.uk/#:~:text=Difftastic%20parses%20your%20code%20with,inner%20expression%20hasn%27t%20changed%20here).

Some key AST-based differencing algorithms and tools include:

* **ChangeDistiller (Fluri et al., 2007):** An early AST differencing technique for fine-grained source code change extraction[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=,70731). ChangeDistiller parses Java code and classifies changes (e.g. statement insert, condition change) by comparing ASTs, enabling analysis of code evolution beyond line diffs[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=The%20typical%20edit%20actions%20supported,the%20change%20comprehension%20point%20of)[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=,70731).
    
* **GumTree (Falleri et al., 2014):** A widely cited algorithm for accurate tree differencing[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=,In%20Proceedings%20of%20the%2043rd). GumTree introduced improved heuristics for matching AST nodes between versions, supporting move detection and producing a concise _edit script_ of changes[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=The%20typical%20edit%20actions%20supported,the%20change%20comprehension%20point%20of). It became a de facto baseline for AST diff and is used in many tools (open-sourced as **GumTreeDiff**).
    
* **IJM – Iterative Java Matcher (Frick et al., 2018):** An AST differencing approach that iteratively refines the matching of AST nodes to improve edit script accuracy[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=The%20typical%20edit%20actions%20supported,the%20change%20comprehension%20point%20of). It aimed to generate more compact and precise diffs by re-matching difficult cases in multiple passes.
    
* **MTDiff (Dotzler & Philippsen, 2016):** A move-optimized tree differencing algorithm[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=32%2C%204%20%28apr%202020%29%2C%2031%C2%A0pages,2970315). MTDiff focuses on correctly identifying moved code blocks as moves (instead of as delete+insert), improving diff interpretability when code is reorganized[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=The%20typical%20edit%20actions%20supported,the%20change%20comprehension%20point%20of).
    
* **CLDiff (Huang et al., 2018):** An AST differencing tool that produces _concise linked code differences_[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=Generating%20Simpler%20AST%20Edit%20Scripts,3238219). It concisely links related changes (like a function call change linked to its definition change) to aid understanding of cross-cutting edits.
    

These AST-based techniques demonstrated much better results than raw text diffs for code. For instance, they recognize updates and moves (not just additions/deletions) and align diffs with the code’s logical structure[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=text%20line%20granularity%20%28Nugroho%20et%C2%A0al,to%20new%20locations%20relatively%20far)[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=developed,Escobar%20et%C2%A0al). This makes reviews of complex changes (e.g. refactorings that move code far from its original location) more comprehensible[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=text%20line%20granularity%20%28Nugroho%20et%C2%A0al,to%20new%20locations%20relatively%20far). Empirical studies have shown that AST differencing helps developers understand code evolution more easily than line-by-line diffs[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=The%20typical%20edit%20actions%20supported,the%20change%20comprehension%20point%20of). Tools like ChangeDistiller and GumTree became **foundational in software engineering research** for analyzing code changes.

Recent Advances and Semantic Enhancements
-----------------------------------------

Despite their improvements, AST differencing tools still face challenges in producing _optimal_ diffs from a human perspective. A 2021 study by **Fan et al.** systematically tested state-of-the-art AST diff algorithms and found that **20–30% of code revisions still get inaccurately mapped** by tools like GumTree, MTDiff, and IJM[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=as%20shown%20in%20experiments%20with,that%20based%20on%20their%20experimental). In other words, in up to a third of cases, these tools either mismatched nodes or produced confusing edit scripts, indicating room for further improvement[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=as%20shown%20in%20experiments%20with,that%20based%20on%20their%20experimental). Common issues included incorrectly matching semantically different nodes and not recognizing complex refactorings.

**Refactoring-aware differencing** is one area of recent progress. For example, Alikhanifard & Tsantalis (2024) introduced an AST differencing approach built on RefactoringMiner that addresses several limitations of earlier tools[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=overcome%20the%20limitations%20of%20line,mapping%20accuracy%2C%20and%20then%20we). Their method incorporates **language semantics and refactoring knowledge** into the diff algorithm: it allows one-to-many mappings (merging or splitting code), uses language-specific clues (identifiers, type information) to guide matching, and explicitly accounts for known refactorings (like Extract Method or Rename Class)[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=tools%20in%20understanding%20complex%20changes%2C,pairs%20of%20matched%20program%20element)[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=RefactoringMiner%20to%20increase%20its%20statement,that%20of%20the%20faster%20tools). By leveraging detected refactoring operations and matching declarations across the two versions, their tool produces diffs that more closely reflect the developer’s intended changes[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=RefactoringMiner%20to%20increase%20its%20statement,that%20of%20the%20faster%20tools). In an evaluation with a benchmark of 1000+ real commits, this refactoring-aware diff achieved significantly higher precision and recall than earlier AST diff tools, especially on commits involving complex refactorings[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=RefactoringMiner%20to%20increase%20its%20statement,that%20of%20the%20faster%20tools). It demonstrates that making the diff engine _aware of the programming language semantics_ (e.g., what constitutes a renamed function vs. a new function) yields more intelligent diffs.

Another frontier is moving from purely _structural_ AST diffs to truly **semantic diffs** that understand code meaning. A structural diff identifies changes in syntax structure, but a semantic diff goes further by understanding when different code representations are equivalent in behavior. For instance, the tool **SemanticDiff** (2024) distinguishes semantic no-ops: it knows that `1337` and `0x539` are the same numeric value, or that adding optional parentheses doesn’t change logic[semanticdiff.com](https://semanticdiff.com/blog/semanticdiff-vs-difftastic/#:~:text=Semantic%20diffs%2C%20as%20implemented%20in,to%20detect%20those%20invariant%20changes). Such a semantic diff attaches extra information to AST nodes (like constant values or evaluation semantics) and uses rules to ignore changes that don’t affect program behavior[semanticdiff.com](https://semanticdiff.com/blog/semanticdiff-vs-difftastic/#:~:text=Semantic%20diffs%2C%20as%20implemented%20in,to%20detect%20those%20invariant%20changes). This means that if a change only alters the format (like splitting a long string literal into two or adding parentheses around an expression), a semantic diff can recognize it as _no meaningful change_, highlighting nothing or much less in the diff. By filtering out these behavior-preserving edits, semantic diffs further reduce review noise and pinpoint only the impactful changes. This approach of course requires deeper language-specific knowledge (e.g., how numeric literals or string concatenation work), but it represents the cutting edge in “intelligent” differencing where the tool is truly aware of code logic.

It’s also worth noting research that summarizes _systematic_ code changes. **LSdiff (Kim & Notkin, 2009)**, for example, looks for recurring structural change patterns and summarizes them as logic rules[researchgate.net](https://www.researchgate.net/publication/221554249_LSdiff_A_program_differencing_tool_to_identify_systematic_structural_differences#:~:text=,and%20represents%20each%20program). Instead of listing every individual edit, LSdiff infers rules like “all subclasses of X had method Y’s call to Z deleted”[web.cs.ucla.edu](https://web.cs.ucla.edu/~miryung/Publications/uw08-dissertation-mkim.pdf#:~:text=change,allow%20programmers%20to%20understand%20shared)[web.cs.ucla.edu](https://web.cs.ucla.edu/~miryung/Publications/uw08-dissertation-mkim.pdf#:~:text=Suppose%20that%20a%20programmer%20deleted,m). Such techniques go beyond single-diff analysis to identify higher-level semantic trends in code evolution. While these are specialized research tools, they highlight how semantic analysis of diffs can aid in understanding large-scale or repetitive changes.

Open-Source Tools for Semantic Code Diff
----------------------------------------

The concepts above have been implemented in various tools, including several open-source projects that developers can use today:

* **GumTreeDiff:** An open-source library implementing the GumTree AST differencing algorithm (originally by Falleri et al. 2014). It takes two code files, parses them into ASTs, and produces a fine-grained edit script. GumTreeDiff is actively maintained and has been integrated into version control and research tools[news.ycombinator.com](https://news.ycombinator.com/item?id=44520438#:~:text=If%20you%27re%20looking%20for%20something,com%2FGumTreeDiff%2Fgumtree). It provides language-agnostic tree differencing (with built-in support for Java and others) and often serves as a baseline for AST diff performance.
    
* **RefactoringMiner 3.0:** Primarily known for detecting code refactorings, RefactoringMiner (by Tsantalis et al.) now also offers AST differencing capabilities. Since version 3.0, it can generate an AST diff for a given commit, pull request, or file pair[github.com](https://github.com/tsantalis/RefactoringMiner#:~:text=RefactoringMiner%20is%20a%20library%2FAPI%20written,the%20diffs%20in%20your%20browser). Notably, it is _refactoring-aware_: when visualizing diffs, it can annotate detected refactorings (e.g. “Method renamed” or “Block moved”) with tooltips and list them alongside the code changes[github.com](https://github.com/tsantalis/RefactoringMiner#:~:text=Refactoring). It also handles code moved across files and matches changes in comments or Javadoc formatting[github.com](https://github.com/tsantalis/RefactoringMiner#:~:text=Diff%20for%20code%20moved%20between,different%20files)[github.com](https://github.com/tsantalis/RefactoringMiner#:~:text=Our%20tool%20can%20match%20Javadoc,line%20arguments.%20Image%3A%20CommentFormatting). RefactoringMiner is open-source (Java) and can be used as a library or CLI, making it a powerful option for semantic diffing especially in Java projects.
    
* **Diff/AST (codinuum/diffast):** An AST differencing tool by Hashimoto and Mori, originally described in their 2008 paper “Diff/TS: Fine-Grained Structural Change Analysis”[github.com](https://github.com/codinuum/diffast#:~:text=reported%20in%20the%20following%20paper%3A). Diff/AST uses a tree edit distance algorithm with optimizations to compare syntax trees of code in languages like Java, C/C++, Python, etc.[github.com](https://github.com/codinuum/diffast#:~:text=The%20tool%20is%20currently%20able,their%20computational%20complexity%20is%20essentially). It produces fine-grained change facts (and can even output changes in XML or RDF formats for querying)[github.com](https://github.com/codinuum/diffast#:~:text=Diff%2FAST%20is%20able%20to%20export,mining%2C%20and%20code%20homology%20analysis). This tool emphasizes exact AST node matching and was one of the early open implementations of a _language-aware diff_ supporting multiple languages.
    
* **Difftastic:** A popular modern structural diff tool written in Rust. Difftastic uses the Tree-sitter parsing library to parse source files into syntax trees, and then compares those trees instead of raw text[difftastic.wilfred.me.uk](https://difftastic.wilfred.me.uk/#:~:text=Difftastic%20parses%20your%20code%20with,inner%20expression%20hasn%27t%20changed%20here). The result is a diff that _“understands syntax”_ – it ignores pure formatting changes and aligns changes on syntax elements rather than lines[difftastic.wilfred.me.uk](https://difftastic.wilfred.me.uk/#:~:text=Difftastic%20is%20a%20CLI%20diff,easier%20for%20humans%20to%20read)[difftastic.wilfred.me.uk](https://difftastic.wilfred.me.uk/#:~:text=Difftastic%20parses%20your%20code%20with,inner%20expression%20hasn%27t%20changed%20here). For example, if only an inner expression in a line changed, difftastic will highlight just that token rather than the whole line. It supports many languages (by leveraging Tree-sitter’s wide range of grammars) and produces side-by-side diffs that clearly show added/removed syntax nodes. Difftastic is MIT-licensed and can integrate with Git as an alternative diff driver[difftastic.wilfred.me.uk](https://difftastic.wilfred.me.uk/#:~:text=Difftastic%20is%20a%20CLI%20diff,easier%20for%20humans%20to%20read)[difftastic.wilfred.me.uk](https://difftastic.wilfred.me.uk/#:~:text=Image%3A%20screenshot).
    
* **Diffsitter:** Another Rust-based AST diff tool that specifically builds on Tree-sitter for parsing. Diffsitter similarly creates **“semantically meaningful diffs that ignore formatting differences like spacing”**, by computing diffs on the AST rather than on the raw text[robot.unipv.it](https://robot.unipv.it/toolleeo/shaarli/shaare/ihXilw#:~:text=diffsitter%20creates%20semantically%20meaningful%20diffs,text%20contents%20of%20the%20file). It aims to provide more human-friendly diffs across languages, taking advantage of Tree-sitter to parse each language’s grammar. (Its README lists comparable projects including difftastic and even a web-based Semantic Diff tool[github.com](https://github.com/afnanenayet/diffsitter#:~:text=Similar%20Projects).) Diffsitter is open-source (MIT license) and has a focus on being a drop-in diff tool replacement for developers who want AST-level diffs without setting up heavy infrastructure.
    

In addition to the above, there are other noteworthy tools. **Difftastic’s approach** has inspired similar projects (e.g. _Locust_ or _Delta_ mentioned alongside Diffsitter[github.com](https://github.com/afnanenayet/diffsitter#:~:text=Similar%20Projects)). There are also commercial offerings like **SemanticMerge** (by Plastic SCM) which perform language-aware merges and diffs, and newer services like **SemanticDiff** (with a GitHub app and VS Code extension) that implement the advanced semantic comparisons described earlier. The open-source version control system _Pijul_ has also discussed using AST-level diffs for smarter merges[discourse.pijul.org](https://discourse.pijul.org/t/ast-level-diffs-and-merges/187#:~:text=AST,moving%20blocks%20of%20code). The landscape of semantic differencing tools is growing rapidly, reflecting the demand for diffs that are more intelligent than the classic unified diff.

Conclusion
----------

Semantic code differencing has evolved from theoretical foundations in the 1990s to practical tools today that significantly improve the clarity of code changes. Foundational research established how to identify changes in program _meaning_, and recent work has translated those insights into syntax-aware diff algorithms and tools. Modern AST-based diffs (like GumTree, ChangeDistiller, and RefactoringMiner’s diff) align changes with code structure, making diffs more informative for developers[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=text%20line%20granularity%20%28Nugroho%20et%C2%A0al,to%20new%20locations%20relatively%20far)[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=The%20typical%20edit%20actions%20supported,the%20change%20comprehension%20point%20of). Cutting-edge approaches even incorporate deeper semantic knowledge – for example, recognizing refactorings or ignoring changes that don’t alter program behavior[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=tools%20in%20understanding%20complex%20changes%2C,pairs%20of%20matched%20program%20element)[semanticdiff.com](https://semanticdiff.com/blog/semanticdiff-vs-difftastic/#:~:text=Semantic%20diffs%2C%20as%20implemented%20in,to%20detect%20those%20invariant%20changes). Open-source tools such as difftastic and diffsitter leverage parsing frameworks (Tree-sitter) to bring these capabilities to dozens of programming languages out of the box[difftastic.wilfred.me.uk](https://difftastic.wilfred.me.uk/#:~:text=Difftastic%20parses%20your%20code%20with,inner%20expression%20hasn%27t%20changed%20here)[robot.unipv.it](https://robot.unipv.it/toolleeo/shaarli/shaare/ihXilw#:~:text=diffsitter%20creates%20semantically%20meaningful%20diffs,text%20contents%20of%20the%20file).

In summary, the “best” solutions for semantic diffing combine **language-aware analysis** with robust diff algorithms. For foundational reading, Horwitz’s 1990 work[diva-portal.org](https://www.diva-portal.org/smash/get/diva2:210981/FULLTEXT01.pdf#:~:text=Horwitz%E2%80%98s%20approach%20finds%20both%20the,while%20loops%20and%20output%20statement) and Binkley’s 1992 study[diva-portal.org](https://www.diva-portal.org/smash/get/diva2:210981/FULLTEXT01.pdf#:~:text=Binkley%E2%80%98s%20approach%20is%20used%20to,to%20reduce%20cost%20regression%20testing) provide insight into semantic differencing in terms of program behavior. On the syntax-aware side, key papers like Fluri et al. 2007[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=,70731) and Falleri et al. 2014[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=,In%20Proceedings%20of%20the%2043rd) introduce the AST differencing paradigm, while newer research (e.g. Alikhanifard & Tsantalis 2024) shows how to push this further with semantic and refactoring awareness[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=RefactoringMiner%20to%20increase%20its%20statement,that%20of%20the%20faster%20tools). By consulting these works and experimenting with tools like RefactoringMiner, GumTree, or difftastic, one can get a strong overview of state-of-the-art semantic code diff techniques that go well beyond whitespace and line comparisons.

**Sources:**

1. Horwitz, S. (1990). _Identifying the semantic and textual differences between two versions of a program._ PLDI 1990[diva-portal.org](https://www.diva-portal.org/smash/get/diva2:210981/FULLTEXT01.pdf#:~:text=Horwitz%E2%80%98s%20approach%20finds%20both%20the,while%20loops%20and%20output%20statement)
    
2. Binkley, D. (1992). _Using semantic differencing to reduce the cost of regression testing._ ICSM 1992[diva-portal.org](https://www.diva-portal.org/smash/get/diva2:210981/FULLTEXT01.pdf#:~:text=Binkley%E2%80%98s%20approach%20is%20used%20to,to%20reduce%20cost%20regression%20testing)
    
3. Fluri, B. et al. (2007). _Change Distilling: Tree Differencing for Fine-Grained Source Code Change Extraction._ TSE 33(11), 725–743[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=,70731)
    
4. Falleri, J.-R. et al. (2014). _Fine-Grained and Accurate Source Code Differencing._ ASE 2014, pp. 313–324[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=,In%20Proceedings%20of%20the%2043rd)
    
5. Fan, Y. et al. (2021). _A Differential Testing Approach for Evaluating AST Mapping Algorithms._ ICSE 2021[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=as%20shown%20in%20experiments%20with,that%20based%20on%20their%20experimental)
    
6. Alikhanifard, P., & Tsantalis, N. (2024). _A Novel Refactoring and Semantic Aware AST Differencing Tool_ (TOSEM 2024)[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=overcome%20the%20limitations%20of%20line,mapping%20accuracy%2C%20and%20then%20we)[ar5iv.org](https://ar5iv.org/html/2403.05939v2#:~:text=RefactoringMiner%20to%20increase%20its%20statement,that%20of%20the%20faster%20tools)
    
7. Difftastic – _A structural diff tool that understands syntax._ (Project site)[difftastic.wilfred.me.uk](https://difftastic.wilfred.me.uk/#:~:text=Difftastic%20is%20a%20CLI%20diff,easier%20for%20humans%20to%20read)[difftastic.wilfred.me.uk](https://difftastic.wilfred.me.uk/#:~:text=Difftastic%20parses%20your%20code%20with,inner%20expression%20hasn%27t%20changed%20here)
    
8. _diffsitter_ – Tree-sitter based AST difftool (GitHub README excerpt)[robot.unipv.it](https://robot.unipv.it/toolleeo/shaarli/shaare/ihXilw#:~:text=diffsitter%20creates%20semantically%20meaningful%20diffs,text%20contents%20of%20the%20file)
    
9. Müller, M. (2024). “Structural vs. Semantic Diffs.” _SemanticDiff blog_[semanticdiff.com](https://semanticdiff.com/blog/semanticdiff-vs-difftastic/#:~:text=Semantic%20diffs%2C%20as%20implemented%20in,to%20detect%20those%20invariant%20changes)
    
10. Hashimoto, M., & Mori, A. (2008). _Diff/TS: Fine-Grained Structural Change Analysis._ WCRE 2008[github.com](https://github.com/codinuum/diffast#:~:text=reported%20in%20the%20following%20paper%3A)