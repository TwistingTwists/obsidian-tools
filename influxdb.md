---
tags:
  - rust
  - database
  - projects
---
day - 01 2025-03-04 06:46:27

Crash Handlers in Rust for Linux systems 
```rust


// Based on ideas from
// https://github.com/servo/servo/blob/f03ddf6c6c6e94e799ab2a3a89660aea4a01da6f/ports/servo/main.rs#L58-L79
#[cfg(unix)]
fn install_crash_handler() {
    unsafe {
        set_signal_handler(libc::SIGSEGV, signal_handler); // handle segfaults
        set_signal_handler(libc::SIGILL, signal_handler); // handle stack overflow and unsupported CPUs
        set_signal_handler(libc::SIGBUS, signal_handler); // handle invalid memory access
    }
}

#[cfg(unix)]
unsafe extern "C" fn signal_handler(sig: i32) {
    use backtrace::Backtrace;
    use std::process::abort;
    let name = std::thread::current()
        .name()
        .map(|n| format!(" for thread \"{n}\""))
        .unwrap_or_else(|| "".to_owned());
    eprintln!(
        "Signal {}, Stack trace{}\n{:?}",
        sig,
        name,
        Backtrace::new()
    );
    abort();
}

// based on https://github.com/adjivas/sig/blob/master/src/lib.rs#L34-L52
#[cfg(unix)]
unsafe fn set_signal_handler(signal: libc::c_int, handler: unsafe extern "C" fn(libc::c_int)) {
    use libc::{sigaction, sigfillset, sighandler_t};
    let mut sigset = unsafe { std::mem::zeroed() };

    // Block all signals during the handler. This is the expected behavior, but
    // it's not guaranteed by `signal()`.
    if unsafe { sigfillset(&mut sigset) } != -1 {
        // Done because sigaction has private members.
        // This is safe because sa_restorer and sa_handlers are pointers that
        // might be null (that is, zero).
        let mut action: sigaction = unsafe { std::mem::zeroed() };

        // action.sa_flags = 0;
        action.sa_mask = sigset;
        action.sa_sigaction = handler as sighandler_t;

        unsafe {
            sigaction(signal, &action, std::ptr::null_mut());
        }
    }
}

```

Great! I will prepare a comprehensive 5000-word summary covering:

1. **Introduction to signals in Unix/Linux**, including an explanation of key signals like SIGSEGV, SIGILL, and SIGBUS.
2. **A detailed breakdown of the provided Rust code**, with line-by-line explanations and practical examples.
3. **Crash handling strategies in Rust**, comparing Rust’s approach to handling crashes with other languages.
4. **Best practices for signal handling**, explaining why `sigaction` is preferred over `signal()` and discussing signal safety concerns.
5. **Debugging and logging signals**, with tools, logging techniques, and debugging practices for effective crash reporting.
6. **Comparative scenarios for different signals**, explaining when and why specific signals matter in real-world applications.

I’ll ensure the document is rich in Rust examples, including contrasting cases where relevant signals make more sense.

I'll update you when the document is ready!

# Signal Crash Handling in Rust: A Comprehensive Guide

## Introduction to Signals in Unix/Linux

In Unix-like systems, a **signal** is essentially an asynchronous message or notification sent to a process to inform it of an event ([What is a signal in Unix? - Stack Overflow](https://stackoverflow.com/questions/455842/what-is-a-signal-in-unix#:~:text=A%20signal%20is%20,%28from%20Wikipedia)) ([What is a signal in Unix? - Stack Overflow](https://stackoverflow.com/questions/455842/what-is-a-signal-in-unix#:~:text=0)). The operating system interrupts the normal flow of the process and delivers a signal, which can be triggered by various events: a user pressing `Ctrl+C` (sending `SIGINT`), a timer expiring (`SIGALRM`), or an illegal operation like an invalid memory access (`SIGSEGV`). Each signal has a numeric identifier and a name (for example, signal 11 is `SIGSEGV`). When a signal is delivered, the process can choose to handle it in a custom way, ignore it, or do nothing and accept the default behavior defined by the OS ([Working with signals in Rust - some things that signal handlers can't handle](https://www.jameselford.com/blog/working-with-signals-in-rust-pt1-whats-a-signal#:~:text=You%20can%20find%20a%20more,Others%20might%20simply%20be%20ignored)).

**Default behaviors:** Every signal has a default action if the program doesn’t handle it. Many signals by default will terminate the process, sometimes also producing a **core dump** (a snapshot file of the program’s memory) for post-mortem debugging ([signal(7) - Linux manual page](http://man7.org/linux/man-pages/man7/signal.7.html#:~:text=SIGABRT%20%20%20%20,Child%20stopped%20or%20terminated)) ([Who’s at Fault: Tracking Down Segfaults in Production](https://blog.discourse.org/2021/10/tracking-down-segfaults-in-production/#:~:text=It%27s%20probably%20best%20to%20discuss,SEGV%20stands%20for%20%27segmentation%20violation)). For example, the signals most associated with crashes – like **SIGSEGV** (segmentation fault), **SIGILL** (illegal instruction), **SIGBUS** (bus error), **SIGFPE** (floating-point exception), and **SIGABRT** (abort) – all have a default action to terminate the program and dump core ([signal(7) - Linux manual page](http://man7.org/linux/man-pages/man7/signal.7.html#:~:text=SIGABRT%20%20%20%20,Child%20stopped%20or%20terminated)) ([Who’s at Fault: Tracking Down Segfaults in Production](https://blog.discourse.org/2021/10/tracking-down-segfaults-in-production/#:~:text=SIGSEGV%20is%20one%20of%20several,and%20return%20to%20normal%20operation)). This means that if your Rust program hits an invalid memory reference (SIGSEGV) or executes an illegal CPU instruction (SIGILL), it will by default be killed and (if core dumps are enabled) a core file will be generated. Some other signals have different defaults: for instance, **SIGINT** (interrupt from keyboard) normally terminates a program (without a core dump), and **SIGPIPE** (writing to a broken pipe) terminates the process by default. A few signals are simply ignored by default (e.g. `SIGCHLD` which notifies parent process of child termination), and **SIGKILL** and **SIGSTOP** are special signals that cannot be caught or ignored at all – `SIGKILL` always immediately kills the process, and `SIGSTOP` always suspends it ([Working with signals in Rust - some things that signal handlers can't handle](https://www.jameselford.com/blog/working-with-signals-in-rust-pt1-whats-a-signal#:~:text=You%20can%20find%20a%20more,Others%20might%20simply%20be%20ignored)) ([signal(2) - Linux manual page](http://man7.org/linux/man-pages/man2/signal.2.html#:~:text=WARNING%3A%20the%20behavior%20of%20signal,See%20Portability%20below)).

**How processes handle signals:** A running process can set up a **signal handler** function to execute when a specific signal arrives. If no handler is set for a given signal, the process will undergo the default behavior. If a handler is installed, the OS will interrupt the normal execution flow and invoke that handler function asynchronously. After the handler finishes, the process may resume execution (in some cases) as if nothing happened, unless the handler takes steps to terminate or the signal’s default is to kill the process. Most signals can be caught and handled this way, but there are exceptions (notably `SIGKILL` and `SIGSTOP` which the OS will always handle by terminating/stopping the process) ([signal(2) - Linux manual page](http://man7.org/linux/man-pages/man2/signal.2.html#:~:text=,upon%20return%20from%20the%20handler)).

It’s important to note that signal handling is a **process-wide setting** – in a multi-threaded program, all threads share the same signal handlers and disposition for each signal ([signal(7) - Linux manual page](http://man7.org/linux/man-pages/man7/signal.7.html#:~:text=The%20signal%20disposition%20is%20a,the%20same%20for%20all%20threads)). However, the signal is delivered to one particular thread. For synchronous error signals like SIGSEGV or SIGFPE, the signal is delivered to the thread that caused the fault (for example, the thread that performed the invalid memory access) ([signal(7) - Linux manual page](http://man7.org/linux/man-pages/man7/signal.7.html#:~:text=hardware%20exception%3A%20SIGBUS%2C%20SIGEMT%2C%20SIGFPE%2C,does%20not%20always%20make%20sense)). By default, these signals will crash the entire process. In general, there's usually no way to continue normal execution after a serious error signal (like a segfault) without risking instability, so even if you handle it, it's typically for logging or cleanup purposes before terminating.

**Key crash signals:** Let’s briefly introduce the most relevant signals for crash handling and what they represent:

- **SIGSEGV** – Segmentation fault, i.e. an invalid memory reference. This signal is sent when a program tries to read or write memory that it's not allowed to access (for example, dereferencing a null or dangling pointer, or overflowing the stack) ([Who’s at Fault: Tracking Down Segfaults in Production](https://blog.discourse.org/2021/10/tracking-down-segfaults-in-production/#:~:text=It%27s%20probably%20best%20to%20discuss,SEGV%20stands%20for%20%27segmentation%20violation)). The default action is to terminate the process with a core dump.
- **SIGILL** – Illegal instruction. This occurs when the CPU encounters an invalid or privileged machine instruction. It can happen if you attempt to execute data as code, jump to a corrupt function pointer, or if your binary is compiled for the wrong architecture and contains instructions the CPU cannot understand ([Who’s at Fault: Tracking Down Segfaults in Production](https://blog.discourse.org/2021/10/tracking-down-segfaults-in-production/#:~:text=SIGBUS%20%20%20%20Bus,SVr4)). Default action is to terminate with core dump.
- **SIGBUS** – Bus error, which also indicates an invalid memory access but of a particular kind. It often means an alignment error (accessing memory at an address that isn’t properly aligned for the type) or other hardware-specific memory faults (for example, on some systems trying to access memory that doesn’t exist but without the same conditions as a segmentation fault) ([Who’s at Fault: Tracking Down Segfaults in Production](https://blog.discourse.org/2021/10/tracking-down-segfaults-in-production/#:~:text=%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%E2%94%80%20SIGABRT%20%20%20Abort,SVr4)). Default is terminate with core.
- **SIGFPE** – Floating point exception. Despite the name, this covers errors in arithmetic operations, not just floating-point. It’s sent on conditions like division by zero or overflow in certain hardware-supported math operations ([crash_handler - Rust](https://docs.rs/crash-handler#:~:text=)). In modern x86 Rust code, integer overflow in debug mode triggers a panic (not a signal), and floating-point errors produce NaNs or infinities by default, so SIGFPE is less common in Rust unless you deliberately enable FPU exceptions or call into C code that causes it. Default action is terminate with core.
- **SIGABRT** – Abort signal. This is sent when a program aborts itself, typically via calling `abort()` in C or `std::process::abort()` in Rust. Many library assertion failures or double-panic situations result in an abort. The default action is to terminate with a core dump ([crash_handler - Rust](https://docs.rs/crash-handler#:~:text=Signal%20sent%20to%20a%20process,itself%20like%20any%20other%20signal)).
- **SIGTRAP** – Trap signal. This is generated by a breakpoint or a debugger trap, or by certain instructions like `int3` on x86. For example, debuggers use SIGTRAP to stop programs at breakpoints. It can also be raised by programs (Rust’s `unreachable_unchecked` or other low-level debug asserts might cause a trap). Default action is terminate with core ([crash_handler - Rust](https://docs.rs/crash-handler#:~:text=)) ([Who’s at Fault: Tracking Down Segfaults in Production](https://blog.discourse.org/2021/10/tracking-down-segfaults-in-production/#:~:text=SIGSYS%20%20%20%20Bad,2BSD)).
- **SIGTERM** and **SIGINT** – These are not crash signals per se (they indicate a requested termination, from the system or user), but it's worth mentioning that their default action is to gracefully terminate the process (without a core dump). They can be caught to perform cleanup. We won't focus on these for _crash_ handling, but they are part of the signal spectrum.
- **SIGPIPE** – Also not exactly a "crash" signal, but by default it will terminate a process if it writes to a pipe or socket that has been closed on the other end. Many network programs ignore SIGPIPE to handle such errors in code instead. We mention it because it's a common gotcha: a Rust program writing to a closed socket could get killed by SIGPIPE unless that signal is handled or ignored.

In summary, Unix signals are a fundamental mechanism for the OS to notify processes of events or errors. For crash-related signals like segmentation faults or illegal instructions, the default behavior is to terminate the program (often dumping core). As developers, we have the ability to intercept these signals with handlers – which is what the Rust code in question will do – but doing so requires care. Next, we'll examine a Rust implementation of a crash signal handler and how it works.

## Breakdown of the Provided Rust Code

Let's break down the Rust code snippet that installs a crash handler. This code aims to catch fatal signals (such as SIGSEGV, SIGILL, SIGBUS, etc.) so that the program can log a backtrace or message before terminating. We'll go through it line by line, explaining what each part does:

```rust
use std::ptr;
use std::mem;
use libc::{sigaction, sigemptyset, c_int, SIGSEGV, SIGILL, SIGBUS, SIGFPE, SIGABRT};

/// Set up a signal handler for a given signal number.
unsafe fn set_signal_handler(signum: c_int, handler: extern "C" fn(c_int)) {
    let mut action: libc::sigaction = mem::zeroed();      // Initialize a sigaction struct with zeros
    // Assign the handler function to the sa_handler field
    action.sa_sigaction = handler as usize as *const ();  // Using union field sa_sigaction here as raw pointer
    // Or in a simpler way: action.sa_handler = handler (if using sa_handler union alias)
    action.sa_flags = 0;                                  // No special flags (e.g. no SA_SIGINFO, no SA_RESTART explicitly)
    sigemptyset(&mut action.sa_mask);                     // Block no additional signals during handler
    // Install the new handler for the given signal
    sigaction(signum, &action, ptr::null_mut());
}

/// The signal handler function – prints backtrace and aborts.
extern "C" fn signal_handler(signum: c_int) {
    eprintln!("Caught signal {}", signum);
    // Use the backtrace crate or std::backtrace to capture a backtrace
    let bt = backtrace::Backtrace::new();
    eprintln!("{:?}", bt);
    std::process::abort();  // Forcefully terminate the process after handling
}

/// Install handlers for various crash signals.
pub fn install_crash_handler() {
    unsafe {
        set_signal_handler(SIGSEGV, signal_handler);
        set_signal_handler(SIGILL,  signal_handler);
        set_signal_handler(SIGBUS,  signal_handler);
        set_signal_handler(SIGFPE,  signal_handler);
        // SIGABRT is optional – handling it can interfere with abort() behavior
        // set_signal_handler(SIGABRT, signal_handler);
    }
}
```

Now, let's explain each piece of this code:

- **Importing libc and constants:** The code uses the `libc` crate to access low-level C functions and constants. We import `libc::sigaction` (the struct and function) and signal constants like `SIGSEGV`, `SIGILL`, etc. These constants correspond to the standard signal numbers on Unix.
    
- **`install_crash_handler` function:** This is the entry point that the program would call (for example, early in `main()`) to set up the custom handlers. It simply calls `set_signal_handler` for each of the signals we want to catch. We wrap these calls in an `unsafe` block because installing signal handlers involves calling C functions (which are marked unsafe in Rust due to the global side effects).
    
- **`set_signal_handler` function:** This function abstracts the process of registering our handler for a given signal. It is marked `unsafe` because it interacts with C code and raw pointers. Inside:
    
    - We create a `libc::sigaction` struct named `action` and zero it out with `mem::zeroed()`. This struct is defined by the libc API to describe a signal handling action. Zeroing it ensures all fields are default-initialized (which is important, for example, to start with an empty signal mask).
    - We then set the handler function pointer. The `libc::sigaction` struct has a union for the handler: it can be used either as `sa_handler` (for a handler that takes just the signal number) or `sa_sigaction` (for a handler that takes extra parameters for detailed info). In our simple case, our `signal_handler` function matches the type `void handler(int)` (just the signal number), so we could assign it to `action.sa_handler`. The code above does a cast via `sa_sigaction` field; effectively, it’s storing the function pointer. The `extern "C" fn(c_int)` type ensures the function uses the correct C ABI and signature required by the OS ([signal(2) - Linux manual page](http://man7.org/linux/man-pages/man2/signal.2.html#:~:text=signal,signal%20handler)).
    - We set `action.sa_flags = 0` meaning we use the default behavior (no special flags). In particular, we did _not_ set `SA_RESTART`, `SA_SIGINFO`, or `SA_ONSTACK` here.
        - `SA_RESTART` flag would make certain system calls automatically resume if interrupted by this signal ([Working with signals in Rust - part 2](https://www.jameselford.com/blog/working-with-signals-in-rust-pt2-nonlocal-behaviour/#:~:text=Let%27s%20just%20dwell%20for%20a,to%20automatically%20restart)). Not setting it means if the signal arrives while the program was in a sleep or blocking I/O call, that call might return early with `EINTR`. In practice, for crash signals that usually occur due to bugs, this distinction is minor – the program is about to abort anyway.
        - `SA_SIGINFO` flag would allow a more complex handler signature that receives extra `siginfo_t` and context parameters (useful to get details like memory address that caused SIGSEGV). Our handler doesn’t use those, so we leave it off and use the simpler form.
        - `SA_ONSTACK` would allow the handler to run on an alternate stack (more on this in best practices, useful for stack overflow handling). Here it's not set, which means the handler will run on the process's current stack (which could be a problem if the stack is overflowed).
        - Other flags like `SA_NODEFER` or `SA_RESETHAND` are also default-off. By default, without `SA_NODEFER`, the system will block the same signal from interrupting itself (to prevent recursion), and without `SA_RESETHAND`, the handler remains in place for subsequent signals.
    - We call `sigemptyset(&mut action.sa_mask)` to initialize the mask of signals that should be blocked during execution of our handler. An empty set means "block no additional signals." By default, when a handler is invoked, the system already blocks that specific signal from being delivered again concurrently (unless `SA_NODEFER` is used) ([signal(2) - Linux manual page](http://man7.org/linux/man-pages/man2/signal.2.html#:~:text=,upon%20return%20from%20the%20handler)). You could add other signals to this mask if you want to prevent them from interrupting this handler.
    - Finally, we call `libc::sigaction(signum, &action, ptr::null_mut())`. This is the system call to register our handler for the given `signum`. We pass `ptr::null_mut()` for the old action because we don't need to save the previous handler. After this call, the process knows to use our `signal_handler` whenever signal `signum` occurs. We do not explicitly check the return value here, but in a robust implementation you might want to ensure it returns 0 (success).
- **`extern "C" fn signal_handler(signum: c_int)`**: This is the function that gets called when one of the signals we set up is delivered. Let's examine what it does:
    
    - The function is marked `extern "C"` to ensure it has the correct calling convention that the OS expects for signal handlers (C ABI). It takes an `c_int` (i32) parameter which is the signal number.
    - Inside, it first uses `eprintln!` to print an error message to standard error: `"Caught signal {signum}"`. This is a quick way to notify what happened. We use `eprintln!` (which is like `println!` but goes to stderr and is unbuffered) because in a crash scenario we want the message to appear even if stdout is buffered.
    - Next, it captures and prints a **backtrace**. In the snippet above, we assume there's a `backtrace` crate in use (or Rust’s built-in `std::backtrace::Backtrace`). By calling `Backtrace::new()` (or similar) and then printing it with `{:?}`, we attempt to get a stack trace of the current thread. The backtrace will show the sequence of function calls that led to this point (the crash handler itself will be on the stack, followed by the point where the signal was raised). This is immensely helpful for debugging – it tells us _where_ the crash occurred. For example, if a segmentation fault happened, the backtrace would show the function that caused it and its callers. Keep in mind, generating a backtrace may or may not be fully reliable in a signal handler context (it might allocate memory or do things that aren't strictly async-signal-safe), but in practice it's often used for debugging purposes ([The problem is that printing a backtrace is the responsibility of the ...](https://news.ycombinator.com/item?id=35836017#:~:text=The%20problem%20is%20that%20printing,rs%20mostly%20delegates)). We'll discuss signal safety shortly.
    - Finally, the handler calls `std::process::abort()`. This is crucial. We log the backtrace and then _immediately terminate the process_ by aborting. We do this instead of trying to return normally from the handler because after a serious fault like SIGSEGV, the program state is likely corrupted or at least the instruction that faulted cannot be successfully retried. By aborting, we ensure the program stops then and there. `abort()` effectively raises SIGABRT to the process, which by default will terminate the process and produce a core dump ([crash_handler - Rust](https://docs.rs/crash-handler#:~:text=Signal%20sent%20to%20a%20process,itself%20like%20any%20other%20signal)). In other words, we choose to end the program in a controlled way after logging. If we were to simply return from the handler, execution would resume at the point of the fault, and likely trigger the same signal again immediately (since nothing was fixed). That would either lead to a recursive signal loop or the kernel terminating the process on the second signal delivery ([Who’s at Fault: Tracking Down Segfaults in Production](https://blog.discourse.org/2021/10/tracking-down-segfaults-in-production/#:~:text=SIGSEGV%20is%20one%20of%20several,and%20return%20to%20normal%20operation)) ([Is SIGSEGV handled by Rust runtime? - The Rust Programming Language Forum](https://users.rust-lang.org/t/is-sigsegv-handled-by-rust-runtime/45680#:~:text=The%20intent%20is%20that%20returning,stuff%20if%20we%20just%20aborted)). By aborting, we break out of that cycle and let the program die in a known manner.

Putting it all together, `install_crash_handler()` will set up our `signal_handler` for the specified crash signals. From that point on, if any of those signals occur, instead of the program instantly dying with a cryptic "Segmentation fault (core dumped)" message, our handler will run. It will print a message and a backtrace to stderr, helping us identify what went wrong, and then abort the program.

**A note about SIGABRT:** In the code, handling SIGABRT is commented out as "optional." This is because calling `abort()` in the handler would itself raise SIGABRT, and if we've installed our handler for SIGABRT too, we would catch it again in the handler – causing an infinite loop of aborting. One way to avoid that would be not to use `abort()` in the handler if we handle SIGABRT, or temporarily restore the default handler. In many crash handlers, people either choose not to catch SIGABRT (so that calling `abort()` will perform the default action and terminate the program normally), or if they do catch it, they do something slightly different like printing and then calling `_exit()` or re-raising the signal with the default disposition. In our simple scenario, it's safer to not override SIGABRT; thus, our `abort()` call will cleanly terminate the program with a core dump. The result is that whether the crash was from a segfault or an explicit abort, we will get a stack trace printed out and then a termination.

**Why use `sigaction` instead of `signal()`?** The code above uses the `sigaction` system call to set the handler. There is an older C library function `signal()` which could also register a handler, but it has historical quirks and less control. In fact, the Linux man page explicitly warns: _“Avoid its use: use sigaction(2) instead.”_ ([signal(2) - Linux manual page](http://man7.org/linux/man-pages/man2/signal.2.html#:~:text=WARNING%3A%20the%20behavior%20of%20signal,See%20Portability%20below)). The `sigaction` API allows you to specify flags (like the ones discussed) and is consistent across UNIX systems, whereas `signal()` has varied semantics (on some systems it may reset the handler to default after firing, etc.) ([signal(2) - Linux manual page](http://man7.org/linux/man-pages/man2/signal.2.html#:~:text=WARNING%3A%20the%20behavior%20of%20signal,See%20Portability%20below)) ([signal(2) - Linux manual page](http://man7.org/linux/man-pages/man2/signal.2.html#:~:text=,upon%20return%20from%20the%20handler)). Rust’s `libc` and higher-level libraries favor `sigaction` for these reasons. In our code, we directly call `libc::sigaction`, but one could also use wrappers from crates like `nix` or `signal-hook` which make it safer and easier to register handlers.

**Summary of what the crash handler does:** After installing, if say a null pointer dereference occurs, the OS will send SIGSEGV to our process. Instead of the default (terminate immediately), our `signal_handler` will run. It will print "Caught signal 11" (11 is the number for SIGSEGV on most systems) and a backtrace of the thread, then call abort to end the program. We thus get a nice diagnostic in the console (and still get a core dump for deeper inspection if enabled). This can be invaluable in debugging crashes, especially in release builds or when running in environments where attaching a debugger is not easy.

Next, we'll discuss the broader strategies for handling crashes in Rust and how this compares to other error handling mechanisms.

## Crash Handling Strategies in Rust

Rust is often touted for its safety guarantees, so you might wonder: _if Rust is safe, why would we ever need a crash handler for SIGSEGV or the like?_ The key is that Rust’s safety is largely about avoiding _logical_ memory errors in safe code (like buffer overflows, use-after-free, etc.). However, Rust does allow **unsafe code** and interfacing with other languages, which means the same kinds of crashes that can happen in C or C++ (null dereferences, invalid frees, etc.) can happen in a Rust program that uses those features ([Debugging a segfault in my Rust program](https://jvns.ca/blog/2017/12/23/segfault-debugging/#:~:text=Segfaults%20happen%20in%20Rust%20for,your%20Rust%20program%20can%20segfault)). Additionally, certain conditions like stack overflow are detected at runtime via the operating system’s signals. Therefore, robust Rust applications – especially systems programming, embedded, or high-availability services – might employ crash handlers to log and diagnose such failures.

Let's outline how Rust deals with errors and crashes:

- **Rust panics vs. OS signals:** In Rust, a panic (triggered by `panic!()` or by the standard library on certain checks like out-of-bounds array access in debug mode) is _not_ the same as a segmentation fault. A panic is Rust's way of saying "something went wrong, but in a controlled fashion." By default, a panic will **unwind** the stack: it starts unwinding (calling destructors) and either you catch it at some boundary or it will eventually terminate the thread (and the process, if it was the main thread) after printing a message. Panics are not implemented via signals – they are language-level and use Rust’s runtime. For example, an out-of-range index will cause a panic with a message, not a SIGSEGV. If that panic goes uncaught, the runtime will print the panic message and abort the process (by calling `abort()` after unwinding or directly if panic=abort is configured). When a panic leads to abort, the OS sees a SIGABRT. This is different from a segfault (SIGSEGV) which the OS raises due to an invalid memory access. So, **panics are intended for recoverable errors or bugs in safe code, whereas signals like SIGSEGV usually indicate a serious memory error that Rust’s safety checks did not prevent** (likely because of `unsafe` or external code).
    
- **Using `panic::catch_unwind`:** Rust allows catching unwinding panics with `std::panic::catch_unwind` (in Rust 1.52+ this only works if the thread was already set to unwind on panic). This is useful if you want to isolate a portion of code that may panic and prevent it from crashing the whole program. For example, you might run a plugin or callback that could panic, and you catch it to handle it gracefully. **However, `catch_unwind` will _not_ catch a segmentation fault or other signal!** It only catches Rust panics. If an actual segfault occurs, it will bypass Rust’s panic mechanism entirely – the OS will interrupt the program. In other languages like Java or C#, all errors (even NullReference exceptions) are language exceptions that can be caught (though often it's bad practice to catch serious ones). In Rust (like in C/C++), a null pointer dereference isn’t a Rust panic, it's a fatal signal from the OS. There is no built-in language support to recover from that kind of crash inside the process. That’s why approaches like our signal handler are needed if we want to do something before the program dies.
    
- **Rust’s approach to crashes vs other languages:** Rust doesn’t have a runtime that will, for example, catch a SIGSEGV and convert it into a higher-level exception automatically. Some environments do: for instance, the Java Virtual Machine will crash on a segfault (it typically cannot continue), but some managed environments might attempt to handle certain errors. C++ does not convert segfaults to exceptions by default either (although Windows has Structured Exception Handling (SEH) which can catch access violations as exceptions, that’s outside standard C++). Rust chooses not to hide these catastrophic issues – if a segfault happens, it’s treated as a bug and the process will terminate (unless you installed a handler as we did). So in that sense, Rust is similar to C: you need to use OS facilities if you want to handle such events.
    
- **Rust standard library and stack overflow:** One interesting thing Rust does do is try to handle **stack overflows** more gracefully. Rust sets up a guard page at the end of each thread’s stack. If the stack pointer goes beyond that (overflowing), the CPU triggers a SIGSEGV. The Rust standard library has a signal handler for SIGSEGV _specifically to detect stack overflow on Windows and Unix_ and print a message like “stack overflow” before aborting ([Is SIGSEGV handled by Rust runtime? - The Rust Programming Language Forum](https://users.rust-lang.org/t/is-sigsegv-handled-by-rust-runtime/45680#:~:text=handling%20of%20stack%20overflow,the%20existence%20of%20the%20handler)) ([Is SIGSEGV handled by Rust runtime? - The Rust Programming Language Forum](https://users.rust-lang.org/t/is-sigsegv-handled-by-rust-runtime/45680#:~:text=The%20intent%20is%20that%20returning,stuff%20if%20we%20just%20aborted)). For example, on Linux, when a new thread is created, Rust will use `sigaltstack` to set up an alternate signal stack and configure a SIGSEGV handler that runs on that alternate stack. This way, if a stack overflow occurs (on the main stack), the handler can run on a separate stack and not itself overflow. The handler then typically prints an error to stderr and exits the process. This is why, if you ever accidentally create infinite recursion in Rust, you might see a message from the runtime about a stack overflow, rather than a raw OS message ([Is SIGSEGV handled by Rust runtime? - The Rust Programming Language Forum](https://users.rust-lang.org/t/is-sigsegv-handled-by-rust-runtime/45680#:~:text=The%20intent%20is%20that%20returning,stuff%20if%20we%20just%20aborted)) ([Is SIGSEGV handled by Rust runtime? - The Rust Programming Language Forum](https://users.rust-lang.org/t/is-sigsegv-handled-by-rust-runtime/45680#:~:text=cuviper%20%20July%2011%2C%202020%2C,9%3A08pm%20%206)). It’s a bit of a special-case crash handling built into the language runtime. Notably, after printing the message, Rust’s handler will **reset to the default and re-raise the SIGSEGV** so that the process terminates with the usual signal code (so that things like core dumps or parent process can see it was a SIGSEGV) ([Is SIGSEGV handled by Rust runtime? - The Rust Programming Language Forum](https://users.rust-lang.org/t/is-sigsegv-handled-by-rust-runtime/45680#:~:text=The%20intent%20is%20that%20returning,stuff%20if%20we%20just%20aborted)). This pattern – handle once, then crash – is essentially what our custom handler could do as well (we simplified by just calling abort). The Rust developers did this to differentiate stack overflow (which can happen in safe code) from other segfaults (which almost always indicate unsafe code issues). Aside from this, Rust doesn’t attempt to catch or recover from general protection faults.
    
- **Comparing with C and C++:** In C/C++, a common approach for crash handling is to use `signal(SIGSEGV, handler)` or `sigaction` or platform-specific mechanisms. There are libraries like Google Breakpad or Crashpad that set up out-of-process crash handling (spawning a helper process to capture state when a program crashes). Rust can interoperate with such libraries too (via FFI). One difference is that because Rust encourages avoiding crashes (with the type system and panics), you might not see as many Rust projects with custom SIGSEGV handlers as you would see C projects with, say, `set_terminate` or structured exception handling. But the need still arises, particularly in certain domains (games, servers, embedded devices) where you want a crash report.
    
- **Panic = abort option:** Rust has a compile-time option (in Cargo.toml or via `-C panic=abort`) to make panics abort the process immediately (no unwind). When panics abort, they effectively just call `abort()`, which sends SIGABRT. This is often used in release builds of binaries for performance (unwinding tables can be omitted) and to ensure a panic in any thread brings down the whole program (since unwinding in one thread but not joining it could potentially lead to a stalled program). With `panic=abort`, a Rust panic leads to a crash that can be caught by an **abort signal handler**. If we _did_ install our handler for SIGABRT, we could catch those as well. However, as noted earlier, intercepting SIGABRT is tricky if the handler itself calls abort. If your goal is just to log panics, it’s easier to use Rust’s `std::panic::set_hook` to set a custom panic hook (which can print the panic info and even a backtrace via `Backtrace::force_capture`) before aborting. But that only covers Rust panics, not other signals.
    
- **When to use a signal crash handler:** Ideally, your Rust program never segfaults. In practice, if you use unsafe code or FFI, crashes can happen. A signal handler like the one we installed is a last resort to capture information. It's analogous to an insurance policy: hopefully never needed, but invaluable when things go horribly wrong. You typically use it to log and then terminate, not to recover (since continuing after memory corruption is not safe) ([Who’s at Fault: Tracking Down Segfaults in Production](https://blog.discourse.org/2021/10/tracking-down-segfaults-in-production/#:~:text=SIGSEGV%20is%20one%20of%20several,and%20return%20to%20normal%20operation)). In high-reliability systems, one strategy is to run the process with a monitoring parent (like systemd or a supervisor) that will restart it if it crashes. The crash handler can output diagnostics (maybe to a file or stderr) that you can later analyze to fix the underlying issue.
    

In summary, Rust’s philosophy is to prevent crashes through safety guarantees and to handle errors through panics or `Result` types. But when a true crash occurs (segfault, illegal instruction, etc.), it behaves similarly to C/C++ – it's up to the programmer to decide if they want to intercept the signal. Unlike higher-level languages, there's no built-in catch for these at the language level. Our Rust code using `sigaction` is essentially the same approach you would use in C to catch a crash: it's tapping directly into the OS signal facility. Next, we'll look at best practices when writing such signal handlers in Rust, to ensure we don’t introduce more problems by handling signals.

## Best Practices for Signal Handling in Rust

Writing signal handlers (especially for crash signals) is a delicate task. Here are some best practices and important considerations to keep in mind:

**1. Prefer `sigaction` over `signal()`:** As mentioned, `signal()` is considered less reliable due to historical inconsistencies. The POSIX standard provides `sigaction` to supersede it, giving you explicit control over handler behavior ([signal(2) - Linux manual page](http://man7.org/linux/man-pages/man2/signal.2.html#:~:text=WARNING%3A%20the%20behavior%20of%20signal,See%20Portability%20below)). In Rust, you can use the `libc` crate to call `sigaction` (as we did) or use higher-level wrappers. The [`nix` crate](https://docs.rs/nix/latest/nix/sys/signal/) provides a safe wrapper around `sigaction` that may be more ergonomic. Using `sigaction` lets you specify flags like `SA_ONSTACK`, `SA_RESTART`, etc., which `signal()` does not directly offer. It also avoids the portability pitfalls of `signal()`. In short, always use `sigaction` (or a library built on it) for setting up signal handlers ([signal(2) - Linux manual page](http://man7.org/linux/man-pages/man2/signal.2.html#:~:text=WARNING%3A%20the%20behavior%20of%20signal,See%20Portability%20below)) ([signal(2) - Linux manual page](http://man7.org/linux/man-pages/man2/signal.2.html#:~:text=The%20only%20portable%20use%20of,use%20it%20for%20this%20purpose)).

**2. Keep signal handlers simple and **async-signal-safe****: Within a signal handler, you are running asynchronously, possibly interrupting the program at an arbitrary point (even in the middle of a library call). Only a very limited set of operations are safe to do in this context. The POSIX standard defines a list of [async-signal-safe functions](http://man7.org/linux/man-pages/man7/signal-safety.7.html) – functions that can be safely called from a signal handler without risk of deadlocks or corruption. These typically include low-level syscalls like `write` to file descriptors, `_exit`, `sig_atomic_t` operations, etc. Notably, **memory allocation and locking are not signal-safe**. In our handler, we called `eprintln!` and used the backtrace crate – technically, these are not guaranteed signal-safe (they might allocate or use locks internally) ([linux - How to handle SIGSEGV signal in userspace using Rust? - Stack Overflow](https://stackoverflow.com/questions/52065965/how-to-handle-sigsegv-signal-in-userspace-using-rust#:~:text=In%20a%20signal%20handler%2C%20you,println)) ([Unix Signals in Rust - The Rust Programming Language Forum](https://users.rust-lang.org/t/unix-signals-in-rust/733#:~:text=%40caleb%2C%20unfortunately%20your%20signal%20handler,but%20not%20the%20signal%20handler)). Why did we do it then? In a crash scenario, one might take the approach that "we're crashing anyway, let's try to get a backtrace out". It's a trade-off: there's a chance the backtrace or printing could hang (for example, if the crash occurred while another thread held the memory allocator lock, and our handler tries to allocate, it could deadlock) ([Unix Signals in Rust - The Rust Programming Language Forum](https://users.rust-lang.org/t/unix-signals-in-rust/733#:~:text=%40caleb%2C%20unfortunately%20your%20signal%20handler,but%20not%20the%20signal%20handler)). The **safest** handler would avoid anything that isn't async-signal-safe. For instance, it's better to use `libc::write` to print to stderr instead of `eprintln!`, because `write` is async-signal-safe whereas `eprintln!` may use buffered I/O or locks. The Rust compiler’s own signal handler for stack overflow uses direct syscalls to write to stderr for this reason ([signal_handler.rs source code [rust/compiler/rustc_driver_impl/src/signal_handler.rs] - Codebrowser](https://codebrowser.dev/rust/rust/compiler/rustc_driver_impl/src/signal_handler.rs.html#:~:text=20%2021%20impl%20fmt%3A%3AWrite%20,27) ) ([signal_handler.rs source code [rust/compiler/rustc_driver_impl/src/signal_handler.rs] - Codebrowser](https://codebrowser.dev/rust/rust/compiler/rustc_driver_impl/src/signal_handler.rs.html#:~:text=22%20fn%20write_str,SIGSEGV%20comes%20for%20our%20head) ). **Best practice:** do the minimal work needed in the signal handler – e.g., set an atomic flag, write a simple message to an FD, or in our case, capture a backtrace if you accept the potential risk.

**3. Don’t attempt complex recovery:** As stressed earlier, recovering from a segmentation fault or similar is unsafe. Once you get SIGSEGV, you generally should assume the process is in a bad state. The best you can do is log and exit (or perhaps execute a orderly shutdown sequence if you know it's safe). You should **not** return from a SIGSEGV handler expecting to continue normal execution – if the underlying issue isn’t resolved, the faulting instruction will just fault again ([Who’s at Fault: Tracking Down Segfaults in Production](https://blog.discourse.org/2021/10/tracking-down-segfaults-in-production/#:~:text=SIGSEGV%20is%20one%20of%20several,and%20return%20to%20normal%20operation)). One could use techniques like `siglongjmp` from within a handler to jump out to an earlier point in the program, but this is highly discouraged unless you really know what you're doing (and even then, memory may be corrupt). A common pattern (which Rust’s standard library uses for stack overflow) is: handle the signal once, then restore the default handler and re-raise the signal to let the OS terminate the program ([Is SIGSEGV handled by Rust runtime? - The Rust Programming Language Forum](https://users.rust-lang.org/t/is-sigsegv-handled-by-rust-runtime/45680#:~:text=The%20intent%20is%20that%20returning,stuff%20if%20we%20just%20aborted)) ([Is SIGSEGV handled by Rust runtime? - The Rust Programming Language Forum](https://users.rust-lang.org/t/is-sigsegv-handled-by-rust-runtime/45680#:~:text=cuviper%20%20July%2011%2C%202020%2C,9%3A08pm%20%206)). This way you get a chance to log, but still terminate in the normal way. In our code, calling `abort()` is another way to terminate cleanly (though via SIGABRT). Either way, plan to end the process. If you need the program to keep running despite a fault (for example, in an interactive environment), a better approach is to isolate the risky code in a separate process and communicate via IPC, rather than trying to catch SIGSEGV and continue in the same process.

**4. Use `SA_ONSTACK` and an alternate signal stack for certain signals:** One trap when handling signals like SIGSEGV is that the signal may be caused by a **stack overflow**. In that case, the thread's stack is exhausted – if the handler tries to run on the same stack, it will likely fail (you have no space to handle). The solution is to use `sigaltstack`: set up a separate stack area and use `SA_ONSTACK` flag with `sigaction` so that the handler executes on the alternate stack ([linux - How to handle SIGSEGV signal in userspace using Rust? - Stack Overflow](https://stackoverflow.com/questions/52065965/how-to-handle-sigsegv-signal-in-userspace-using-rust#:~:text=9)) ([crash_handler - Rust](https://docs.rs/crash-handler#:~:text=One%20important%20detail%20of%20the,stack%20that%20raised%20the%20signal)). Rust’s standard library automatically does this for new threads for the SIGSTACK (overflow) handler ([crash_handler - Rust](https://docs.rs/crash-handler#:~:text=One%20important%20detail%20of%20the,stack%20that%20raised%20the%20signal)). If you're writing your own crash handler and you want to robustly handle stack overflow, you should allocate an alternate stack (e.g. using `std::alloc` or libc `malloc` to get, say, 64KB for a stack) and call `libc::sigaltstack` to register it, then set `SA_ONSTACK` in your `sigaction` for SIGSEGV. This ensures that even if the main stack is toast, the handler can run on the alternate stack ([linux - How to handle SIGSEGV signal in userspace using Rust? - Stack Overflow](https://stackoverflow.com/questions/52065965/how-to-handle-sigsegv-signal-in-userspace-using-rust#:~:text=9)). In our simple code, we omitted this (meaning if a true stack overflow happens, our handler might not run properly). For general crash handling (especially if you include SIGSEGV), this is a good practice.

**5. Use `SA_RESTART` when appropriate:** The `SA_RESTART` flag can be set so that certain system calls (like read, write, etc.) that are interrupted by a signal will automatically restart instead of returning an `EINTR` error. If you're writing a handler for signals that might occur during normal operation (like SIGUSR1 or SIGINT), using `SA_RESTART` is often beneficial to not break syscalls ([Working with signals in Rust - part 2](https://www.jameselford.com/blog/working-with-signals-in-rust-pt2-nonlocal-behaviour/#:~:text=Let%27s%20just%20dwell%20for%20a,to%20automatically%20restart)). For crash signals, since we intend to abort, it doesn't matter much. But be aware: if you don't set `SA_RESTART`, functions like `sleep()` or `wait()` could return early with an error when a signal arrives ([Working with signals in Rust - part 2](https://www.jameselford.com/blog/working-with-signals-in-rust-pt2-nonlocal-behaviour/#:~:text=Let%27s%20just%20dwell%20for%20a,to%20automatically%20restart)). The default behavior when using `sigaction` without `SA_RESTART` is that system calls will be interrupted (unless the system is configured to restart them by default). In our code, we had `sa_flags = 0`, which typically means "no SA_RESTART", so for instance if SIGSEGV arrived and our program was in the middle of a blocking I/O call in another thread, that call might error out with `EINTR`. Given the program is about to terminate, this is not a big issue, but it's something to remember for other signal handlers.

**6. Multi-threaded considerations:** In a multi-threaded program, a signal can be delivered to any thread that does not have it blocked. For synchronous signals like SIGSEGV caused by a fault, it will target the thread that caused the fault. When our handler runs, it runs in the context of that thread. If other threads are running, they are _not_ automatically stopped (they continue until the OS possibly pauses them when the crashing thread enters the handler or when the process aborts). This means if you attempt to do complex things (like print to a log that uses a mutex), another thread might have that mutex locked, causing your handler to deadlock waiting for it ([Unix Signals in Rust - The Rust Programming Language Forum](https://users.rust-lang.org/t/unix-signals-in-rust/733#:~:text=%40caleb%2C%20unfortunately%20your%20signal%20handler,but%20not%20the%20signal%20handler)). The best practice is to avoid needing locks in the handler. For example, if you want to log to a file, open a dedicated file descriptor in advance and use `write` with an atomic `write()` call (which is safe) instead of going through a logging framework that might use mutexes. If you want to signal another thread to do something, you could use an `AtomicBool` or similar to flag it (of course, if it's a crash, you likely just want to die rather than try to recover via another thread). Also, remember that the signal disposition is global – calling `sigaction` in one thread affects the whole process. If you have multiple threads setting handlers, be careful not to stomp on each other (usually you set them once at startup).

**7. When to use `panic::catch_unwind` vs signal handlers:** Use `catch_unwind` for isolating Rust panics (recoverable errors in threads or libraries that might panic). Use signal handlers for truly unrecoverable conditions (segfaults, etc.) that cannot be turned into Rust errors. They serve different purposes and are often used in tandem: for example, a thread pool might catch unwinding panics to keep the thread alive, but if that thread segfaults, there's no catching that with Rust code – a signal handler might log it and terminate the process.

**8. Cleaning up resources vs immediate abort:** In a graceful shutdown (say on SIGTERM), you might want to close files, flush logs, etc., in the handler or after it. In a crash scenario, you likely do not want to attempt much cleanup from within the handler (it could be dangerous if the state is corrupt). If you must do some cleanup (like removing a partially written output file to avoid leaving a corrupt file), make sure the functions you call are safe (for example, `unlink` is async-signal-safe ([Who’s at Fault: Tracking Down Segfaults in Production](https://blog.discourse.org/2021/10/tracking-down-segfaults-in-production/#:~:text=You%20could%20however%20use%20a,safe))). It's often better to let the OS clean up resources when the process exits, rather than doing it in the handler and possibly getting stuck.

**9. Testing your handlers:** It can be tricky to test a crash handler. One way is to deliberately induce a crash. For example, you can create a small unsafe block to write to a null pointer (causing SIGSEGV) and see if your handler prints the backtrace and aborts as expected. Or send the signal to your process with `libc::raise(SIGSEGV)` or using the shell command `kill -SIGSEGV <pid>`. Keep in mind, as one Rust user observed, sending a SIGSEGV with `kill` might behave differently than an actual fault – e.g., Rust's guard page handler for stack overflow will see a manually sent SIGSEGV as something it doesn't know how to handle (it might ignore the first one due to how it's set up) ([Is SIGSEGV handled by Rust runtime? - The Rust Programming Language Forum](https://users.rust-lang.org/t/is-sigsegv-handled-by-rust-runtime/45680#:~:text=then%20%60kill%20,does%20result%20in%20a%20sigsegv)) ([Is SIGSEGV handled by Rust runtime? - The Rust Programming Language Forum](https://users.rust-lang.org/t/is-sigsegv-handled-by-rust-runtime/45680#:~:text=The%20intent%20is%20that%20returning,stuff%20if%20we%20just%20aborted)). But for our custom handler, it should trigger it regardless. This kind of testing should be done in a controlled environment, as it will crash the program.

**10. Documentation and disable in production:** If you incorporate a crash handler in a library or application, document it for users. Sometimes, crash handlers can interfere with debuggers (for example, if a debugger is attached, developers might prefer the program to just crash and break in the debugger rather than your handler catching it). You might consider enabling the crash handler only in certain builds (like only when not running under a debugger, or provide an opt-out flag). Some crash reporting libraries detect if a debugger is present (e.g., by checking `stderr` for being a TTY) and disable themselves to not confuse the debugging process.

In summary, writing a signal handler in Rust (or any language) requires caution: use the right APIs (`sigaction`), do minimal work in the handler, ensure you handle special cases like stack overflow by using an alternate stack, and accept that the primary goal is to record information and terminate, not to recover. With these best practices, you can avoid common pitfalls such as deadlocks or missing critical information.

## Debugging and Logging Signals in Rust

Even with a crash handler in place, you'll often need to **debug** and **analyze** crashes using external tools. Here are some strategies and tools:

**Using a debugger (gdb/lldb):** The traditional way to debug a segmentation fault or similar is to run the program under a debugger. For Rust programs on Linux, you can use GDB with Rust's pretty-printers (the `rust-gdb` wrapper sets those up) or LLDB (which has some Rust support). If your program crashes (with or without a custom handler), the debugger can catch the signal. For example, in gdb you can do: `run` and when it says "Program received signal SIGSEGV", use the `bt` (backtrace) command to see where it happened ([Who’s at Fault: Tracking Down Segfaults in Production](https://blog.discourse.org/2021/10/tracking-down-segfaults-in-production/#:~:text=Once%20this%20is%20loaded%2C%20you%E2%80%99ll,portion%20of%20the%20lengthy%20backtrace)). If you have debug symbols enabled (compile in debug mode or with `-g` flags), the backtrace will show you Rust function names and line numbers. This is extremely useful to pinpoint the cause of the crash. If you use a custom handler that calls `abort()`, the actual crash seen by the debugger might be a SIGABRT after your log is printed. You can still see the earlier context by looking at the backtrace when the SIGSEGV was caught (if you break on SIGSEGV inside gdb, you might want to configure gdb **not** to skip your handler; e.g., `handle SIGSEGV nostop noprint` to let it go to your handler, or actually you might want it to stop _before_ the handler runs by default). Another approach: run `gdb` on the core dump after the fact.

**Core dumps:** A core dump is a file containing the memory of the program at the moment it crashed. On Linux, you may need to enable core dumps (e.g., `ulimit -c unlimited` in your shell to remove size limits). By default, when your Rust program crashes due to a signal like SIGSEGV or SIGABRT, you'll see a message "(core dumped)" and a file like `core` or `core.<pid>` might appear (depending on system settings). You can load this file in gdb: `gdb ./myprogram core` and then use `bt` to get a backtrace of the crash post-mortem ([Who’s at Fault: Tracking Down Segfaults in Production](https://blog.discourse.org/2021/10/tracking-down-segfaults-in-production/#:~:text=match%20at%20L260%20,c%3A664)). This is useful for production systems where you cannot interactively debug. Modern Linux systems often pipe core dumps to a handler (like systemd-coredump or Apport) rather than writing to the working directory. You can configure the core file location and pattern via `/proc/sys/kernel/core_pattern` ([Who’s at Fault: Tracking Down Segfaults in Production](https://blog.discourse.org/2021/10/tracking-down-segfaults-in-production/#:~:text=Since%20Linux%202,19)). In fact, as shown in an example ([Who’s at Fault: Tracking Down Segfaults in Production](https://blog.discourse.org/2021/10/tracking-down-segfaults-in-production/#:~:text=%24%20cat%20%2Fproc%2Fsys%2Fkernel%2Fcore_pattern%20%7C%2Fusr%2Flocal%2Fsbin%2Fprocess,E)), you can set the core pattern to pipe to a custom program (this is how crash reporting daemons work) – but that's an advanced topic. The main point: core dumps combined with symbolic debuggers allow you to inspect the state of the program after a crash thoroughly (you can examine variables, memory, etc., not just the backtrace). Signals that produce core dumps by default include SIGSEGV, SIGILL, SIGBUS, SIGFPE, SIGABRT, SIGTRAP, etc ([Who’s at Fault: Tracking Down Segfaults in Production](https://blog.discourse.org/2021/10/tracking-down-segfaults-in-production/#:~:text=Signal%20%20%20%20Comment,SVr4)).

**Logging strategies for crashes:** If you have a crash handler in Rust, as we wrote, it will log to stderr. Ensure that stderr is being captured or stored somewhere useful. For example, if this is a server running under systemd, stderr might go to journald – you want to make sure those backtrace logs are saved. If you prefer logging to a file, you might modify the handler to write to a pre-opened log file descriptor (using `write` directly). For instance, open "crash.log" at startup and store its FD in a global, then in the handler use `libc::write(fd, message)` to append data. Because we cannot safely use formatted I/O in the handler, you might pre-format some strings (though the dynamic data like backtrace obviously is obtained on the fly). If the backtrace is large, writing it with simple writes could be cumbersome but doable. Some crash reporting libraries fork a child process in the handler to handle logging outside the context of the crash – that's complex and usually overkill.

**Backtrace accuracy:** The quality of the backtrace you get in a crash handler can vary. In Rust, if you use the `backtrace` crate or `std::backtrace`, it relies on debug info to translate return addresses to function names and lines. Make sure your program has symbols (e.g., compile as `cargo build` (debug) or `cargo build --release` but with `debug = true` in the `[profile.release]` in Cargo.toml to keep some debug info). If you strip the binary, backtraces will just show addresses or minimal symbols. For better results, you can also use tools like `addr2line` on addresses. In fact, if your crash handler only prints addresses (which could happen if symbol resolution is off), you can later feed those addresses into `addr2line -e myprogram 0xdeadbeef` to find lines (provided the binary still has debug info or you have separate .pdb/.dSYM etc. on other platforms).

**Using AddressSanitizer or Valgrind:** These aren't exactly signal handling, but worth mentioning as debugging tools. AddressSanitizer (ASan) is a tool that can detect memory errors and will deliberately abort the program with diagnostics when it finds an issue. It uses its own way of handling crashes (it may catch segfaults or provoke SIGABRT with a stack trace). If you're chasing a hard-to-find memory bug, sometimes compiling your Rust program with ASan (e.g., with `-Zsanitize=address` on nightly or using a custom build) can pinpoint the issue without you having to rely on catching the signal yourself. Valgrind is another tool (works on Linux) that runs the program in an instrumented environment to catch invalid memory accesses. These tools complement your crash handling: your handler tells you "something bad happened here", and then you might use ASan/Valgrind to get deeper insight.

**Working with `RUST_BACKTRACE`:** Remember that `RUST_BACKTRACE=1` enables backtraces for Rust _panics_ (i.e., if a thread panics, it will print a backtrace of that panic). This does not apply to segmentation faults or aborts. If your program simply crashes with no panic, `RUST_BACKTRACE` won’t magically produce a backtrace – that’s exactly why we implement our own signal handler or rely on a debugger. So don’t be confused: `RUST_BACKTRACE` is great for debugging Rust panics, but for native crashes you need the approaches discussed (signal handlers, core dumps, etc.).

**Example scenario (SIGSEGV debugging):** Suppose your Rust program crashes with a segfault and you have the crash handler installed. You run the program, and you see output like:

```
Caught signal 11
stack backtrace:
   0: myapp::signal_handler
   1: ??? (maybe some address or library)
   2: ??? 
   3: myapp::some_function at src/lib.rs:123
   4: myapp::main at src/main.rs:10
   5: __libc_start_main ...
   6: _start ...
Aborted (core dumped)
```

This tells you that a SIGSEGV occurred, and by looking at the backtrace you see it happened in `some_function` at lib.rs line 123. Perhaps you go to that line and realize you're dereferencing a pointer that might be null due to a logic bug in unsafe code. You fix the bug. If the backtrace had many `???`, it means symbol resolution failed for some addresses – you might then load the core in gdb and do `bt` to get a more detailed trace or ensure you compiled with debug symbols.

**Example scenario (SIGILL debugging):** If you catch an illegal instruction, the handler might show you a backtrace leading to some function and then an instruction that caused SIGILL. Illegal instructions can be tricky – sometimes it means you jumped to random data. Using a debugger, you can inspect the registers and memory at the crash to see what instruction was being executed. Often, though, it might hint that you called a function via a bad pointer. The backtrace may or may not resolve properly if the instruction pointer was in nonsense territory. But you could at least see which function attempted the call. Logging the `signum` is useful to differentiate these cases (SIGILL vs SIGSEGV, etc.) and handle accordingly if needed.

**Real-world usage:** Crash signal handlers are often used in systems that need to log crashes automatically. For instance, a web server might log a crash and then exit, and a monitoring service restarts it. Or a game engine might catch crashes to save a crash report file for developers (including the stack trace). In Rust, there's an example of a project using such techniques: the Servo browser engine (an experimental project in Rust) had a crash handling module to log crashes (likely similar in concept to what we described). Another example is the `signal-hook` crate (commonly used for SIGINT/SIGTERM) – while it's mainly for graceful shutdown, it could be extended for crash signals with caution (it actually specifically says to avoid heavy work in the handler by using a pipe trick to communicate with the main program). Our approach here is more direct (doing the logging in the handler).

In conclusion, to effectively debug signals in Rust:

- Use a combination of in-process handlers (for immediate info) and external tools like debuggers and core dumps (for deep inspection).
- Ensure your program is compiled with debug information during development so that backtraces are meaningful.
- Log the signal number and stack trace in the handler.
- Collect core dumps in production if feasible, as they can be loaded later to find out exactly what happened.
- Test the crash reporting mechanism to be sure it works when a crash actually happens (there's nothing worse than a crash handler that itself crashes or deadlocks).

By following these practices, you can turn a nasty mysterious crash into a more manageable problem with a clear trail of breadcrumbs (log messages or core files) to diagnose and fix the root cause.

## Comparative Scenarios for Different Signals

Let's go through some specific signals (SIGSEGV, SIGILL, SIGBUS, SIGFPE, SIGABRT, SIGTRAP) and discuss example scenarios in Rust where they might occur, and how one might handle or react to them. We’ll also compare the nature of these signals to understand why and when each occurs.

- **SIGSEGV (Segmentation Fault):** This is the most common "crash" signal. Scenario: suppose you have an `unsafe` block in Rust where you manually dereference a raw pointer that might be invalid. For example:
    
    ```rust
    unsafe {
        let ptr = 0xdeadbeef as *mut i32;
        *ptr = 42;  // attempt to write to an arbitrary memory address
    }
    ```
    
    If `0xdeadbeef` is not a valid mapped address (very likely it's not), the CPU will raise a segmentation fault and the OS sends SIGSEGV to your process ([Who’s at Fault: Tracking Down Segfaults in Production](https://blog.discourse.org/2021/10/tracking-down-segfaults-in-production/#:~:text=It%27s%20probably%20best%20to%20discuss,SEGV%20stands%20for%20%27segmentation%20violation)). Another scenario is a null pointer dereference:
    
    ```rust
    unsafe {
        let ptr = std::ptr::null_mut::<i32>();
        *ptr = 13; // boom, null dereference
    }
    ```
    
    This will also trigger SIGSEGV (address 0 is not accessible). In safe Rust, you can't directly get a null dereference, but it could happen if interfacing with C or using `Option<NonNull<T>>` incorrectly, etc. **Stack overflow** is another cause of SIGSEGV – if you create infinite recursion or allocate a very large stack array, eventually you'll hit the guard page and get SIGSEGV at the point of overflow. By default, any of these will terminate the process (and probably dump core). With our crash handler, as soon as the segfault occurs, we catch it, print a backtrace (which will show exactly where that invalid access was attempted), then abort. The proper "response" to a SIGSEGV is almost always to fix the bug causing it. There's no recovering, but the info we log is crucial. If this were a C program, the approach and outcome are the same: catch it to log, but not continue execution.
    
- **SIGILL (Illegal Instruction):** Scenario: imagine using Rust's inline assembly or CPU intrinsics incorrectly. For instance:
    
    ```rust
    #[cfg(target_arch = "x86_64")]
    unsafe fn trigger_sigill() {
        core::arch::asm!("ud2", options(nomem, nostack));
    }
    fn main() {
        unsafe { trigger_sigill() };
    }
    ```
    
    The `ud2` instruction on x86_64 is explicitly defined to cause an illegal instruction trap – it's a way to intentionally trigger SIGILL (assemblers often use it for marking unreachable code). Running this will send SIGILL. Another scenario: you compiled your Rust program for a CPU with certain features (say AVX instructions) but run it on an older CPU lacking them – then when it executes an unknown opcode, SIGILL occurs. If memory is corrupted and a function pointer or return address gets clobbered, the CPU might try to execute data as code leading to SIGILL as well (or SIGSEGV if it points to unmapped memory). In any case, our handler would catch SIGILL similarly. The backtrace might show the context (e.g., that it was inside `trigger_sigill`). For CPU feature issues, one might handle SIGILL by, for example, detecting and logging that an illegal instruction occurred (maybe logging the instruction pointer from `ucontext` if using `SA_SIGINFO` for advanced uses). But typically, you treat it as a fatal error. In debugging, if you see SIGILL, check if you're using any inline assembly or intrinsics, and ensure compatibility with the running environment. In Rust, safe code won't emit illegal instructions on its own (if it does, that's a compiler bug).
    
- **SIGBUS (Bus Error):** Scenario: Bus errors are a bit less common on x86 but can occur on other architectures or certain situations. One classic cause is **misaligned memory access** on architectures that require alignment. For example, on some RISC architectures, trying to read a 32-bit integer from an address that's not 4-byte aligned could raise SIGBUS. Rust's reference types enforce alignment, but with raw pointers one could misalign. Another scenario is dealing with memory-mapped files: if you `mmap` a file into memory and then the file is truncated, accessing the part of the memory that no longer maps to physical storage can cause a SIGBUS. Or if your program somehow jumps to an instruction at an address that is correct but not properly aligned (some CPUs might give SIGBUS instead of SIGILL – this is platform-specific). In Rust, a misalignment scenario could be created with unsafe code like constructing a `&u32` from an odd address. If running on a strict alignment architecture, that could bus fault. Our crash handler would treat SIGBUS just like SIGSEGV: catch and log. The backtrace will show where it happened. The default OS behavior is the same (terminate + core). Debugging SIGBUS often involves checking alignment or memory mapping issues. For example, if you see SIGBUS, and your code uses `std::fs::File::map` or some unsafe buffer tricks, that’s a clue.
    
- **SIGFPE (Floating-Point Exception):** Despite the name, this signal covers errors like division by zero or overflow in certain arithmetic operations ([crash_handler - Rust](https://docs.rs/crash-handler#:~:text=)). In Rust, by default, integer overflow in debug mode causes a panic (not a signal), and in release mode it wraps (no signal). Division by zero on integers in Rust triggers a panic (which then may abort) rather than a CPU trap. However, in C, dividing by zero (integers) isn't caught – it might cause undefined behavior or sometimes a SIGFPE for floating-point division by zero (on x87 FPUs, dividing float by zero raises a floating point exception which can translate to SIGFPE if unmasked). Rust’s safe code usually doesn't produce SIGFPE, but it could happen if:
    
    - You call into some C code that does a bad math operation.
    - You deliberately enable hardware floating point exceptions. For instance, using C’s `feenableexcept` to turn on exceptions for invalid operations, then performing one.
    - Or possibly on certain architectures, integer overflow might raise SIGFPE (though on mainstream ones it doesn't by default).
    
    If a SIGFPE happens, our handler would catch it and log it. The backtrace might indicate the offending operation. For example, maybe you have an `unsafe { asm!("fidivr %st(1), %st(0)") }` or something silly that triggers it. Typically, you'd debug this by looking at what arithmetic operation caused it. Since Rust usually turns these into panics, a SIGFPE in a Rust program is rare. (One edge case: **NaN payloads** or other FPU anomalies usually don't SIGFPE unless explicitly configured.)
    
- **SIGABRT (Abort):** This signal is a bit different because it's usually _intentionally_ raised by the program calling `abort()` or failing an assertion in C, etc. In Rust, a thread panic that is not caught will by default terminate the thread and then the runtime will abort the process (resulting in SIGABRT). Also calling `std::process::abort()` directly triggers SIGABRT immediately. Other things that cause abort: double panic (if a panic occurs while unwinding from another panic, the runtime will abort to avoid unwinding unsoundness), or calling `assert!(…);` in Rust that fails when compiled with `panic = "abort"` (since that panic becomes an abort). If we set up a handler for SIGABRT, it would catch these. But as discussed, handling SIGABRT is tricky because our handler itself calls abort. If we were to handle SIGABRT, we would need to change our strategy: maybe print a message like "Process aborting (SIGABRT) - possible panic or assert!" and then call `_exit(1)` to terminate without looping. Many crash handlers either ignore SIGABRT (let it crash normally) or handle it with care. In comparative terms, SIGABRT is _not_ a "memory error" but a deliberate crash. The presence of SIGABRT usually means the program decided to crash (for example, an `assert!(false)` in Rust in an aborting panic mode, or an explicit call). If you see a SIGABRT crash in a Rust program, often the stderr output or panic message is more informative (Rust prints something like "panic occurred: ..."). Our handler might actually obscure a panic message if we caught SIGABRT, so another reason we commented it out. In debugging, if you get SIGABRT, check for panic messages or assertion failures. The exit code for SIGABRT is typically 134 (on Linux, since it's signal 6 + 128).
    
- **SIGTRAP (Trap/BPT trap):** Rust normally doesn’t raise SIGTRAP by itself except in two cases: if you use the `std::intrinsics::breakpoint()` (an unsafe intrinsic to emit a breakpoint trap), or if a debugger is attached and sets breakpoints (those cause SIGTRAP internally to pause execution). Also, the macro `debug_assert!` in Rust in debug mode just becomes a normal assert (panic), not a trap. But in some systems, an assertion failure in C might call `__builtin_trap()` which is an illegal instruction or trap. Anyway, if your program gets SIGTRAP and you didn't explicitly trigger it, it could be due to a debugger or an environment like ptrace. If we had a handler for SIGTRAP, it might interfere with debugging (since debuggers expect to catch traps). It's uncommon to handle SIGTRAP in a crash handler; typically you don't catch it – you let the debugger handle it. For completeness, if our handler caught SIGTRAP, we could log "Trace/breakpoint trap occurred" ([crash_handler - Rust](https://docs.rs/crash-handler#:~:text=)). This would likely only happen if someone deliberately put an `int3` in code for testing.
    
- **SIGQUIT (Quit from keyboard):** This is triggered by Ctrl+\ in the terminal. It terminates the program and by default _does_ generate a core dump (unlike Ctrl+C which doesn't). We didn't include SIGQUIT in our handler list, but if you wanted, you could handle it. It's not exactly a "crash" but often considered a "quit and dump" signal. Many programs just leave it as default (so a user can hit Ctrl+\ to force a core). If you handle it, you might print something and still abort.
    
- **SIGPIPE (Broken pipe):** Just to reiterate from earlier, SIGPIPE is not a bug signal but happens when writing to a closed pipe or socket. Rust by default will terminate the process if a SIGPIPE is raised (for example, writing to stdout when the pipe is closed because the other end exited). Most Rust programs that deal with I/O set `libc::signal(libc::SIGPIPE, libc::SIG_IGN)` to ignore SIGPIPE, and instead handle the `EPIPE` error from write syscalls. We didn't focus on it because it's not a "crash due to memory error", but in practice, if your program prints to stdout and is piped to `head`, once head closes the pipe, your next write will cause SIGPIPE and kill the program unless handled. If you had our crash handler installed for all signals, it would catch SIGPIPE and abort – which is kind of overkill. Usually you just ignore SIGPIPE. So, it's a good example of why you might not indiscriminately handle every signal the same way.
    

**Real-world examples:**

- A web server written in Rust uses some unsafe optimizations. It experiences a segmentation fault under high load. With our crash handler, the next time it crashes, it logs a backtrace showing the fault in an unsafe block in the connection handling code. The developers use that information to identify a bug (maybe an out-of-bounds access) and fix it. Without the handler, they might only see "segfault (core dumped)" and have to reproduce the issue with a debugger attached to get the backtrace. The handler saved time by capturing it in the moment.
    
- A game engine has a scripting subsystem in Rust that calls out to a C library. If the C library crashes (say it does an illegal memory access), the Rust engine catches the SIGSEGV and logs something like "C library X caused SIGSEGV at address Y, backtrace: ..." to a crash log file, then safely terminates the process or maybe even tries to restart the subsystem (in some controlled sandbox scenario). In this case, the Rust application is acting similarly to how an OS would – isolating the crash and logging it.
    
- An embedded Linux device running Rust software might enable a crash handler to log crashes to persistent storage. For example, if a device in the field experiences a crash, on next boot, developers can retrieve the crash log and see the signal and backtrace. This can be crucial for diagnosing issues that are hard to reproduce locally.
    

**Which signals to handle and which not to:** As a rule of thumb, handle the ones that indicate serious errors that you want to log: SIGSEGV, SIGBUS, SIGILL, SIGFPE, maybe SIGABRT. Possibly SIGTRAP if you have some reason, but usually not needed. Avoid handling SIGKILL/SIGSTOP (impossible anyway) and be cautious with ones like SIGINT/SIGTERM – those you might handle for graceful shutdown (different use-case, not crash). If you do set a handler for SIGTERM for graceful shutdown, keep it separate from your crash handler logic (you don't want to abort on SIGTERM; that one you might `println!("shutting down...")` and exit normally). It's fine to have multiple handlers for different signals doing different things.

In conclusion, different signals have different causes but our approach for crash-like signals is uniform: catch, log, and abort. The differences lie in understanding what caused them:

- SIGSEGV/SIGBUS are memory access issues – look at pointers and memory usage.
- SIGILL is bad CPU instruction – check binaries, CPU features, or code injection.
- SIGFPE is bad math – check divisions or FPU usage.
- SIGABRT is an intentional abort – look for panic or abort calls, or library errors.
- SIGTRAP is a debug breakpoint or trap – typically occurs only under specific circumstances (like debugging or explicit trap instructions).

By comparing these scenarios and signals, a developer becomes better at quickly diagnosing the type of crash: For example, _"We got SIGSEGV, likely a null pointer or invalid slice access in unsafe code. Let's see the backtrace."_ versus _"We got SIGILL on a user's machine – maybe they lack a CPU feature our binary uses; we might need to adjust compile flags."_ Each signal is a clue to the nature of the failure.

Finally, always remember: the goal of handling these signals in Rust isn't to make the program magically correct the error and continue – it's about **observability**. You want to make the bug easier to find by providing information. Once you have that, you go back to the code and fix the root cause (be it removing an unsafe flaw, adding a check to avoid an invalid state, etc.). Rust’s strong type system and borrow checker prevent many of these, but when they slip through (often via `unsafe` or external calls), signals are the mechanism by which the OS tells us something went very wrong. Our job is to listen (via handlers or tools) and then act on that information by improving the code.