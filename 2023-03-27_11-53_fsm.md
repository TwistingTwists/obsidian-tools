---
tags:
  -
---


@startuml

[*] --> StudentSubmitted


StudentSubmitted : Student has submitted the copy.
AssignedToEvaluator : Copy has been assigned for review.

StudentSubmitted  --> AssignToEvaluatorPending
AssignToEvaluatorPending --> AssignedToEvaluator
AssignedToEvaluator --> CheckByEvaluatorPending

CheckByEvaluatorPending --> CheckByEvaluatorRejected
 CheckByEvaluatorRejected --> AssignToEvaluatorPending
CheckByEvaluatorPending --> CheckedByEvaluator


CheckedByEvaluator --> AdminReviewPending
AdminReviewPending --> AdminRejected
AdminRejected --> AssignToEvaluatorPending
AdminRejected --> CheckByEvaluatorPending

AdminReviewPending --> AdminApproved

AdminApproved  --> [*]

@enduml




defmodule MyApp.ClassRoom do
  import Ecto.Query
  alias MyApp.{Repo, User, Course, Subscription, Payment, Test, Submission}

  # 1. Assign submission to a teacher
  def assign_submission_to_teacher(submission_id, teacher_id) do
    with %User{id: ^teacher_id, role: :teacher} <- Repo.get(User, teacher_id),
         %Submission{} = submission <- Repo.get(Submission, submission_id) do
      submission
      |> Submission.changeset(%{evaluated_by: teacher_id})
      |> Repo.update()
    else
      _ -> {:error, "Invalid teacher ID or submission ID"}
    end
  end

  # 2. Student purchase a course
  def purchase_course(student_id, course_id, payment_attrs) do
    with %User{id: ^student_id, role: :student} <- Repo.get(User, student_id),
         %Course{} = course <- Repo.get(Course, course_id),
         {:ok, %Payment{payment_status: "successful"}} <- create_payment(payment_attrs) do
      create_subscription(%{user_id: student_id, course_id: course_id})
    else
      _ -> {:error, "Invalid student ID, course ID, or payment attributes"}
    end
  end

  # Helper function to create payment
  defp create_payment(attrs) do
    %Payment{}
    |> Payment.changeset(attrs)
    |> Repo.insert()
  end

  # Helper function to create subscription
  defp create_subscription(attrs) do
    %Subscription{}
    |> Subscription.changeset(attrs)
    |> Repo.insert()
  end

  # 3. Admin CRUD operations
  def create_admin_resource(module, attrs) do
    changeset = apply(module, :changeset, [%module{}, attrs])
    Repo.insert(changeset)
  end

  def get_admin_resource(module, id), do: Repo.get(module, id)

  def update_admin_resource(module, id, attrs) do
    with %{} = resource <- Repo.get(module, id) do
      changeset = apply(module, :changeset, [resource, attrs])
      Repo.update(changeset)
    else
      _ -> {:error, "Invalid resource ID"}
    end
  end

  def delete_admin_resource(module, id) do
    with %{} = resource <- Repo.get(module, id) do
      Repo.delete(resource)
    else
      _ -> {:error, "Invalid resource ID"}
    end
  end

  # 4. Finite State Machine for Submissions
  defmodule SubmissionFSM do
    use StateMachines,
      transitions: %{
        {:student_submitted, :assign_to_evaluator_pending} => :assigned_to_evaluator,
        {:assigned_to_evaluator, :check_by_evaluator_pending} => :checked_by_evaluator,
        {:checked_by_evaluator, :admin_review_pending} => :admin_approved,
        {:admin_review_pending, :admin_rejected} => [:assigned_to_evaluator, :checked_by_evaluator]
      },
      initial: :student_submitted
  end
end
