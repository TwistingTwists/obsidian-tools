---
tags:
  - weekly
  - logs
aim: Ragas
advice: 
aliases:
  - weekly plan
---

### Focus 

- [ ] [[Codecrafters Kafka]]
- [ ] [[Rust Ardan Labs]]
- [ ] [[Ragas in Elixir]]
	- [ ] [[ML readings]]


Write an accomplishment BIO for yourself. 
- [ ] like this https://zed.dev/team

### Blogs read this week 

<h6 class="h6">  Database - NEON </h6> 

- [ ] https://neon.tech/blog/architecture-decisions-in-neon

<h6 class="h6">  Rust Async Runtimes  </h6> 

* When to use traits in Rust ?
1. These types are technical details the programmers understand, but does not affect how the business logic works at all. So we have them behind traits.

* Radix Humanyun 
Task, Spawner, Exectuor, Waker 

* Monoio (io-uring based rust executor)


 
Pavex : 
https://www.youtube.com/watch?v=cMea6IMRk2s


### Blogs Writing this week 

- [ ] Rust exectuor 
- [ ] Composite Indexes in SQL - explained with Example



#### todo

- [x] setup tmux system for personal work 
	- [ ] ragas
	- [ ] kafka codecrafters
	- [ ] blogging - tasting_curries
- [x] setup tmux for professional work 
	- [ ] ardan labs course rust 
	- [ ] jonhoo videos rust 
	- [x] CREATE VIEWS in obsidian for 
		- [x] files edited today
		- [x] files edited this week
- [ ] [[Event Sourcing]] and Commanded books
- [ ] Setup Blog - Astro + Obsidian setup. The best! 
	- [x] git repo setup 
	- [x] build astro locally? 
		- [ ] cleanup and migrate blog posts
			- [x] draft all shriram's posts
			- [ ] publish first post
		- [ ] cleanup shriram's references
			- [x] image
			- [x] socials
			- [ ] blog live link
			- [ ] company name etc 
			- [x] Name from author etc 
	- [ ] BlogPost: Evals and setting it up in elixir
	- [ ] obsidian local setup
	- [ ] mobile setup obsidian
- [ ] Shivani - Ash Framework - ash_table for quickly updating the views.
	- [x] setup ash with postgres etc. 
	- [ ] domain modelling
	- [ ] migrations
	- [ ] seed data
	- [ ] ash_table
- [ ] Balu skype 
- [ ] Database series 
	- [ ] from todo microsoft
- [ ] OS Series
- [ ] 

Daily Checklist 
- [ ] stord 
	- [ ] checked pr comments
- [ ] shivani 
	- [ ] prepared topic for practice?
	- [ ] 


### Ash Prompts


```
defmodule AshHq.Blog.Post do
  @moduledoc "A blog post. Uses the AshBlog data layer and therefore is static"
  use Ash.Resource,
    domain: AshHq.Blog,
    otp_app: :ash_hq,
    data_layer: AshBlog.DataLayer,
    extensions: [AshHq.Docs.Extensions.RenderMarkdown, AshAdmin.Resource]

  require Ash.Query

  render_markdown do
    render_attributes body: :body_html
  end

  admin do
    table_columns [:slug, :title, :state, :created_at, :id]

    form do
      field :body do
        type :markdown
      end
    end
  end

  actions do
    default_accept :*
    defaults [:create, :read, :update]

    read :published do
      argument :tag, :ci_string

      prepare build(sort: [created_at: :desc])

      filter expr(
               state == :published and
                 if is_nil(^arg(:tag)) do
                   true
                 else
                   ^arg(:tag) in type(tag_names, ^{:array, :ci_string})
                 end
             )
    end

    read :by_slug do
      argument :slug, :string do
        allow_nil? false
      end

      get? true

      filter expr(slug == ^arg(:slug) or ^arg(:slug) in past_slugs)
    end
  end

  attributes do
    uuid_primary_key :id

    attribute :tag_line, :string do
      public? true
      allow_nil? false
      constraints max_length: 250
    end

    attribute :tag_names, {:array, :ci_string} do
      public? true

      constraints items: [
                    match: ~r/^[a-zA-Z]*$/,
                    casing: :lower
                  ]
    end

    attribute :author, :string do
      public? true
      allow_nil? false
    end

    attribute :body_html, :string do
      public? true
      writable? false
    end

    timestamps()
  end

  relationships do
    has_many :tags, AshHq.Blog.Tag do
      public? true

      manual fn posts, %{query: query} ->
        all_tags = Enum.flat_map(posts, &(&1.tag_names || []))

        tags =
          query
          |> Ash.Query.unset([:limit, :offset])
          |> Ash.Query.filter(name in ^all_tags)
          |> Ash.read!()

        {:ok,
         Map.new(posts, fn post ->
           {post.id, Enum.filter(tags, &(&1.name in post.tag_names))}
         end)}
      end
    end
  end

  code_interface do
    define :published
    define :by_slug, args: [:slug]
  end

  changes do
    change fn changeset, _ ->
             Ash.Changeset.after_action(changeset, fn _, %{tag_names: tag_names} = record ->
               all_post_tags =
                 AshHq.Blog.Post.published!()
                 |> Enum.flat_map(&(&1.tag_names || []))

               notifications =
                 Enum.flat_map(
                   tag_names || [],
                   &elem(AshHq.Blog.Tag.upsert!(&1, return_notifications?: true), 1)
                 )

               destroy_notifications =
                 AshHq.Blog.Tag.read!()
                 |> Enum.flat_map(fn tag ->
                   if to_string(tag.name) in all_post_tags do
                     []
                   else
                     AshHq.Blog.Tag.destroy!(tag, return_notifications?: true)
                   end
                 end)

               {:ok, record, notifications ++ destroy_notifications}
             end)
           end,
           on: [:create, :update]
  end
end
```
this is a basic blog post with Ash. Post is called Resource.

this is custom dsl for defining Resources. Here is a brief description of it. 
1. `changes do .. end  ` - section represents the changesets and validations on the data
2. `code_interface` - defines public API exposed from the module
3. `relationships` are postgres relationships between this resource and other resources
4. `attributes` are the columns of the postgres table
5. `actions` are the CRUD related functions defined on the resource.

----- 

Use the above and write Ash Resources based on the following SQL queries. Ensure that you have `attributes` and `relationships` sections included.


```sql
CREATE TABLE topics (
2    id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
3    name TEXT NOT NULL,
4    parent_id BIGINT REFERENCES topics(id) ON DELETE CASCADE
5);
6
7CREATE TABLE topic_progress (
8    id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
9    topic_id BIGINT REFERENCES topics(id) ON DELETE CASCADE,
10    progress_percentage NUMERIC(5, 2) NOT NULL CHECK (progress_percentage >= 0 AND progress_percentage <= 100),
11    progress_date DATE NOT NULL
12);
13
14CREATE TABLE topic_revisions (
15    id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
16    topic_id BIGINT REFERENCES topics(id) ON DELETE CASCADE,
17    revision_number INT NOT NULL,
18    revision_date DATE NOT NULL
19);
```

##### Not important Not Urgent

- 




























