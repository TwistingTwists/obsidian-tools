---
tags:
  - spark
  - ash
  - elixir
---

So to start you need a Dsl module where you define what you want, and then use Spark.Dsl.Extension in it and pass it some sections
You're kinda expected to define your Dsl as a bunch of structs in module attributes, and then pass that as the options to Spark.Dsl.Extension
You need at least one Section. Sections are like the top level building block of your DSL. They can take arguments and/or entities. Entities are like arguments but you can have many of them and are more structured

For instance, let's say you want to support this syntax:

```elixir
fsm do
  module Slime
  name "Fire blob"

  state :idle
  state :attack
  state :move

  transition :idle, :attack, &attack/3
  transition :attack, :idle, &finsih_attack/3
  transition :idle, :move, &move/3
end
```

You define it as

```elixir
@state %Spark.Dsl.Entity{
  name: :state,
  args: [:name],
  schema: [name: [type: :atom]]
}

@transition %Spark.Dsl.Entity{
  name: :transition,
  args: [:from, :to, :function],
  schema: [
    from: [type: :atom],
    to: [type: :atom],
    function: [type: {:fun, 3}]
  ]
}

@fsm %Spark.Dsl.Section{
  name: :dsm,
  schema: [
    module: [type: :atom],
    name: [type: :string],
  ],
  entities: [@state, @transition] # Makes these entities available inside this section
}

use Spark.Dsl.Extension, sections: [@fsm]
```


With your DSL defines, you now need an extension module that does some actual work, so if you did that in defmodule Fsm.Dsl do, then you define the extension as

```elixir
defmodule Fsm do
  use Spark.Dsl, default_extensions: [extensions: Fsm]
end
```

Now the user of your dsl needs to use that:

```elixir
defmodule MyUserCode do
  use Fsm

  fsm do
    ...
  end
end
```


That will generate a spark_dsl_config/0 that you can use to fetch the Dsl information and generate code or whatever you want to do with it, but you didn't have to write any macro code to support the dsl syntax
