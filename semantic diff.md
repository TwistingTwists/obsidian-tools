This is a fascinating area of software engineering research. "Semantic diffing" moves beyond the line-based comparisons of standard `git diff` (which uses Myers' algorithm) to understand code structure, moves, renames, and refactorings.

Here is a curated list of the most relevant papers and algorithms, categorized by their approach.

### **I. The "Gold Standard" (AST-Based Algorithms)**

These papers propose algorithms that parse code into Abstract Syntax Trees (ASTs) to compute differences.1 This is the foundation of most modern "semantic diff" tools.

- **The Baseline Paper:**
    
    - **"Fine-grained and Accurate Source Code Differencing" (GumTree)**
        
        - _Authors:_ Falleri et al. (2014)2
            
        - _Why it matters:_ This is the **seminal paper** in the field. It introduced the **GumTree algorithm**, which is likely the engine behind most "semantic diff" tools you encounter today. It uses a top-down and bottom-up matching phase to map nodes between two ASTs, allowing it to detect moved code and wrapped statements that line-based diffs miss.
            
        - _Key Concept:_ Isomorphic subtree matching.
            
- **The Improvements (State-of-the-Art):**
    
    - **"Generating Accurate and Compact Edit Scripts using Tree Differencing" (IJM)**
        
        - _Authors:_ Frick et al. (2018)3
            
        - _Why it matters:_ This paper proposes the **Iterative Java Matcher (IJM)**.4 It critiques GumTree for sometimes generating "correct but inaccurate" edit scripts (e.g., deleting a node and re-inserting it effectively the same way). IJM improves detection of _updates_ and _moves_ to reflect developer intent better.
            
    - **"HyperDiff: Computing Source Code Diffs at Scale"**
        
        - _Authors:_ Dilavrec et al. (2024/2025 timeframe for recent optimizations)
            
        - _Why it matters:_ AST differencing is slow (O(n^2) or worse). HyperDiff focuses on making these structural diffs scalable for massive repositories and commit histories using lazified loading and specialized data structures.
            

---

### **II. Refactoring Detection (Intent-Based)**

These papers don't just find _what_ changed, but _how_ it changed (e.g., "Method `foo` was renamed to `bar`" rather than "Line 10 removed, Line 15 added").

- **"RefactoringMiner 2.0"**
    
    - _Authors:_ Tsantalis et al. (2020)
        
    - _Why it matters:_ This is currently the industry standard for mining refactorings. If you want a diff that says "Extract Method" instead of showing you a block of added code, this is the algorithm to study. It achieves incredibly high precision (99%+) by tracking code elements even after heavy modifications.
        
    - _Key Concept:_ Statement matching combined with structural constraints to identify high-level operations.
        
- **"RefDiff: A Multi-language Refactoring Detection Tool"**
    
    - _Authors:_ Silva et al. (2020)
        
    - _Why it matters:_ Offers a language-agnostic approach to refactoring detection, using a plugin system to support Java, JavaScript, and C. It matches code elements based on similarity of their structure and dependencies.
        

---

### **III. The Frontier (LLMs & Deep Learning)**

The cutting edge is moving away from strict tree matching toward statistical and neural approaches that "understand" the code's semantics (meaning) via embeddings or LLMs.

- **"What a diff makes: automating code migration with large language models"** (Oct 2025)
    
    - _Why it matters:_ A very recent paper exploring how LLMs can utilize diffs to perform complex code migrations.5 It provides evidence that providing "semantic diffs" (or diff-aware contexts) to LLMs significantly improves their ability to reasoning about code evolution.
        
- **"BDiff: Block-aware and Accurate Text-based Code Differencing"** (Oct 2025)6
    
    - _Why it matters:_ This paper bridges the gap between text and structure. It proposes a text-based algorithm that is "block-aware," meaning it can identify moved blocks of code without the full overhead of AST parsing, outperforming standard diffs while remaining faster than full AST approaches.
        
- **"GraphCodeBERT: Pre-training Code Representations with Data Flow"**
    
    - _Why it matters:_ While not a "diff" paper per se, this is the foundational work for **Semantic Similarity**. If you want to build a diff tool that says "Function A is semantically identical to Function B despite different variable names," you would use the embeddings generated by this model (or its successors) to calculate vector similarity.
        

---

### **IV. Semantic Merging (Conflict Resolution)**

Diffing is often a precursor to merging. These papers tackle "Semantic Conflicts"â€”where code merges cleanly textually but breaks the program logic.

- **"Detecting semantic merge conflicts with variability-aware execution" (Semex)7**
    
    - _Authors:_ Nguyen et al.
        
    - _Why it matters:_ It introduces the idea of executing the merged program to find conflicts that static analysis misses.
        
- **"Symbolic Execution to Detect Semantic Merge Conflicts"**
    
    - _Why it matters:_ Uses symbolic execution (exploring all possible program paths mathematically) to prove whether a merge introduces conflicting behavior.
        

### **Summary of "Next Steps"**

1. **For a practical tool you can use now:** Look at **[Difftastic](https://difftastic.wilfred.me.uk/)**. It implements a structural diffing algorithm (similar to GumTree) and is usable in the terminal today.
    
2. **For research/implementation:** Start by reading the **GumTree** paper. It is the clearest introduction to the problem of "Tree Edit Distance" and how to solve it efficiently for code.
    
3. **For deep learning:** Look into **RefactoringMiner** to understand how to label data, then read **GraphCodeBERT** to understand how to represent that data for a model.

[[semantic diff - model 2 ]]
[[semantic diff - perplexity]]
[[semantic diff - deep research gemini]]
[[semantic diff - deep research chatgpt]]