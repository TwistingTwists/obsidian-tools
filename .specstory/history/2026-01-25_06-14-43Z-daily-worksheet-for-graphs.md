<!-- Generated by SpecStory, Markdown v2.1.0 -->

# 2026-01-25 06:14:52Z

<!-- Claude Code Session 8a0f207a-8928-4aeb-817e-35a4edc794a8 (2026-01-25 06:14:52Z) -->

_**User (2026-01-25T06:14:52.553Z)**_

Â Daily worksheet for graphs.md

  for this file - make a concrete question wise path for me.

  see the directory TheEssay (look at previous sessions for this) 

---

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:14:56.514Z)**_

<think><details><summary>Thought Process</summary>
The user wants me to:
1. Read the file "Daily worksheet for graphs.md"
2. Look at the directory "TheEssay" to understand the context from previous sessions
3. Create a concrete question-wise path for them

Let me start by reading the file and exploring the directory.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:14:57.172Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./Daily worksheet for graphs.md`
```
     1â†’# 30-Day Graph Mastery Schedule for Google Interviews
     2â†’
     3â†’## Week 1: Foundations & Core Traversals
     4â†’
     5â†’### **Day 1: Graph Basics & Representation**
     6â†’**Key Focus:** Understanding graph fundamentals
     7â†’- **Theory (2 hrs):**
     8â†’  - Graph types: directed, undirected, weighted, unweighted
     9â†’  - Representations: adjacency list, adjacency matrix, edge list
    10â†’  - When to use each representation
    11â†’- **Practice (2 hrs):**
    12â†’  - Build graphs from edge lists manually
    13â†’  - Implement adjacency list and matrix
    14â†’  - **Problem:** 1971 (Find if Path Exists in Graph)
    15â†’- **Achievement:** Can build any graph representation from scratch
    16â†’
    17â†’---
    18â†’
    19â†’### **Day 2: DFS - Depth First Search**
    20â†’**Key Focus:** Master recursive and iterative DFS
    21â†’- **Theory (1 hr):**
    22â†’  - DFS algorithm, call stack visualization
    23â†’  - Visited set management
    24â†’  - Time/space complexity analysis
    25â†’- **Practice (3 hrs):**
    26â†’  - Implement both recursive and iterative DFS
    27â†’  - **Problems:** 
    28â†’    - 797 (All Paths From Source to Target) â­
    29â†’    - 547 (Number of Provinces) â­â­
    30â†’    - 695 (Max Area of Island) â­â­
    31â†’- **Achievement:** Can write DFS in sleep, understand stack behavior
    32â†’
    33â†’---
    34â†’
    35â†’### **Day 3: BFS - Breadth First Search**
    36â†’**Key Focus:** Master level-order traversal
    37â†’- **Theory (1 hr):**
    38â†’  - BFS algorithm, queue mechanics
    39â†’  - Level tracking techniques
    40â†’  - BFS vs DFS - when to use what
    41â†’- **Practice (3 hrs):**
    42â†’  - Implement BFS with level tracking
    43â†’  - **Problems:**
    44â†’    - 1091 (Shortest Path in Binary Matrix) â­â­â­â­â­
    45â†’    - 542 (01 Matrix) â­â­â­â­
    46â†’    - 1162 (As Far from Land as Possible)
    47â†’- **Achievement:** Understand why BFS gives shortest path in unweighted graphs
    48â†’
    49â†’---
    50â†’
    51â†’### **Day 4: Grid-based DFS**
    52â†’**Key Focus:** 4-directional/8-directional traversal
    53â†’- **Theory (1 hr):**
    54â†’  - Grid as implicit graph
    55â†’  - Direction arrays: `[(0,1), (1,0), (0,-1), (-1,0)]`
    56â†’  - Boundary checking
    57â†’- **Practice (3 hrs):**
    58â†’  - **Problems:**
    59â†’    - 200 (Number of Islands) â­â­â­â­â­
    60â†’    - 463 (Island Perimeter)
    61â†’    - 1254 (Number of Closed Islands)
    62â†’- **Achievement:** Can navigate any grid problem with confidence
    63â†’
    64â†’---
    65â†’
    66â†’### **Day 5: Grid-based BFS & Multi-source BFS**
    67â†’**Key Focus:** Simultaneous propagation from multiple sources
    68â†’- **Theory (1 hr):**
    69â†’  - Multi-source BFS pattern
    70â†’  - Why it works for "nearest" problems
    71â†’- **Practice (3 hrs):**
    72â†’  - **Problems:**
    73â†’    - 994 (Rotting Oranges) â­â­â­â­â­
    74â†’    - 286 (Walls and Gates)
    75â†’    - 1765 (Map of Highest Peak)
    76â†’- **Achievement:** Can handle complex BFS scenarios with multiple starting points
    77â†’
    78â†’---
    79â†’
    80â†’### **Day 6: Clone & Copy Problems**
    81â†’**Key Focus:** Deep copying graph structures
    82â†’- **Theory (1 hr):**
    83â†’  - Handling node references
    84â†’  - HashMap for oldâ†’new node mapping
    85â†’- **Practice (3 hrs):**
    86â†’  - **Problems:**
    87â†’    - 133 (Clone Graph) â­â­â­â­â­
    88â†’    - 138 (Copy List with Random Pointer)
    89â†’- **Achievement:** Understand reference handling in graph problems
    90â†’
    91â†’---
    92â†’
    93â†’### **Day 7: Week 1 Review & Assessment**
    94â†’**Key Focus:** Consolidation
    95â†’- **Morning (2 hrs):** Redo hardest problem from each day
    96â†’- **Afternoon (2 hrs):** 
    97â†’  - Solve 2 random easy/medium problems blind
    98â†’  - Write out DFS/BFS templates from memory
    99â†’- **Achievement:** Solid foundation in basic graph traversals
   100â†’
   101â†’---
   102â†’
   103â†’## Week 2: Advanced Patterns & Cycle Detection
   104â†’
   105â†’### **Day 8: Cycle Detection in Undirected Graphs**
   106â†’**Key Focus:** Parent tracking method
   107â†’- **Theory (1.5 hrs):**
   108â†’  - DFS with parent parameter
   109â†’  - Why visiting parent doesn't count as cycle
   110â†’- **Practice (2.5 hrs):**
   111â†’  - **Problems:**
   112â†’    - 684 (Redundant Connection) â­â­â­â­
   113â†’    - 261 (Graph Valid Tree) â­â­â­â­
   114â†’- **Achievement:** Can detect cycles in undirected graphs
   115â†’
   116â†’---
   117â†’
   118â†’### **Day 9: Cycle Detection in Directed Graphs**
   119â†’**Key Focus:** Three-color algorithm
   120â†’- **Theory (1.5 hrs):**
   121â†’  - White (unvisited), Gray (visiting), Black (visited)
   122â†’  - Recursion stack vs visited set
   123â†’- **Practice (2.5 hrs):**
   124â†’  - **Problems:**
   125â†’    - 207 (Course Schedule) â­â­â­â­â­
   126â†’    - 802 (Find Eventual Safe States)
   127â†’- **Achievement:** Master directed graph cycle detection
   128â†’
   129â†’---
   130â†’
   131â†’### **Day 10: Topological Sort - DFS Approach**
   132â†’**Key Focus:** Post-order DFS for topological ordering
   133â†’- **Theory (1.5 hrs):**
   134â†’  - Why post-order gives reverse topological order
   135â†’  - Detecting cycles as prerequisite
   136â†’- **Practice (2.5 hrs):**
   137â†’  - **Problems:**
   138â†’    - 210 (Course Schedule II) â­â­â­â­â­
   139â†’    - 1462 (Course Schedule IV)
   140â†’- **Achievement:** Can produce topological ordering with DFS
   141â†’
   142â†’---
   143â†’
   144â†’### **Day 11: Topological Sort - Kahn's Algorithm (BFS)**
   145â†’**Key Focus:** In-degree based approach
   146â†’- **Theory (1.5 hrs):**
   147â†’  - In-degree calculation
   148â†’  - Processing nodes with in-degree 0
   149â†’  - Cycle detection via count
   150â†’- **Practice (2.5 hrs):**
   151â†’  - **Problems:**
   152â†’    - 210 (Course Schedule II - redo with Kahn's) â­â­â­â­â­
   153â†’    - 310 (Minimum Height Trees)
   154â†’    - 2050 (Parallel Courses III)
   155â†’- **Achievement:** Know both topological sort approaches cold
   156â†’
   157â†’---
   158â†’
   159â†’### **Day 12: Alien Dictionary & Build Order Problems**
   160â†’**Key Focus:** Building graph from implicit constraints
   161â†’- **Theory (1 hr):**
   162â†’  - Extracting edges from ordering constraints
   163â†’  - Handling edge cases (cycles, invalid inputs)
   164â†’- **Practice (3 hrs):**
   165â†’  - **Problems:**
   166â†’    - 269 (Alien Dictionary) â­â­â­â­
   167â†’    - 1203 (Sort Items by Groups Respecting Dependencies)
   168â†’- **Achievement:** Can construct graphs from problem constraints
   169â†’
   170â†’---
   171â†’
   172â†’### **Day 13: Bipartite Graphs**
   173â†’**Key Focus:** Two-coloring with BFS/DFS
   174â†’- **Theory (1.5 hrs):**
   175â†’  - Bipartite definition
   176â†’  - Coloring/grouping algorithm
   177â†’  - Relationship with odd-length cycles
   178â†’- **Practice (2.5 hrs):**
   179â†’  - **Problems:**
   180â†’    - 785 (Is Graph Bipartite?) â­â­â­
   181â†’    - 886 (Possible Bipartition)
   182â†’- **Achievement:** Understand graph partitioning
   183â†’
   184â†’---
   185â†’
   186â†’### **Day 14: Week 2 Review & Mixed Practice**
   187â†’**Key Focus:** Applying patterns
   188â†’- **Morning (2 hrs):** Redo one problem from each pattern
   189â†’- **Afternoon (2 hrs):** Solve 3 random medium problems
   190â†’- **Achievement:** Can identify which pattern to use quickly
   191â†’
   192â†’---
   193â†’
   194â†’## Week 3: Union-Find & Shortest Paths
   195â†’
   196â†’### **Day 15: Union-Find Basics**
   197â†’**Key Focus:** Path compression & union by rank
   198â†’- **Theory (2 hrs):**
   199â†’  - Disjoint sets concept
   200â†’  - Path compression optimization
   201â†’  - Union by rank/size
   202â†’  - Amortized time complexity
   203â†’- **Implementation (2 hrs):**
   204â†’  - Code UnionFind class from scratch
   205â†’  - Test with simple examples
   206â†’- **Achievement:** Have working UnionFind template
   207â†’
   208â†’---
   209â†’
   210â†’### **Day 16: Union-Find Applications**
   211â†’**Key Focus:** Connected components
   212â†’- **Practice (4 hrs):**
   213â†’  - **Problems:**
   214â†’    - 323 (Number of Connected Components) â­â­â­â­
   215â†’    - 684 (Redundant Connection - redo with UF) â­â­â­â­
   216â†’    - 547 (Number of Provinces - redo with UF) â­â­â­
   217â†’    - 1319 (Number of Operations to Make Network Connected)
   218â†’- **Achievement:** Can choose between DFS and Union-Find appropriately
   219â†’
   220â†’---
   221â†’
   222â†’### **Day 17: Advanced Union-Find**
   223â†’**Key Focus:** Dynamic connectivity
   224â†’- **Practice (4 hrs):**
   225â†’  - **Problems:**
   226â†’    - 721 (Accounts Merge) â­â­â­
   227â†’    - 990 (Satisfiability of Equality Equations)
   228â†’    - 1579 (Remove Max Number of Edges to Keep Graph Fully Traversable)
   229â†’- **Achievement:** Handle complex union-find scenarios
   230â†’
   231â†’---
   232â†’
   233â†’### **Day 18: Dijkstra's Algorithm - Theory & Implementation**
   234â†’**Key Focus:** Single-source shortest path in weighted graphs
   235â†’- **Theory (2 hrs):**
   236â†’  - Greedy approach with min-heap
   237â†’  - Relaxation concept
   238â†’  - Why negative weights break it
   239â†’- **Implementation (2 hrs):**
   240â†’  - Code from scratch with heapq
   241â†’  - Test on small examples
   242â†’- **Achievement:** Can implement Dijkstra's without reference
   243â†’
   244â†’---
   245â†’
   246â†’### **Day 19: Dijkstra's Applications**
   247â†’**Key Focus:** Variants and modifications
   248â†’- **Practice (4 hrs):**
   249â†’  - **Problems:**
   250â†’    - 743 (Network Delay Time) â­â­â­â­
   251â†’    - 787 (Cheapest Flights Within K Stops) â­â­â­
   252â†’    - 1631 (Path With Minimum Effort) â­â­â­
   253â†’- **Achievement:** Can modify Dijkstra's for constraints
   254â†’
   255â†’---
   256â†’
   257â†’### **Day 20: Bellman-Ford & Floyd-Warshall**
   258â†’**Key Focus:** Alternative shortest path algorithms
   259â†’- **Theory (2 hrs):**
   260â†’  - Bellman-Ford: handles negative weights
   261â†’  - Floyd-Warshall: all-pairs shortest path
   262â†’- **Practice (2 hrs):**
   263â†’  - **Problems:**
   264â†’    - 787 (Cheapest Flights - redo with Bellman-Ford)
   265â†’    - 1334 (Find the City With Smallest Number of Neighbors)
   266â†’- **Achievement:** Know when to use each shortest path algorithm
   267â†’
   268â†’---
   269â†’
   270â†’### **Day 21: Week 3 Review & Speed Practice**
   271â†’**Key Focus:** Building speed
   272â†’- **Timed Practice (4 hrs):** 
   273â†’  - 6 problems, 40 minutes each
   274â†’  - Mix of Union-Find and shortest path
   275â†’- **Achievement:** Can solve medium problems in interview time
   276â†’
   277â†’---
   278â†’
   279â†’## Week 4: Advanced Topics & Interview Prep
   280â†’
   281â†’### **Day 22: Backtracking on Graphs**
   282â†’**Key Focus:** State restoration in search
   283â†’- **Theory (1 hr):**
   284â†’  - Difference from regular DFS
   285â†’  - When to use backtracking
   286â†’- **Practice (3 hrs):**
   287â†’  - **Problems:**
   288â†’    - 79 (Word Search) â­â­â­â­
   289â†’    - 980 (Unique Paths III) â­â­â­
   290â†’    - 1066 (Campus Bikes II)
   291â†’- **Achievement:** Master backtracking pattern
   292â†’
   293â†’---
   294â†’
   295â†’### **Day 23: Trie + Graph Hybrid**
   296â†’**Key Focus:** Combining data structures
   297â†’- **Theory (1 hr):**
   298â†’  - Trie basics
   299â†’  - Using Trie to optimize graph search
   300â†’- **Practice (3 hrs):**
   301â†’  - **Problems:**
   302â†’    - 212 (Word Search II) â­â­â­â­
   303â†’    - 1233 (Remove Sub-Folders from Filesystem)
   304â†’- **Achievement:** Can combine data structures effectively
   305â†’
   306â†’---
   307â†’
   308â†’### **Day 24: Advanced Grid Problems**
   309â†’**Key Focus:** Complex constraints on grids
   310â†’- **Practice (4 hrs):**
   311â†’  - **Problems:**
   312â†’    - 130 (Surrounded Regions) â­â­â­â­
   313â†’    - 417 (Pacific Atlantic Water Flow) â­â­â­â­
   314â†’    - 1559 (Detect Cycles in 2D Grid)
   315â†’    - 1905 (Count Sub Islands)
   316â†’- **Achievement:** Handle multi-constraint grid problems
   317â†’
   318â†’---
   319â†’
   320â†’### **Day 25: Matrix Problems & Traversals**
   321â†’**Key Focus:** Advanced matrix manipulations
   322â†’- **Practice (4 hrs):**
   323â†’  - **Problems:**
   324â†’    - 127 (Word Ladder) â­â­â­â­
   325â†’    - 433 (Minimum Genetic Mutation)
   326â†’    - 752 (Open the Lock)
   327â†’- **Achievement:** Master transformation graphs
   328â†’
   329â†’---
   330â†’
   331â†’### **Day 26: Minimum Spanning Tree**
   332â†’**Key Focus:** Kruskal's and Prim's algorithms
   333â†’- **Theory (2 hrs):**
   334â†’  - MST concept
   335â†’  - Kruskal's with Union-Find
   336â†’  - Prim's with min-heap
   337â†’- **Practice (2 hrs):**
   338â†’  - **Problems:**
   339â†’    - 1584 (Min Cost to Connect All Points) â­â­â­
   340â†’    - 1135 (Connecting Cities With Minimum Cost)
   341â†’- **Achievement:** Understand MST algorithms
   342â†’
   343â†’---
   344â†’
   345â†’### **Day 27: Graph Coloring & Advanced Patterns**
   346â†’**Key Focus:** Less common but important patterns
   347â†’- **Practice (4 hrs):**
   348â†’  - **Problems:**
   349â†’    - 332 (Reconstruct Itinerary) - Eulerian path
   350â†’    - 1136 (Parallel Courses) - Critical path
   351â†’    - 1436 (Destination City)
   352â†’- **Achievement:** Broaden pattern recognition
   353â†’
   354â†’---
   355â†’
   356â†’### **Day 28: Mock Interview Day 1**
   357â†’**Key Focus:** Simulated pressure
   358â†’- **Format:** 
   359â†’  - 2 problems, 45 minutes each
   360â†’  - Explain approach out loud
   361â†’  - Code in real environment
   362â†’- **Problems:** Pick 1 medium, 1 medium-hard randomly
   363â†’- **Achievement:** Practice interview conditions
   364â†’
   365â†’---
   366â†’
   367â†’### **Day 29: Mock Interview Day 2 & Weak Areas**
   368â†’**Key Focus:** Targeted improvement
   369â†’- **Morning (2 hrs):** Mock with 2 more problems
   370â†’- **Afternoon (2 hrs):** Review mistakes, practice weak areas
   371â†’- **Achievement:** Identify and fix gaps
   372â†’
   373â†’---
   374â†’
   375â†’### **Day 30: Final Review & Confidence Building**
   376â†’**Key Focus:** Solidify knowledge
   377â†’- **Morning (2 hrs):**
   378â†’  - Review all templates
   379â†’  - Quick redo of 5 key problems
   380â†’- **Afternoon (2 hrs):**
   381â†’  - Read problem statements only, identify patterns
   382â†’  - Mental walkthrough of solutions
   383â†’- **Achievement:** Ready for any graph problem Google throws at you!
   384â†’
   385â†’---
   386â†’
   387â†’# Summary Markdown
   388â†’
   389â†’```markdown
   390â†’## 30-Day Graph Mastery Summary
   391â†’
   392â†’### Week 1: Foundations (Days 1-7)
   393â†’- Graph representations & basics
   394â†’- DFS (recursive/iterative) - Problems: 797, 547, 695
   395â†’- BFS & shortest path - Problems: 1091, 542, 1162
   396â†’- Grid DFS - Problems: 200, 463, 1254
   397â†’- Multi-source BFS - Problems: 994, 286, 1765
   398â†’- Graph cloning - Problems: 133, 138
   399â†’
   400â†’**Milestone:** Master basic graph traversals
   401â†’
   402â†’### Week 2: Cycles & Ordering (Days 8-14)
   403â†’- Cycle detection (undirected) - Problems: 684, 261
   404â†’- Cycle detection (directed) - Problems: 207, 802
   405â†’- Topological sort (DFS) - Problems: 210, 1462
   406â†’- Topological sort (Kahn's) - Problems: 210, 310, 2050
   407â†’- Constraint graphs - Problems: 269, 1203
   408â†’- Bipartite graphs - Problems: 785, 886
   409â†’
   410â†’**Milestone:** Master topological sort & cycle detection
   411â†’
   412â†’### Week 3: Union-Find & Shortest Paths (Days 15-21)
   413â†’- Union-Find basics & applications - Problems: 323, 684, 547
   414â†’- Advanced Union-Find - Problems: 721, 990, 1579
   415â†’- Dijkstra's algorithm - Problems: 743, 787, 1631
   416â†’- Bellman-Ford & Floyd-Warshall - Problems: 787, 1334
   417â†’
   418â†’**Milestone:** Master connectivity & shortest paths
   419â†’
   420â†’### Week 4: Advanced & Interview Prep (Days 22-30)
   421â†’- Backtracking - Problems: 79, 980, 1066
   422â†’- Trie + Graph - Problems: 212, 1233
   423â†’- Complex grids - Problems: 130, 417, 1559, 1905
   424â†’- Transformation graphs - Problems: 127, 433, 752
   425â†’- MST algorithms - Problems: 1584, 1135
   426â†’- Mock interviews & review
   427â†’
   428â†’**Milestone:** Interview-ready confidence
   429â†’
   430â†’## Daily Time Commitment
   431â†’- **Weekdays:** 4 hours (2 hrs theory/review, 2 hrs practice)
   432â†’- **Weekends:** 4-5 hours (deeper practice)
   433â†’
   434â†’## Key Templates to Memorize
   435â†’1. DFS (recursive & iterative)
   436â†’2. BFS (with level tracking)
   437â†’3. Union-Find (with path compression)
   438â†’4. Dijkstra's algorithm
   439â†’5. Topological sort (both methods)
   440â†’6. Cycle detection (both graph types)
   441â†’
   442â†’## Success Metrics
   443â†’- âœ… Can recognize pattern in 30 seconds
   444â†’- âœ… Can code solution in 30 minutes
   445â†’- âœ… Can explain time/space complexity
   446â†’- âœ… Can handle follow-up variations
   447â†’```
   448â†’
   449â†’---
   450â†’
   451â†’## Pro Tips for Success
   452â†’
   453â†’1. **Code by hand first** - Don't jump to IDE immediately
   454â†’2. **Explain out loud** - Pretend you're in an interview
   455â†’3. **Time yourself** - Build pressure tolerance
   456â†’4. **Review mistakes thoroughly** - Understand why you got stuck
   457â†’5. **Focus on patterns, not memorization** - Understand the "why"
   458â†’6. **Do problems twice** - First attempt + redo after 3-5 days
   459â†’
   460â†’**You've got this! ğŸš€ Consistent daily practice will make you graph problem master.**
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:14:57.636Z)**_

<tool-use data-tool-type="search" data-tool-name="Glob"><details>
<summary>Tool use: **Glob**</summary>
 pattern `**/TheEssay/**/*`
```
No files found
```
</details></tool-use>

---

_**User (2026-01-25T06:15:00.855Z)**_

[Request interrupted by user]

_**User (2026-01-25T06:15:41.814Z)**_

/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/

see example made for BFS mastery in a md file int hat repo -> you have to improve on that. and integrate the Daily worksheet for graphs.

---

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:15:44.944Z)**_

<tool-use data-tool-type="search" data-tool-name="Glob"><details>
<summary>Tool use: **Glob**</summary>
 path `/home/abhishek/Downloads/delittt/2026-01-06/TheEssay` pattern `**/*.md`
```
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/graph/ai_tut.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/README.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/daily_checklist.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/good_reddit_comments.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/DP/dp_master.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/final_5d_plan.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/10_day_roadmap.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/graph/talk_wtih_polymath.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/graph/shortest_path_with_k_stops.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/graph/shortest_path_in_dag.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/graph/wordladder-II.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/graph/bfs_dfs.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/graph/dijkstra_notes.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/graph/floyd_warshal.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/greedy_roadmap.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/leetcode-screenshotter/ReadMe.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/leetcode-screenshotter/problem-data-parser/ReadMe.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/leetcode-screenshotter/screenshotter/ReadMe.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/resources.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/plan.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/sliding_window/sliding_window_master.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/syntax_you_forget.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/two_pointer/min_unsorted_subarray.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/trees/binary_tree_from_preorder.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/trees/validBSTUnderstandSolveLater.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/trees/kth_smallest_element.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/trees/count_nodes_complete_tree.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/trees/master.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/trees/checkwhentime.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/trees/bst_tree_iterator.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/trees/delete_bst_node.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/two_pointer/partitioning.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/BFS_DFS_EDITORIAL_GUIDE.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/leetcode-screenshotter/.specstory/history/2026-01-23_06-01-42Z-teach-in-in-order.md
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/leetcode-screenshotter/.specstory/history/2026-01-23_05-52-10Z-command-name-model-command.md
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:15:50.985Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/BFS_DFS_EDITORIAL_GUIDE.md`
```
     1â†’# BFS & DFS Editorial Guide
     2â†’
     3â†’This guide shows you how to access BFS and DFS editorials from the LeetCode Screenshotter project.
     4â†’
     5â†’---
     6â†’
     7â†’## What's Available
     8â†’
     9â†’The project has downloaded **editorial code solutions** from LeetCode Premium editorials. You can find them in:
    10â†’
    11â†’```
    12â†’leetcode-screenshotter/editorial_code/
    13â†’  â”œâ”€â”€ 1-999/       (problems 1-999)
    14â†’  â”œâ”€â”€ 1000-1999/   (problems 1000-1999)
    15â†’  â””â”€â”€ 2000-2999/   (problems 2000-2999)
    16â†’```
    17â†’
    18â†’Each problem folder contains code solutions in multiple languages (Python, Java, C++, JavaScript, etc).
    19â†’
    20â†’---
    21â†’
    22â†’## Essential BFS Problems (Level-Order Traversal)
    23â†’
    24â†’| # | Problem | Difficulty | Editorial Path |
    25â†’|---|---------|-----------|-----------------|
    26â†’| 102 | Binary Tree Level Order Traversal | Medium | `1-999/102. Binary Tree Level Order Traversal/` |
    27â†’| 103 | Binary Tree Zigzag Level Order Traversal | Medium | `1-999/103. Binary Tree Zigzag Level Order Traversal/` |
    28â†’| 107 | Binary Tree Level Order Traversal II | Medium | `1-999/107. Binary Tree Level Order Traversal II/` |
    29â†’| 429 | N-ary Tree Level Order Traversal | Medium | `1-999/429. N-ary Tree Level Order Traversal/` |
    30â†’| 637 | Average of Levels in Binary Tree | Easy | `1-999/637. Average of Levels in Binary Tree/` |
    31â†’| 515 | Find Largest Value in Each Tree Row | Medium | `1-999/515. Find Largest Value in Each Tree Row/` |
    32â†’| 513 | Find Bottom Left Tree Value | Medium | `1-999/513. Find Bottom Left Tree Value/` |
    33â†’| 199 | Binary Tree Right Side View | Medium | `1-999/199. Binary Tree Right Side View/` |
    34â†’
    35â†’---
    36â†’
    37â†’## Essential DFS Problems (Tree Traversal)
    38â†’
    39â†’| # | Problem | Difficulty | Editorial Path |
    40â†’|---|---------|-----------|-----------------|
    41â†’| 94 | Binary Tree Inorder Traversal | Easy | `1-999/094. Binary Tree Inorder Traversal/` |
    42â†’| 144 | Binary Tree Preorder Traversal | Easy | `1-999/144. Binary Tree Preorder Traversal/` |
    43â†’| 145 | Binary Tree Postorder Traversal | Easy | `1-999/145. Binary Tree Postorder Traversal/` |
    44â†’| 589 | N-ary Tree Preorder Traversal | Easy | `1-999/589. N-ary Tree Preorder Traversal/` |
    45â†’| 590 | N-ary Tree Postorder Traversal | Easy | `1-999/590. N-ary Tree Postorder Traversal/` |
    46â†’| 113 | Path Sum II | Medium | `1-999/113. Path Sum II/` |
    47â†’| 124 | Binary Tree Maximum Path Sum | Hard | `1-999/124. Binary Tree Maximum Path Sum/` |
    48â†’| 129 | Sum Root to Leaf Numbers | Medium | `1-999/129. Sum Root to Leaf Numbers/` |
    49â†’
    50â†’---
    51â†’
    52â†’## Graph Problems (BFS/DFS)
    53â†’
    54â†’| # | Problem | Difficulty | Type | Editorial Path |
    55â†’|---|---------|-----------|------|-----------------|
    56â†’| 133 | Clone Graph | Medium | DFS/BFS | `1-999/133. Clone Graph/` |
    57â†’| 200 | Number of Islands | Medium | DFS/BFS | `1-999/200. Number of Islands/` |
    58â†’| 207 | Course Schedule | Medium | Topological Sort | `1-999/207. Course Schedule/` |
    59â†’| 210 | Course Schedule II | Medium | Topological Sort | `1-999/210. Course Schedule II/` |
    60â†’| 261 | Graph Valid Tree | Medium | BFS/DFS (Premium) | `1-999/261. Graph Valid Tree/` |
    61â†’| 323 | Number of Connected Components | Medium | Union-Find/DFS (Premium) | `1-999/323. Number of Connected...` |
    62â†’| 785 | Is Graph Bipartite? | Medium | BFS/DFS | `1-999/785. Is Graph Bipartite/` |
    63â†’| 417 | Pacific Atlantic Water Flow | Medium | DFS | `1-999/417. Pacific Atlantic Water Flow/` |
    64â†’| 130 | Surrounded Regions | Medium | DFS/BFS | `1-999/130. Surrounded Regions/` |
    65â†’
    66â†’---
    67â†’
    68â†’## Island Problems (DFS/BFS)
    69â†’
    70â†’| # | Problem | Difficulty | Editorial Path |
    71â†’|---|---------|-----------|-----------------|
    72â†’| 200 | Number of Islands | Medium | `1-999/200. Number of Islands/` |
    73â†’| 305 | Number of Islands II | Hard (Premium) | `1-999/305. Number of Islands II/` |
    74â†’| 694 | Number of Distinct Islands | Medium (Premium) | `1-999/694. Number of Distinct Islands/` |
    75â†’| 695 | Max Area of Island | Medium | `1-999/695. Max Area of Island/` |
    76â†’| 827 | Making A Large Island | Hard | `1-999/827. Making A Large Island/` |
    77â†’| 1020 | Number of Enclaves | Medium | `1000-1999/1020. Number of Enclaves/` |
    78â†’| 1254 | Number of Closed Islands | Medium | `1000-1999/1254. Number of Closed Islands/` |
    79â†’
    80â†’---
    81â†’
    82â†’## How to Access the Editorial Code
    83â†’
    84â†’### Method 1: Browse the File System
    85â†’```bash
    86â†’cd leetcode-screenshotter/editorial_code/1-999
    87â†’ls "102. Binary Tree Level Order Traversal"
    88â†’# You'll see: python3-0.py, java-0.java, cpp-0.cpp, etc.
    89â†’```
    90â†’
    91â†’### Method 2: Search for Specific Problem
    92â†’```bash
    93â†’find . -type d -name "*Binary Tree Level Order*"
    94â†’find . -type f -name "*.py" -path "*102*"
    95â†’```
    96â†’
    97â†’### Method 3: Check Available Languages for a Problem
    98â†’Each problem folder contains solutions in different languages based on what LeetCode provided:
    99â†’- `python3-X.py` â†’ Python solutions
   100â†’- `java-X.java` â†’ Java solutions  
   101â†’- `cpp-X.cpp` â†’ C++ solutions
   102â†’- `javascript-X.js` â†’ JavaScript solutions
   103â†’- `typescript-X.ts` â†’ TypeScript solutions
   104â†’
   105â†’---
   106â†’
   107â†’## Key Learning Path
   108â†’
   109â†’### Phase 1: Basic Traversals (Start Here)
   110â†’1. **94 - Binary Tree Inorder Traversal** (DFS, Recursive)
   111â†’2. **144 - Binary Tree Preorder Traversal** (DFS, Recursive)
   112â†’3. **145 - Binary Tree Postorder Traversal** (DFS, Recursive)
   113â†’
   114â†’### Phase 2: Level Order (BFS)
   115â†’4. **102 - Binary Tree Level Order Traversal** (BFS with Queue)
   116â†’5. **103 - Binary Tree Zigzag Level Order** (BFS variant)
   117â†’6. **107 - Binary Tree Level Order II** (BFS variant)
   118â†’
   119â†’### Phase 3: Graph DFS
   120â†’7. **200 - Number of Islands** (Classic DFS on grid)
   121â†’8. **133 - Clone Graph** (DFS on graph)
   122â†’9. **130 - Surrounded Regions** (DFS on grid)
   123â†’
   124â†’### Phase 4: Graph BFS & Advanced
   125â†’10. **207 - Course Schedule** (Topological Sort with BFS)
   126â†’11. **210 - Course Schedule II** (Topological Sort with BFS)
   127â†’12. **785 - Is Graph Bipartite** (BFS/DFS on graph)
   128â†’
   129â†’### Phase 5: Advanced Island Problems
   130â†’13. **695 - Max Area of Island** (DFS variant)
   131â†’14. **827 - Making A Large Island** (DFS with merging)
   132â†’15. **417 - Pacific Atlantic Water Flow** (DFS reverse thinking)
   133â†’
   134â†’---
   135â†’
   136â†’## Where Problems Are Located
   137â†’
   138â†’```
   139â†’editorial_code/
   140â†’â”œâ”€â”€ 1-999/
   141â†’â”‚   â”œâ”€â”€ 094. Binary Tree Inorder Traversal/
   142â†’â”‚   â”œâ”€â”€ 102. Binary Tree Level Order Traversal/
   143â†’â”‚   â”œâ”€â”€ 103. Binary Tree Zigzag Level Order Traversal/
   144â†’â”‚   â”œâ”€â”€ 107. Binary Tree Level Order Traversal II/
   145â†’â”‚   â”œâ”€â”€ 113. Path Sum II/
   146â†’â”‚   â”œâ”€â”€ 124. Binary Tree Maximum Path Sum/
   147â†’â”‚   â”œâ”€â”€ 129. Sum Root to Leaf Numbers/
   148â†’â”‚   â”œâ”€â”€ 130. Surrounded Regions/
   149â†’â”‚   â”œâ”€â”€ 133. Clone Graph/
   150â†’â”‚   â”œâ”€â”€ 144. Binary Tree Preorder Traversal/
   151â†’â”‚   â”œâ”€â”€ 145. Binary Tree Postorder Traversal/
   152â†’â”‚   â”œâ”€â”€ 199. Binary Tree Right Side View/
   153â†’â”‚   â”œâ”€â”€ 200. Number of Islands/
   154â†’â”‚   â”œâ”€â”€ 207. Course Schedule/
   155â†’â”‚   â”œâ”€â”€ 210. Course Schedule II/
   156â†’â”‚   â”œâ”€â”€ 261. Graph Valid Tree/ (Premium)
   157â†’â”‚   â”œâ”€â”€ 305. Number of Islands II/ (Premium)
   158â†’â”‚   â”œâ”€â”€ 314. Binary Tree Vertical Order Traversal/ (Premium)
   159â†’â”‚   â”œâ”€â”€ 323. Number of Connected Components/ (Premium)
   160â†’â”‚   â”œâ”€â”€ 417. Pacific Atlantic Water Flow/
   161â†’â”‚   â”œâ”€â”€ 429. N-ary Tree Level Order Traversal/
   162â†’â”‚   â”œâ”€â”€ 513. Find Bottom Left Tree Value/
   163â†’â”‚   â”œâ”€â”€ 515. Find Largest Value in Each Tree Row/
   164â†’â”‚   â”œâ”€â”€ 589. N-ary Tree Preorder Traversal/
   165â†’â”‚   â”œâ”€â”€ 590. N-ary Tree Postorder Traversal/
   166â†’â”‚   â”œâ”€â”€ 637. Average of Levels in Binary Tree/
   167â†’â”‚   â”œâ”€â”€ 694. Number of Distinct Islands/ (Premium)
   168â†’â”‚   â”œâ”€â”€ 695. Max Area of Island/
   169â†’â”‚   â”œâ”€â”€ 785. Is Graph Bipartite/
   170â†’â”‚   â””â”€â”€ 827. Making A Large Island/
   171â†’â”‚
   172â†’â””â”€â”€ 1000-1999/
   173â†’    â”œâ”€â”€ 1020. Number of Enclaves/
   174â†’    â””â”€â”€ 1254. Number of Closed Islands/
   175â†’```
   176â†’
   177â†’---
   178â†’
   179â†’## How to View Editorial Explanations
   180â†’
   181â†’The editorial **text explanations with diagrams** are in:
   182â†’```
   183â†’leetcode-screenshotter/editorial-screenshots/
   184â†’```
   185â†’
   186â†’These contain the visual editorial explanations from LeetCode.
   187â†’
   188â†’The **code implementations** are in:
   189â†’```
   190â†’leetcode-screenshotter/editorial_code/
   191â†’```
   192â†’
   193â†’Example:
   194â†’- Read the explanation: `editorial-screenshots/1-999/102. Binary Tree Level Order Traversal.png`
   195â†’- Check the code: `editorial_code/1-999/102. Binary Tree Level Order Traversal/python3-0.py`
   196â†’
   197â†’---
   198â†’
   199â†’## Quick Access Commands
   200â†’
   201â†’Find all BFS-related problems:
   202â†’```bash
   203â†’grep -i "level.*order" /leetcode-screenshotter/data/problem_data.csv
   204â†’```
   205â†’
   206â†’Find all DFS/traversal problems:
   207â†’```bash
   208â†’grep -i "traversal" /leetcode-screenshotter/data/problem_data.csv
   209â†’```
   210â†’
   211â†’List all downloaded problems:
   212â†’```bash
   213â†’ls -la leetcode-screenshotter/editorial_code/1-999/ | wc -l
   214â†’```
   215â†’
   216â†’Find a specific problem's code:
   217â†’```bash
   218â†’find leetcode-screenshotter/editorial_code -type f -path "*102*" -name "*.py"
   219â†’```
   220â†’
   221â†’---
   222â†’
   223â†’## Notes
   224â†’
   225â†’- Some problems are **Premium** (marked in the table) - editorials may be incomplete
   226â†’- Not all problems have all language versions - check what's available in the folder
   227â†’- The CSV file (`data/problem_data.csv`) lists all problems with difficulty and acceptance rate
   228â†’- Download errors are logged in `editorial_code/download_error.csv`
   229â†’
   230â†’---
   231â†’
   232â†’## Next Steps
   233â†’
   234â†’1. Start with **Problem 94** - Binary Tree Inorder Traversal (simplest DFS)
   235â†’2. Read the editorial explanation screenshot
   236â†’3. Study the code solution(s) in your preferred language
   237â†’4. Try to implement it from memory
   238â†’5. Move to the next problem in the learning path
   239â†’
   240â†’Good luck with your DSA preparation!
   241â†’
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:15:51.482Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/graph/bfs_dfs.md`
```
     1â†’# Python
     2â†’
     3â†’```python
     4â†’from collections import deque
     5â†’class Solution:
     6â†’    def orangesRotting(self, grid: List[List[int]]) -> int:
     7â†’        queue = deque()
     8â†’
     9â†’        # Step 1). build the initial set of rotten oranges
    10â†’        fresh_oranges = 0
    11â†’        ROWS, COLS = len(grid), len(grid[0])
    12â†’        for r in range(ROWS):
    13â†’            for c in range(COLS):
    14â†’                if grid[r][c] == 2:
    15â†’                    queue.append((r, c))
    16â†’                elif grid[r][c] == 1:
    17â†’                    fresh_oranges += 1
    18â†’
    19â†’        # Mark the round / level, _i.e_ the ticker of timestamp
    20â†’        queue.append((-1, -1))
    21â†’
    22â†’        # Step 2). start the rotting process via BFS
    23â†’        minutes_elapsed = -1
    24â†’        directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]
    25â†’        while queue:
    26â†’            row, col = queue.popleft()
    27â†’            if row == -1:
    28â†’                # We finish one round of processing
    29â†’                minutes_elapsed += 1
    30â†’                if queue:  # to avoid the endless loop
    31â†’                    queue.append((-1, -1))
    32â†’            else:
    33â†’                # this is a rotten orange
    34â†’                # then it would contaminate its neighbors
    35â†’                for d in directions:
    36â†’                    neighbor_row, neighbor_col = row + d[0], col + d[1]
    37â†’                    if ROWS > neighbor_row >= 0 and COLS > neighbor_col >= 0:
    38â†’                        if grid[neighbor_row][neighbor_col] == 1:
    39â†’                            # this orange would be contaminated
    40â†’                            grid[neighbor_row][neighbor_col] = 2
    41â†’                            fresh_oranges -= 1
    42â†’                            # this orange would then contaminate other oranges
    43â†’                            queue.append((neighbor_row, neighbor_col))
    44â†’
    45â†’        # return elapsed minutes if no fresh orange left
    46â†’        return minutes_elapsed if fresh_oranges == 0 else -1
    47â†’    ```
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:15:55.181Z)**_

Let me also check the dijkstra_notes and other graph files to understand the style better.

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:15:56.264Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/graph/dijkstra_notes.md`
```
     1â†’# Dijkstra's Algorithm
     2â†’*Refer shortest_path_in_dag first*
     3â†’
     4â†’## The Core Insight
     5â†’
     6â†’**The problem with cyclic graphs:**
     7â†’Topological sort doesn't exist for graphs with cycles. A downstream node can connect back and potentially relax an edge that precedes it â€” so we can't precompute a safe processing order.
     8â†’
     9â†’**Dijkstra's greedy solution:**
    10â†’Always process the unprocessed node with the smallest known distance. This node's distance is guaranteed to be optimal.
    11â†’
    12â†’---
    13â†’
    14â†’## Proof of Correctness
    15â†’
    16â†’**Setup:** Some nodes are processed. Node X has the smallest `dist[X]` among unprocessed nodes.
    17â†’
    18â†’**Claim:** No future relaxation can improve `dist[X]`.
    19â†’
    20â†’**Why:**
    21â†’```
    22â†’    [PROCESSED]              [UNPROCESSED]
    23â†’    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    24â†’    â”‚  S â†’ ... â†’  â”‚ â”€â”€â”€â”€â”€â”€â”€â–º   X (dist=5)  â† smallest
    25â†’    â”‚             â”‚ â”€â”€â”€â”€â”€â”€â”€â–º   Y (dist=8)  
    26â†’    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    27â†’```
    28â†’
    29â†’Any alternative path to X must exit the processed set through some unprocessed node Y first.
    30â†’
    31â†’- `dist[Y] â‰¥ dist[X]` (since X has minimum)
    32â†’- Cost from Y to X â‰¥ 0 (non-negative edges)
    33â†’- Total alternative: `dist[Y] + (Yâ†’X) â‰¥ dist[X] + 0 â‰¥ dist[X]`
    34â†’
    35â†’**Critical requirement:** Non-negative edge weights. With negative edges, a "farther" node could provide a shortcut.
    36â†’
    37â†’---
    38â†’
    39â†’## Why Negative Edges Break Dijkstra
    40â†’
    41â†’```
    42â†’A ---(1)---> B
    43â†’A ---(2)---> C ---(-5)---> B
    44â†’```
    45â†’
    46â†’Greedy processes B first with dist=1. But actual shortest path is Aâ†’Câ†’B = 2 + (-5) = -3.
    47â†’
    48â†’Once B is "finalized," Dijkstra never revisits it.
    49â†’
    50â†’**Solution for negative edges:** Use Bellman-Ford (O(VÃ—E)).
    51â†’
    52â†’---
    53â†’
    54â†’## Complexity
    55â†’
    56â†’| Operation | Time |
    57â†’|-----------|------|
    58â†’| Each node popped once | O(V) |
    59â†’| Each edge relaxed once | O(E) |
    60â†’| Heap operations | O(log V) each |
    61â†’| **Total** | **O((V + E) log V)** |
    62â†’
    63â†’---
    64â†’
    65â†’## Algorithm Steps
    66â†’
    67â†’1. Initialize `dist[source] = 0`, all others `âˆ`
    68â†’2. Push `(0, source)` to min-heap
    69â†’3. While heap not empty:
    70â†’   - Pop node with smallest distance
    71â†’   - Skip if already processed (stale entry)
    72â†’   - Mark as processed
    73â†’   - Relax all neighbors, push improvements to heap
    74â†’4. Return distances
    75â†’
    76â†’---
    77â†’
    78â†’## Template Code
    79â†’
    80â†’```python
    81â†’import heapq
    82â†’
    83â†’def dijkstra(n, adj, source=0):
    84â†’    distances = [float('inf')] * n
    85â†’    processed = set()
    86â†’    heap = [(0, source)]  # (distance, node)
    87â†’    
    88â†’    while heap:
    89â†’        dist, node = heapq.heappop(heap)
    90â†’        
    91â†’        if node in processed:
    92â†’            continue  # skip stale entries
    93â†’        
    94â†’        distances[node] = dist
    95â†’        processed.add(node)
    96â†’        
    97â†’        for neighbor, weight in adj[node]:
    98â†’            if neighbor not in processed:
    99â†’                heapq.heappush(heap, (dist + weight, neighbor))
   100â†’    
   101â†’    return distances
   102â†’```
   103â†’
   104â†’**Python heapq essentials:**
   105â†’- `heapq.heappush(heap, item)` â€” add item
   106â†’- `heapq.heappop(heap)` â€” remove and return smallest
   107â†’- Push tuples `(priority, data)` â€” sorts by first element
   108â†’- No decrease-key â€” just push duplicates and skip stale entries
   109â†’
   110â†’---
   111â†’
   112â†’## Edge Cases
   113â†’
   114â†’| Case | Handling |
   115â†’|------|----------|
   116â†’| Unreachable nodes | Stay `âˆ`, convert to `-1` if needed |
   117â†’| Self-loops | Handled naturally (won't improve distance) |
   118â†’| Parallel edges | All get relaxed, best one wins |
   119â†’| Source not node 0 | Just change the source parameter |
   120â†’| Already at destination | Returns immediately with dist=0 |
   121â†’
   122â†’---
   123â†’
   124â†’## Comparison: Dijkstra vs DAG Shortest Path
   125â†’
   126â†’| Aspect | DAG (Topo Sort) | Dijkstra |
   127â†’|--------|-----------------|----------|
   128â†’| Graph type | DAG only | Any (non-negative weights) |
   129â†’| Time | O(V + E) | O((V + E) log V) |
   130â†’| Processing order | Topological | Greedy (min distance) |
   131â†’| Data structure | Stack | Min-heap |
   132â†’| Negative edges | Works fine | Breaks correctness |
   133â†’
   134â†’**When to use which:**
   135â†’- DAG â†’ use topo sort (faster)
   136â†’- Cycles + non-negative weights â†’ Dijkstra
   137â†’- Negative weights â†’ Bellman-Ford
   138â†’
   139â†’---
   140â†’
   141â†’## Interview Patterns
   142â†’
   143â†’**Keywords that signal Dijkstra:**
   144â†’- "Shortest path" + weighted graph
   145â†’- "Minimum cost/time to reach"
   146â†’- "Network delay time"
   147â†’- "Cheapest flights within K stops" (modified)
   148â†’
   149â†’**Key phrase to mention:**
   150â†’> "Since we have non-negative weights, I'll use Dijkstra's algorithm. The greedy choice is safe â€” when we pop a node from the min-heap, its distance is already optimal because any alternative path through a farther node can only add non-negative cost."
   151â†’
   152â†’---
   153â†’
   154â†’## Common Variations
   155â†’
   156â†’1. **Shortest path to specific target:** Stop early when target is popped
   157â†’2. **Track the actual path:** Store `parent[]` array during relaxation
   158â†’3. **K shortest paths:** Keep counter of times each node is popped
   159â†’4. **Grid-based:** Neighbors are 4 or 8 adjacent cells
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:15:56.936Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/sliding_window/sliding_window_master.md`
```
     1â†’Get subarray with sum = 5 ; max sum ; min sum ; => with fixed length
     2â†’array is continous sub part
     3â†’
     4â†’Identification: repeated calculation over an inner loop, question is generally on **contiguous** part | could be fixed or variable length. 
     5â†’
     6â†’Type2# => variable length subarray
     7â†’
     8â†’
     9â†’#1 : maximum sub-array of size k
    10â†’
    11â†’
    12â†’
    13â†’Template: 
    14â†’```python
    15â†’class Solution:
    16â†’    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:
    17â†’        from collections import defaultdict
    18â†’        counter = defaultdict(lambda:0)
    19â†’        i,j = 0,0
    20â†’        answer = []
    21â†’
    22â†’        def get_xth_smallest_zero(counter:dict,x:int)->int:
    23â†’            keys = counter.keys()
    24â†’            keys = sorted(keys)
    25â†’            current_position = 0
    26â†’            for key in keys:
    27â†’                if current_position + counter[key] >= x:
    28â†’                    return key
    29â†’                
    30â†’                current_position+=counter[key]
    31â†’
    32â†’            return 0
    33â†’
    34â†’
    35â†’        while j<len(nums):
    36â†’
    37â†’            # initial state: we have consumed till i till j-1, yet to consume j
    38â†’
    39â†’
    40â†’            # consume j to window
    41â†’            if nums[j]<0:
    42â†’                counter[nums[j]]+=1
    43â†’
    44â†’            if j-i+1<k:
    45â†’                j+=1
    46â†’                continue
    47â†’
    48â†’            # fully filled window - ready to be consumed
    49â†’            answer.append(get_xth_smallest_zero(counter,x)) # optimization
    50â†’            
    51â†’            if nums[i] < 0:
    52â†’                counter[nums[i]]-=1 # remove i
    53â†’
    54â†’            i+=1;j+=1
    55â†’        return answer
    56â†’```
    57â†’
    58â†’
    59â†’Question patterns:
    60â†’
    61â†’Fixed size
    62â†’    1. maximum sum subarray with size k
    63â†’    2. first negative number in every window k
    64â†’    3. count of occurances of anagram in a window k
    65â†’    4. **Nice** Maximum of all elements in a given subarray k
    66â†’
    67â†’Variable size:
    68â†’    1. Largest subarray of size k
    69â†’    2. longest substring with K unique characters
    70â†’    3. longest substring without repeating characters
    71â†’    4. Pick toys
    72â†’    5. minimum window substring
    73â†’
    74â†’
    75â†’
    76â†’
    77â†’# pattern for variable window 
    78â†’```python
    79â†’class Solution:
    80â†’    def minWindow(self, s: str, t: str) -> str:
    81â†’        from collections import defaultdict
    82â†’        s_dict, t_dict = defaultdict(int), defaultdict(int)
    83â†’
    84â†’        for char in t:
    85â†’            t_dict[char]+=1
    86â†’
    87â†’
    88â†’
    89â†’        def satisfies(parent_dict:dict, child_dict: dict)->bool:
    90â†’            for child_key in child_dict:
    91â†’                if child_key not in parent_dict:
    92â†’                    return False
    93â†’                if parent_dict[child_key] < child_dict[child_key]:
    94â†’                    return False
    95â†’            return True
    96â†’
    97â†’        
    98â†’        i = j = 0
    99â†’        best_length = 10**10
   100â†’        answer = ""
   101â†’
   102â†’        for j in range(len(s)):
   103â†’            
   104â†’            s_dict[s[j]]+=1
   105â†’
   106â†’            while satisfies(s_dict, t_dict):
   107â†’                if best_length > j-i+1:
   108â†’                    answer = s[i:j+1]
   109â†’                    best_length = j-i+1
   110â†’
   111â†’                s_dict[s[i]]-=1
   112â†’                i+=1
   113â†’
   114â†’        return answer
   115â†’
   116â†’```Ëœ
   117â†’
   118â†’
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:16:00.305Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/trees/master.md`
```
     1â†’# Trees
     2â†’- basically tree definitions, balanced tree, complete tree and yadayadayadayada
     3â†’- number of nodes in the tree = n, height would log2n best case
     4â†’- if you have the height as d, you'd have 2^d - 1 elements. Basically sum of gp like 1+2+4+....
     5â†’
     6â†’- array representation of tree => refer tree builder
     7â†’
     8â†’
     9â†’# SPACE 
    10â†’-  for complete tree - dfs is much better because the space os O(Height)
    11â†’- for skewed tree - bfs is better since space is O(width) : width = N/2 for complete trees
    12â†’- time is O(N) for both
    13â†’
    14â†’# there is a funda when the width of the tree could be defined as its position with with respect to the row and column but in this representation there is a lot of overlap between nodes so if you find the width by using +1 -1 when going right or right it will cause overlaps but if you want to calculate it using the actual null values that would have been there had this been a complete tree then things change 
    15â†’
    16â†’
    17â†’## tree indexing
    18â†’
    19â†’Here are your notes, cleaned up:
    20â†’
    21â†’---
    22â†’
    23â†’# Binary Tree Indexing: Why Children are at 2i+1 and 2i+2
    24â†’
    25â†’## Tree Structure (0-indexed)
    26â†’
    27â†’```
    28â†’Level 0:                    0                        Level k: [2^k - 1  â†’  2^(k+1) - 1)
    29â†’                          /   \
    30â†’Level 1:                1       2
    31â†’                       / \     / \
    32â†’Level 2:              3   4   5   6
    33â†’                     /\ /\ /\ /\
    34â†’Level 3:            7 8 9 10 11 12 13 14
    35â†’```
    36â†’
    37â†’## Proof
    38â†’
    39â†’**Level k** contains indices from `2^k - 1` to `2^(k+1) - 2` (i.e., `2^k` nodes total).
    40â†’
    41â†’**Parent at index `i`, located in level `k`.**
    42â†’
    43â†’**Nodes before `i` in the same level:**
    44â†’```
    45â†’(2^k - 1) â†’ i  =  i - (2^k - 1)
    46â†’```
    47â†’
    48â†’*Example: i = 5, k = 2 â†’ 5 - 3 = 2 â†’ 2 elements before (nodes 3 and 4)*
    49â†’image.png
    50â†’**Children that will be present before my children (in level k+1):**
    51â†’```
    52â†’= 2 Ã— (i - (2^k - 1))
    53â†’= 2i - 2^(k+1) + 2
    54â†’= n
    55â†’```
    56â†’
    57â†’**First index in level k+1:**
    58â†’```
    59â†’= 2^(k+1) - 1
    60â†’```
    61â†’
    62â†’**My left child (n-th index in level k+1):**
    63â†’```
    64â†’= 2^(k+1) - 1 + n
    65â†’= 2^(k+1) - 1 + 2i - 2^(k+1) + 2
    66â†’= 2i + 1          â† left child
    67â†’```
    68â†’
    69â†’**Right child:**
    70â†’```
    71â†’= 2i + 2          â† right child
    72â†’```
    73â†’
    74â†’---
    75â†’
    76â†’## Summary
    77â†’
    78â†’| Indexing | Left Child | Right Child | Parent |
    79â†’|----------|------------|-------------|--------|
    80â†’| 0-based (root = 0) | `2i + 1` | `2i + 2` | `(i - 1) // 2` |
    81â†’| 1-based (root = 1) | `2i` | `2i + 1` | `i // 2` |
    82â†’
    83â†’---
    84â†’
    85â†’## Notes / Doubts I Had
    86â†’
    87â†’1. **Initial mistake:** I thought nodes before me in my level = `i - 1`. That's wrong â€” it's `i - (first index of my level)`.
    88â†’
    89â†’2. **The key insight:** Each level starts at a specific index (`2^k - 1` for 0-indexed), and I need to count my position *relative to that start*, not relative to 0.
    90â†’
    91â†’3. **Why the 2Ã— multiplier:** Every node before me contributes exactly 2 children to the next level before my children appear.
    92â†’
    93â†’---
    94â†’
    95â†’
    96â†’## Get the depth
    97â†’:=> floor(log2(i+1)) gives you the depth in the 0 based indexing
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:16:04.603Z)**_

Now I have a good understanding of the style. Let me create a comprehensive, question-wise path that integrates the 30-day worksheet with the TheEssay style (focused, practical, with templates and key insights).

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:17:50.466Z)**_

<tool-use data-tool-type="write" data-tool-name="Write"><details>
<summary>Tool use: **Write**</summary>

```md
# Graph Mastery: Question-Wise Path

## Legend
| Symbol | Meaning |
|--------|---------|
| â­ | Must-do (interview essential) |
| ğŸ”‘ | Key insight problem |
| ğŸ“ | Pattern introduction |
| â†’ | Leads to / progression |

---

# Phase 1: Foundations (Days 1-7)

## Module 1.1: Graph Representation
**Goal:** Build any graph from scratch

### Q1: LC 1971 - Find if Path Exists in Graph ğŸ“
**Pattern:** Graph construction + basic traversal
**Before solving:**
- Can you build adjacency list from edge list?
- What's the difference between directed vs undirected representation?

\```python
# Template: Build adjacency list
def build_graph(n, edges, directed=False):
    adj = [[] for _ in range(n)]
    for u, v in edges:
        adj[u].append(v)
        if not directed:
            adj[v].append(u)
    return adj
\```

**Checkpoint:** Solve this in <5 mins including graph construction.

---

## Module 1.2: DFS Mastery
**Goal:** Write DFS in sleep, understand stack behavior

### Q2: LC 797 - All Paths From Source to Target â­ğŸ“
**Pattern:** DFS path enumeration
**Key insight:** When do you need to backtrack vs when visited stays marked?
- Here: **Backtrack** (same node can appear in different paths)
- Connected components: **Stay marked** (just counting)

\```python
# Template: DFS with path tracking (backtracking)
def dfs_paths(node, target, adj, path, result):
    if node == target:
        result.append(path[:])
        return
    for neighbor in adj[node]:
        path.append(neighbor)
        dfs_paths(neighbor, target, adj, path, result)
        path.pop()  # backtrack
\```

### Q3: LC 547 - Number of Provinces â­ğŸ”‘
**Pattern:** Connected components via DFS
**Key insight:** Each DFS call "floods" one component. Count the floods.

\```python
# Template: Count connected components
def count_components(n, adj):
    visited = set()
    count = 0
    for node in range(n):
        if node not in visited:
            dfs(node, adj, visited)
            count += 1
    return count
\```

**Warning:** This problem gives adjacency MATRIX, not list. Convert or adapt.

### Q4: LC 695 - Max Area of Island â­
**Pattern:** DFS on grid returning value
**Key insight:** DFS returns area count, sum up 1 + recursive calls.

\```python
# Template: DFS on grid with return value
def dfs_grid(grid, r, c, visited):
    if r < 0 or r >= len(grid) or c < 0 or c >= len(grid[0]):
        return 0
    if (r, c) in visited or grid[r][c] == 0:
        return 0
    visited.add((r, c))
    return 1 + sum(dfs_grid(grid, r+dr, c+dc, visited)
                   for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)])
\```

---

## Module 1.3: BFS Mastery
**Goal:** Understand why BFS gives shortest path in unweighted graphs

### Q5: LC 1091 - Shortest Path in Binary Matrix â­â­ğŸ“
**Pattern:** BFS shortest path in grid
**Key insight:** First time BFS reaches a cell = shortest distance (unweighted).

\```python
# Template: BFS shortest path
from collections import deque

def bfs_shortest(grid, start, end):
    if grid[start[0]][start[1]] == 1:
        return -1

    queue = deque([(start[0], start[1], 1)])  # (r, c, distance)
    visited = {start}
    directions = [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]

    while queue:
        r, c, dist = queue.popleft()
        if (r, c) == end:
            return dist
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]):
                if (nr, nc) not in visited and grid[nr][nc] == 0:
                    visited.add((nr, nc))
                    queue.append((nr, nc, dist + 1))
    return -1
\```

### Q6: LC 542 - 01 Matrix â­â­
**Pattern:** Multi-source BFS
**Key insight:** Start BFS from ALL zeros simultaneously. Distance propagates outward.

### Q7: LC 994 - Rotting Oranges â­â­â­ğŸ”‘
**Pattern:** Multi-source BFS + level tracking
**Core technique:**
1. Add ALL rotten oranges to queue initially
2. Process level by level
3. Track time = number of levels

\```python
# Template: Multi-source BFS with level tracking
def multi_source_bfs(grid, sources):
    queue = deque(sources)  # all sources added initially
    time = 0

    while queue:
        for _ in range(len(queue)):  # process current level
            r, c = queue.popleft()
            for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)]:
                nr, nc = r + dr, c + dc
                if valid(nr, nc) and should_process(grid[nr][nc]):
                    grid[nr][nc] = mark_processed
                    queue.append((nr, nc))
        if queue:  # more levels to process
            time += 1
    return time
\```

---

## Module 1.4: Grid as Graph
**Goal:** Navigate any grid problem with confidence

### Q8: LC 200 - Number of Islands â­â­â­â­â­ğŸ“
**Pattern:** Connected components on grid
**This is THE grid-graph problem.** Master this, everything else is variation.

\```python
# Core technique: "Sink" the island as you visit
def numIslands(grid):
    count = 0
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            if grid[r][c] == '1':
                sink_island(grid, r, c)  # DFS that marks visited by changing to '0'
                count += 1
    return count
\```

### Q9: LC 463 - Island Perimeter
**Pattern:** Grid counting (different from traversal)
**Insight:** Each land cell contributes 4 - (number of land neighbors).

### Q10: LC 1254 - Number of Closed Islands
**Pattern:** "Touched boundary" detection
**Key insight:** Island is NOT closed if any DFS reaches boundary.

---

## Module 1.5: Clone Problems
**Goal:** Handle node references correctly

### Q11: LC 133 - Clone Graph â­â­â­â­â­ğŸ”‘
**Pattern:** HashMap oldâ†’new mapping
**Key insight:** Build clone as you traverse, lookup prevents infinite loops.

\```python
# Template: Graph cloning
def cloneGraph(node):
    if not node:
        return None

    old_to_new = {}

    def dfs(node):
        if node in old_to_new:
            return old_to_new[node]

        copy = Node(node.val)
        old_to_new[node] = copy  # map BEFORE recursing

        for neighbor in node.neighbors:
            copy.neighbors.append(dfs(neighbor))

        return copy

    return dfs(node)
\```

---

# Phase 2: Cycles & Ordering (Days 8-14)

## Module 2.1: Cycle Detection - Undirected
**Goal:** Detect cycles using parent tracking

### Q12: LC 684 - Redundant Connection â­â­â­â­ğŸ“
**Pattern:** Find the edge that creates a cycle
**Two approaches:**
1. DFS with parent tracking
2. Union-Find (better for this problem)

\```python
# Template: Cycle detection in undirected (DFS)
def has_cycle_undirected(node, parent, adj, visited):
    visited.add(node)
    for neighbor in adj[node]:
        if neighbor == parent:
            continue  # don't go back to parent
        if neighbor in visited:
            return True  # cycle found!
        if has_cycle_undirected(neighbor, node, adj, visited):
            return True
    return False
\```

### Q13: LC 261 - Graph Valid Tree â­â­â­â­
**Pattern:** Tree = connected + no cycle
**Checks:**
1. n-1 edges (necessary but not sufficient)
2. All nodes reachable from node 0
3. No cycle

---

## Module 2.2: Cycle Detection - Directed
**Goal:** Master three-color algorithm

### Q14: LC 207 - Course Schedule â­â­â­â­â­ğŸ“ğŸ”‘
**Pattern:** Detect cycle in directed graph
**THE core problem for topological sort/cycle detection.**

\```python
# Template: Three-color cycle detection
# WHITE=0 (unvisited), GRAY=1 (in current path), BLACK=2 (done)
def has_cycle_directed(node, adj, color):
    color[node] = 1  # GRAY - currently exploring

    for neighbor in adj[node]:
        if color[neighbor] == 1:  # back edge to node in current path
            return True
        if color[neighbor] == 0:  # unvisited
            if has_cycle_directed(neighbor, adj, color):
                return True

    color[node] = 2  # BLACK - done exploring
    return False
\```

**Interview phrase:** "I'm using the three-color algorithm. Gray nodes are in the current DFS path. If we reach a gray node, we've found a back edge, which means a cycle."

### Q15: LC 802 - Find Eventual Safe States
**Pattern:** Reverse cycle detection
**Insight:** Safe = not part of any cycle. Find all nodes that are BLACK after DFS.

---

## Module 2.3: Topological Sort
**Goal:** Know both approaches cold

### Q16: LC 210 - Course Schedule II â­â­â­â­â­ğŸ“
**Pattern:** Topological ordering

**Approach 1: DFS Post-order (reverse)**
\```python
def topo_dfs(n, adj):
    color = [0] * n
    order = []

    def dfs(node):
        color[node] = 1
        for neighbor in adj[node]:
            if color[neighbor] == 1:
                return False  # cycle
            if color[neighbor] == 0:
                if not dfs(neighbor):
                    return False
        color[node] = 2
        order.append(node)  # post-order
        return True

    for i in range(n):
        if color[i] == 0:
            if not dfs(i):
                return []  # cycle exists

    return order[::-1]  # reverse post-order
\```

### Q17: LC 210 (Kahn's) â­â­â­â­â­
**Approach 2: BFS with in-degree**
\```python
def topo_kahn(n, adj):
    in_degree = [0] * n
    for u in range(n):
        for v in adj[u]:
            in_degree[v] += 1

    queue = deque([i for i in range(n) if in_degree[i] == 0])
    order = []

    while queue:
        node = queue.popleft()
        order.append(node)
        for neighbor in adj[node]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)

    return order if len(order) == n else []  # cycle if not all processed
\```

**When to use which:**
- DFS: When you need to detect cycle + order together
- Kahn's: When you need level-by-level processing (parallel courses)

### Q18: LC 310 - Minimum Height Trees ğŸ”‘
**Pattern:** Kahn's from leaves inward
**Insight:** Keep removing leaves until 1-2 nodes remain. Those are the centers.

### Q19: LC 2050 - Parallel Courses III
**Pattern:** Kahn's + track longest path to each node

---

## Module 2.4: Build Graph from Constraints

### Q20: LC 269 - Alien Dictionary â­â­â­â­ğŸ”‘
**Pattern:** Extract edges from ordering, then topo sort
**Key insight:** Compare adjacent words to find ONE edge per pair.

\```python
# Extract edges from word ordering
def extract_edges(words):
    edges = []
    for i in range(len(words) - 1):
        w1, w2 = words[i], words[i+1]
        for c1, c2 in zip(w1, w2):
            if c1 != c2:
                edges.append((c1, c2))  # c1 comes before c2
                break
        else:
            if len(w1) > len(w2):  # "abc" before "ab" is invalid
                return None
    return edges
\```

---

## Module 2.5: Bipartite Graphs

### Q21: LC 785 - Is Graph Bipartite? â­â­â­ğŸ“
**Pattern:** Two-coloring
**Insight:** Bipartite âŸº no odd-length cycles âŸº 2-colorable

\```python
# Template: Bipartite check
def is_bipartite(adj, n):
    color = [-1] * n

    for start in range(n):
        if color[start] != -1:
            continue
        queue = deque([start])
        color[start] = 0

        while queue:
            node = queue.popleft()
            for neighbor in adj[node]:
                if color[neighbor] == color[node]:
                    return False  # same color = not bipartite
                if color[neighbor] == -1:
                    color[neighbor] = 1 - color[node]
                    queue.append(neighbor)
    return True
\```

### Q22: LC 886 - Possible Bipartition
**Pattern:** Bipartite on implicit graph
**Build graph:** If A dislikes B, they must be in different groups.

---

# Phase 3: Union-Find & Shortest Paths (Days 15-21)

## Module 3.1: Union-Find

### Template: Union-Find with Path Compression
\```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
        self.components = n

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # path compression
        return self.parent[x]

    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px == py:
            return False  # already connected

        # union by rank
        if self.rank[px] < self.rank[py]:
            px, py = py, px
        self.parent[py] = px
        if self.rank[px] == self.rank[py]:
            self.rank[px] += 1

        self.components -= 1
        return True
\```

### Q23: LC 323 - Number of Connected Components â­â­â­â­ğŸ“
**Pattern:** Basic Union-Find application
**Compare:** DFS also works. UF is better for dynamic connectivity.

### Q24: LC 684 - Redundant Connection (revisit) â­â­â­â­
**Pattern:** First edge that connects already-connected nodes
**With UF:** Process edges in order. First `union()` that returns False = answer.

### Q25: LC 721 - Accounts Merge â­â­â­ğŸ”‘
**Pattern:** Union-Find with string mapping
**Key:** Map each email to an index, union emails within same account.

### Q26: LC 990 - Satisfiability of Equality Equations
**Pattern:** Process == first (union), then check != (should not be same root)

---

## Module 3.2: Dijkstra's Algorithm

### Core Understanding
**When to use:** Weighted graph + non-negative weights + single-source shortest path

**Why it works:** When we pop a node from min-heap, its distance is final. Any alternative path through a farther node can only add non-negative cost.

**Why negative edges break it:** A "farther" node could provide a shortcut via negative edge.

### Template: Dijkstra
\```python
import heapq

def dijkstra(n, adj, source):
    dist = [float('inf')] * n
    dist[source] = 0
    heap = [(0, source)]

    while heap:
        d, node = heapq.heappop(heap)

        if d > dist[node]:  # stale entry
            continue

        for neighbor, weight in adj[node]:
            new_dist = d + weight
            if new_dist < dist[neighbor]:
                dist[neighbor] = new_dist
                heapq.heappush(heap, (new_dist, neighbor))

    return dist
\```

### Q27: LC 743 - Network Delay Time â­â­â­â­ğŸ“
**Pattern:** Basic Dijkstra
**Answer:** Max of all distances (time for signal to reach farthest node)

### Q28: LC 787 - Cheapest Flights Within K Stops â­â­â­ğŸ”‘
**Pattern:** Modified Dijkstra with state = (cost, node, stops)
**Key:** Can't just skip stale entries. Node might be reached with fewer stops later.

\```python
# Modified state: (cost, node, stops_remaining)
def cheapest_k_stops(n, flights, src, dst, k):
    adj = defaultdict(list)
    for u, v, w in flights:
        adj[u].append((v, w))

    heap = [(0, src, k + 1)]  # (cost, node, stops_remaining)

    while heap:
        cost, node, stops = heapq.heappop(heap)

        if node == dst:
            return cost

        if stops > 0:
            for neighbor, price in adj[node]:
                heapq.heappush(heap, (cost + price, neighbor, stops - 1))

    return -1
\```

### Q29: LC 1631 - Path With Minimum Effort â­â­â­
**Pattern:** Dijkstra on grid with custom weight
**Weight:** max absolute difference along path (not sum)

---

## Module 3.3: Bellman-Ford & Floyd-Warshall

### When to use
| Algorithm | Use case | Complexity |
|-----------|----------|------------|
| Dijkstra | Single-source, non-negative weights | O((V+E) log V) |
| Bellman-Ford | Single-source, handles negative weights | O(V Ã— E) |
| Floyd-Warshall | All-pairs shortest path | O(VÂ³) |

### Q30: LC 787 (Bellman-Ford approach)
**Why it works here:** K stops = K+1 edges = K+1 relaxation rounds

### Q31: LC 1334 - Find City With Smallest Number of Neighbors
**Pattern:** Floyd-Warshall to get all-pairs, then filter by threshold

---

# Phase 4: Advanced Patterns (Days 22-27)

## Module 4.1: Backtracking on Graphs

### Q32: LC 79 - Word Search â­â­â­â­ğŸ“
**Pattern:** DFS with backtracking
**Key difference from regular DFS:** Unmark visited after exploring (same cell can be in different paths)

\```python
def exist(board, word):
    def dfs(r, c, idx):
        if idx == len(word):
            return True
        if r < 0 or r >= len(board) or c < 0 or c >= len(board[0]):
            return False
        if board[r][c] != word[idx]:
            return False

        temp = board[r][c]
        board[r][c] = '#'  # mark visited

        found = any(dfs(r+dr, c+dc, idx+1)
                   for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)])

        board[r][c] = temp  # backtrack
        return found

    for r in range(len(board)):
        for c in range(len(board[0])):
            if dfs(r, c, 0):
                return True
    return False
\```

### Q33: LC 980 - Unique Paths III â­â­â­
**Pattern:** Backtracking + count all valid paths
**Must visit:** All empty cells exactly once

---

## Module 4.2: Trie + Graph

### Q34: LC 212 - Word Search II â­â­â­â­ğŸ”‘
**Pattern:** Trie optimization for multiple word search
**Key insight:** Build Trie of words, DFS on grid while traversing Trie simultaneously

---

## Module 4.3: Advanced Grid Problems

### Q35: LC 130 - Surrounded Regions â­â­â­â­ğŸ“
**Pattern:** Boundary-connected DFS
**Insight:** Mark 'O's connected to boundary. Everything else gets captured.

### Q36: LC 417 - Pacific Atlantic Water Flow â­â­â­â­ğŸ”‘
**Pattern:** Reverse DFS from oceans
**Key insight:** Instead of "can water flow to ocean?", ask "where can ocean reach?"
Start DFS from all ocean borders, find intersection.

### Q37: LC 1559 - Detect Cycles in 2D Grid
**Pattern:** Cycle detection on grid (4-directional)

---

## Module 4.4: Transformation Graphs

### Q38: LC 127 - Word Ladder â­â­â­â­ğŸ“
**Pattern:** BFS on implicit graph (words are nodes)
**Key insight:** Graph isn't given. Each word connects to words differing by 1 char.

\```python
def ladderLength(beginWord, endWord, wordList):
    wordSet = set(wordList)
    if endWord not in wordSet:
        return 0

    queue = deque([(beginWord, 1)])
    visited = {beginWord}

    while queue:
        word, length = queue.popleft()

        if word == endWord:
            return length

        for i in range(len(word)):
            for c in 'abcdefghijklmnopqrstuvwxyz':
                next_word = word[:i] + c + word[i+1:]
                if next_word in wordSet and next_word not in visited:
                    visited.add(next_word)
                    queue.append((next_word, length + 1))

    return 0
\```

### Q39: LC 752 - Open the Lock
**Pattern:** BFS on state space (4-digit lock combinations)

---

## Module 4.5: Minimum Spanning Tree

### Q40: LC 1584 - Min Cost to Connect All Points â­â­â­ğŸ“
**Pattern:** Kruskal's with Union-Find

\```python
def minCostConnectPoints(points):
    n = len(points)
    edges = []

    for i in range(n):
        for j in range(i+1, n):
            dist = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])
            edges.append((dist, i, j))

    edges.sort()
    uf = UnionFind(n)
    cost = 0

    for d, u, v in edges:
        if uf.union(u, v):
            cost += d
            if uf.components == 1:
                break

    return cost
\```

---

# Quick Reference: Pattern Recognition

| Keywords | Pattern | First Problem to Try |
|----------|---------|---------------------|
| "shortest path" + unweighted | BFS | LC 1091 |
| "shortest path" + weighted | Dijkstra | LC 743 |
| "all paths" | DFS backtracking | LC 797 |
| "number of islands/components" | DFS flood fill | LC 200 |
| "rotting/spreading" | Multi-source BFS | LC 994 |
| "course schedule" / "prerequisites" | Topological sort | LC 207 |
| "valid tree" | n-1 edges + connected + no cycle | LC 261 |
| "bipartite" / "two groups" | 2-coloring BFS/DFS | LC 785 |
| "redundant edge" | Union-Find | LC 684 |
| "minimum cost to connect" | MST (Kruskal/Prim) | LC 1584 |
| "word ladder" / "transformation" | BFS on implicit graph | LC 127 |
| "surrounded" / "boundary" | DFS from boundary | LC 130 |

---

# Daily Drill Order

## Week 1: Foundations
| Day | Focus | Must-Do Problems |
|-----|-------|-----------------|
| 1 | Graph construction | 1971 |
| 2 | DFS | 797, 547, 695 |
| 3 | BFS | 1091, 542, 1162 |
| 4 | Grid DFS | 200, 463, 1254 |
| 5 | Multi-source BFS | 994, 286 |
| 6 | Clone problems | 133, 138 |
| 7 | Review | Redo hardest from each day |

## Week 2: Cycles & Ordering
| Day | Focus | Must-Do Problems |
|-----|-------|-----------------|
| 8 | Undirected cycle | 684, 261 |
| 9 | Directed cycle | 207, 802 |
| 10 | Topo sort (DFS) | 210, 1462 |
| 11 | Topo sort (Kahn's) | 210, 310 |
| 12 | Constraint graphs | 269 |
| 13 | Bipartite | 785, 886 |
| 14 | Review | Mixed practice |

## Week 3: Union-Find & Shortest Paths
| Day | Focus | Must-Do Problems |
|-----|-------|-----------------|
| 15 | Union-Find basics | Template implementation |
| 16 | UF applications | 323, 684, 547 |
| 17 | Advanced UF | 721, 990 |
| 18 | Dijkstra theory | Template implementation |
| 19 | Dijkstra applications | 743, 787, 1631 |
| 20 | Bellman-Ford | 787 (redo), 1334 |
| 21 | Speed practice | Timed problems |

## Week 4: Advanced & Mock
| Day | Focus | Must-Do Problems |
|-----|-------|-----------------|
| 22 | Backtracking | 79, 980 |
| 23 | Trie + Graph | 212 |
| 24 | Complex grids | 130, 417 |
| 25 | Transformation graphs | 127, 752 |
| 26 | MST | 1584 |
| 27 | Advanced patterns | 332 |
| 28-30 | Mock interviews | Random selection |

---

# Success Metrics Checklist

- [ ] Can recognize pattern in <30 seconds
- [ ] Can code DFS template without reference
- [ ] Can code BFS template without reference
- [ ] Can code Union-Find without reference
- [ ] Can code Dijkstra without reference
- [ ] Can code Topo Sort (both) without reference
- [ ] Can explain time/space complexity for each
- [ ] Can handle follow-up variations
- [ ] Complete 40 problems minimum

```
```
File created successfully at: /home/abhishek/Downloads/experiments/learnings/Graph Mastery - Question Path.md
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:17:58.163Z)**_

Created: **Graph Mastery - Question Path.md**

Key improvements over original:
1. **Question-centric** - Each problem has clear "before solving" checks, key insights, and templates
2. **Modular structure** - Grouped by pattern, not just day
3. **Templates integrated** - Code snippets embedded where you'll use them
4. **Pattern recognition table** - Quick lookup for interview keywords
5. **Checkpoint questions** - Validates understanding before moving on
6. **Interview phrases** - What to say when explaining approach
7. **Comparison tables** - When to use which algorithm
8. **Daily drill order** - Maps to original 30-day plan but organized by module

The file is at `/home/abhishek/Downloads/experiments/learnings/Graph Mastery - Question Path.md`

---

_**User (2026-01-25T06:18:10.141Z)**_

see the csv file in that directory 

 fd csv
data/editorial_data.csv
data/problem_data.csv

--- 
use those to analyse the leetcode questions and fill the template with more precise question number / headings 




---

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:18:13.422Z)**_

<think><details><summary>Thought Process</summary>
The user wants me to look at CSV files in the TheEssay directory to get more precise LeetCode question numbers and titles. Let me read those CSV files.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:18:14.237Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/data/problem_data.csv`
```
<tool_use_error>File does not exist.</tool_use_error>
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:18:14.893Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/data/editorial_data.csv`
```
<tool_use_error>File does not exist.</tool_use_error>
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:18:17.929Z)**_

<think><details><summary>Thought Process</summary>
The files don't exist at that path. Let me search for them in the leetcode-screenshotter subdirectory.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:18:18.761Z)**_

<tool-use data-tool-type="search" data-tool-name="Glob"><details>
<summary>Tool use: **Glob**</summary>
 path `/home/abhishek/Downloads/delittt/2026-01-06/TheEssay` pattern `**/*.csv`
```
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/leetcode-screenshotter/data/editorial_data.csv
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/leetcode-screenshotter/data/problem_data.csv
/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/leetcode-screenshotter/editorial_code/download_error.csv
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:18:22.636Z)**_

<think><details><summary>Thought Process</summary>
Found them. Let me read both CSV files.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:18:23.119Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/leetcode-screenshotter/data/problem_data.csv`
```
<tool_use_error>File content (278.4KB) exceeds maximum allowed size (256KB). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.</tool_use_error>
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:18:23.673Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/leetcode-screenshotter/data/editorial_data.csv`
```
File content (31509 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:18:27.663Z)**_

<think><details><summary>Thought Process</summary>
The files are too large. Let me read just the header and some rows, then search for specific graph-related problems.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:18:28.474Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/leetcode-screenshotter/data/problem_data.csv`
```
     1â†’Number,Title,Link,Premium,Acceptance,Difficulty
     2â†’1,Two Sum,https://leetcode.com/problems/two-sum/,FALSE,50.00%,Easy
     3â†’2,Add Two Numbers,https://leetcode.com/problems/add-two-numbers/,FALSE,40.60%,Medium
     4â†’3,Longest Substring Without Repeating Characters,https://leetcode.com/problems/longest-substring-without-repeating-characters/,FALSE,33.80%,Medium
     5â†’4,Median of Two Sorted Arrays,https://leetcode.com/problems/median-of-two-sorted-arrays/,FALSE,36.50%,Hard
     6â†’5,Longest Palindromic Substring,https://leetcode.com/problems/longest-palindromic-substring/,FALSE,32.40%,Medium
     7â†’6,Zigzag Conversion,https://leetcode.com/problems/zigzag-conversion/,FALSE,45.10%,Medium
     8â†’7,Reverse Integer,https://leetcode.com/problems/reverse-integer/,FALSE,27.60%,Medium
     9â†’8,String to Integer (atoi),https://leetcode.com/problems/string-to-integer-atoi/,FALSE,16.60%,Medium
    10â†’9,Palindrome Number,https://leetcode.com/problems/palindrome-number/,FALSE,53.80%,Easy
    11â†’10,Regular Expression Matching,https://leetcode.com/problems/regular-expression-matching/,FALSE,28.00%,Hard
    12â†’11,Container With Most Water,https://leetcode.com/problems/container-with-most-water/,FALSE,54.00%,Medium
    13â†’12,Integer to Roman,https://leetcode.com/problems/integer-to-roman/,FALSE,62.30%,Medium
    14â†’13,Roman to Integer,https://leetcode.com/problems/roman-to-integer/,FALSE,58.60%,Easy
    15â†’14,Longest Common Prefix,https://leetcode.com/problems/longest-common-prefix/,FALSE,41.00%,Easy
    16â†’15,3Sum,https://leetcode.com/problems/3sum/,FALSE,32.70%,Medium
    17â†’16,3Sum Closest,https://leetcode.com/problems/3sum-closest/,FALSE,45.60%,Medium
    18â†’17,Letter Combinations of a Phone Number,https://leetcode.com/problems/letter-combinations-of-a-phone-number/,FALSE,56.90%,Medium
    19â†’18,4Sum,https://leetcode.com/problems/4sum/,FALSE,35.80%,Medium
    20â†’19,Remove Nth Node From End of List,https://leetcode.com/problems/remove-nth-node-from-end-of-list/,FALSE,41.50%,Medium
    21â†’20,Valid Parentheses,https://leetcode.com/problems/valid-parentheses/,FALSE,40.40%,Easy
    22â†’21,Merge Two Sorted Lists,https://leetcode.com/problems/merge-two-sorted-lists/,FALSE,62.70%,Easy
    23â†’22,Generate Parentheses,https://leetcode.com/problems/generate-parentheses/,FALSE,72.80%,Medium
    24â†’23,Merge k Sorted Lists,https://leetcode.com/problems/merge-k-sorted-lists/,FALSE,50.10%,Hard
    25â†’24,Swap Nodes in Pairs,https://leetcode.com/problems/swap-nodes-in-pairs/,FALSE,62.50%,Medium
    26â†’25,Reverse Nodes in k-Group,https://leetcode.com/problems/reverse-nodes-in-k-group/,FALSE,55.10%,Hard
    27â†’26,Remove Duplicates from Sorted Array,https://leetcode.com/problems/remove-duplicates-from-sorted-array/,FALSE,51.90%,Easy
    28â†’27,Remove Element,https://leetcode.com/problems/remove-element/,FALSE,53.40%,Easy
    29â†’28,Find the Index of the First Occurrence in a String,https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/,FALSE,39.50%,Easy
    30â†’29,Divide Two Integers,https://leetcode.com/problems/divide-two-integers/,FALSE,17.10%,Medium
    31â†’30,Substring with Concatenation of All Words,https://leetcode.com/problems/substring-with-concatenation-of-all-words/,FALSE,31.40%,Hard
    32â†’31,Next Permutation,https://leetcode.com/problems/next-permutation/,FALSE,37.80%,Medium
    33â†’32,Longest Valid Parentheses,https://leetcode.com/problems/longest-valid-parentheses/,FALSE,32.90%,Hard
    34â†’33,Search in Rotated Sorted Array,https://leetcode.com/problems/search-in-rotated-sorted-array/,FALSE,39.10%,Medium
    35â†’34,Find First and Last Position of Element in Sorted Array,https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/,FALSE,42.00%,Medium
    36â†’35,Search Insert Position,https://leetcode.com/problems/search-insert-position/,FALSE,43.70%,Easy
    37â†’36,Valid Sudoku,https://leetcode.com/problems/valid-sudoku/,FALSE,58.30%,Medium
    38â†’37,Sudoku Solver,https://leetcode.com/problems/sudoku-solver/,FALSE,58.10%,Hard
    39â†’38,Count and Say,https://leetcode.com/problems/count-and-say/,FALSE,52.40%,Medium
    40â†’39,Combination Sum,https://leetcode.com/problems/combination-sum/,FALSE,68.90%,Medium
    41â†’40,Combination Sum II,https://leetcode.com/problems/combination-sum-ii/,FALSE,53.50%,Medium
    42â†’41,First Missing Positive,https://leetcode.com/problems/first-missing-positive/,FALSE,36.80%,Hard
    43â†’42,Trapping Rain Water,https://leetcode.com/problems/trapping-rain-water/,FALSE,59.40%,Hard
    44â†’43,Multiply Strings,https://leetcode.com/problems/multiply-strings/,FALSE,39.30%,Medium
    45â†’44,Wildcard Matching,https://leetcode.com/problems/wildcard-matching/,FALSE,27.00%,Hard
    46â†’45,Jump Game II,https://leetcode.com/problems/jump-game-ii/,FALSE,39.90%,Medium
    47â†’46,Permutations,https://leetcode.com/problems/permutations/,FALSE,75.90%,Medium
    48â†’47,Permutations II,https://leetcode.com/problems/permutations-ii/,FALSE,57.50%,Medium
    49â†’48,Rotate Image,https://leetcode.com/problems/rotate-image/,FALSE,71.40%,Medium
    50â†’49,Group Anagrams,https://leetcode.com/problems/group-anagrams/,FALSE,66.80%,Medium
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:18:29.292Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/leetcode-screenshotter/data/editorial_data.csv`
```
     1â†’1376,Time Needed to Inform All Employees,https://leetcode.com/problems/time-needed-to-inform-all-employees/solution
     2â†’1,Two Sum,https://leetcode.com/problems/two-sum/solution
     3â†’2,Add Two Numbers,https://leetcode.com/problems/add-two-numbers/solution
     4â†’3,Longest Substring Without Repeating Characters,https://leetcode.com/problems/longest-substring-without-repeating-characters/solution
     5â†’5,Longest Palindromic Substring,https://leetcode.com/problems/longest-palindromic-substring/solution
     6â†’6,Zigzag Conversion,https://leetcode.com/problems/zigzag-conversion/solution
     7â†’7,Reverse Integer,https://leetcode.com/problems/reverse-integer/solution
     8â†’8,String to Integer (atoi),https://leetcode.com/problems/string-to-integer-atoi/solution
     9â†’9,Palindrome Number,https://leetcode.com/problems/palindrome-number/solution
    10â†’10,Regular Expression Matching,https://leetcode.com/problems/regular-expression-matching/solution
    11â†’11,Container With Most Water,https://leetcode.com/problems/container-with-most-water/solution
    12â†’12,Integer to Roman,https://leetcode.com/problems/integer-to-roman/solution
    13â†’13,Roman to Integer,https://leetcode.com/problems/roman-to-integer/solution
    14â†’14,Longest Common Prefix,https://leetcode.com/problems/longest-common-prefix/solution
    15â†’15,3Sum,https://leetcode.com/problems/3sum/solution
    16â†’16,3Sum Closest,https://leetcode.com/problems/3sum-closest/solution
    17â†’17,Letter Combinations of a Phone Number,https://leetcode.com/problems/letter-combinations-of-a-phone-number/solution
    18â†’18,4Sum,https://leetcode.com/problems/4sum/solution
    19â†’19,Remove Nth Node From End of List,https://leetcode.com/problems/remove-nth-node-from-end-of-list/solution
    20â†’20,Valid Parentheses,https://leetcode.com/problems/valid-parentheses/solution
    21â†’21,Merge Two Sorted Lists,https://leetcode.com/problems/merge-two-sorted-lists/solution
    22â†’22,Generate Parentheses,https://leetcode.com/problems/generate-parentheses/solution
    23â†’23,Merge k Sorted Lists,https://leetcode.com/problems/merge-k-sorted-lists/solution
    24â†’24,Swap Nodes in Pairs,https://leetcode.com/problems/swap-nodes-in-pairs/solution
    25â†’25,Reverse Nodes in k-Group,https://leetcode.com/problems/reverse-nodes-in-k-group/solution
    26â†’26,Remove Duplicates from Sorted Array,https://leetcode.com/problems/remove-duplicates-from-sorted-array/solution
    27â†’27,Remove Element,https://leetcode.com/problems/remove-element/solution
    28â†’28,Find the Index of the First Occurrence in a String,https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solution
    29â†’29,Divide Two Integers,https://leetcode.com/problems/divide-two-integers/solution
    30â†’30,Substring with Concatenation of All Words,https://leetcode.com/problems/substring-with-concatenation-of-all-words/solution
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:18:33.076Z)**_

<think><details><summary>Thought Process</summary>
Good. Now let me search for all graph-related problems using grep to find islands, graph, BFS, DFS, topological, shortest path, etc.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:18:33.539Z)**_

Now let me search for all graph-related problems in the CSV.

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:18:36.665Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 path `/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/leetcode-screenshotter/data/problem_data.csv` pattern `Island|Graph|Path|Course|Clone|Bipartite|Component|Tree|Matrix|Orange|Walls|Gate`
```
<persisted-output>
Output too large (39.4KB). Full output saved to: /home/abhishek/.claude/projects/-home-abhishek-Downloads-experiments-learnings/8a0f207a-8928-4aeb-817e-35a4edc794a8/tool-results/toolu_01BkTG6CEgJgLmsrnbeHmrhc.txt

Preview (first 2KB):
55:54,Spiral Matrix,https://leetcode.com/problems/spiral-matrix/,FALSE,46.40%,Medium
60:59,Spiral Matrix II,https://leetcode.com/problems/spiral-matrix-ii/,FALSE,69.70%,Medium
63:62,Unique Paths,https://leetcode.com/problems/unique-paths/,FALSE,62.80%,Medium
64:63,Unique Paths II,https://leetcode.com/problems/unique-paths-ii/,FALSE,39.50%,Medium
65:64,Minimum Path Sum,https://leetcode.com/problems/minimum-path-sum/,FALSE,62.20%,Medium
72:71,Simplify Path,https://leetcode.com/problems/simplify-path/,FALSE,40.60%,Medium
74:73,Set Matrix Zeroes,https://leetcode.com/problems/set-matrix-zeroes/,FALSE,51.80%,Medium
75:74,Search a 2D Matrix,https://leetcode.com/problems/search-a-2d-matrix/,FALSE,48.00%,Medium
95:94,Binary Tree Inorder Traversal,https://leetcode.com/problems/binary-tree-inorder-traversal/,FALSE,74.00%,Easy
96:95,Unique Binary Search Trees II,https://leetcode.com/problems/unique-binary-search-trees-ii/,FALSE,52.70%,Medium
97:96,Unique Binary Search Trees,https://leetcode.com/problems/unique-binary-search-trees/,FALSE,59.80%,Medium
99:98,Validate Binary Search Tree,https://leetcode.com/problems/validate-binary-search-tree/,FALSE,32.10%,Medium
100:99,Recover Binary Search Tree,https://leetcode.com/problems/recover-binary-search-tree/,FALSE,51.30%,Medium
101:100,Same Tree,https://leetcode.com/problems/same-tree/,FALSE,58.50%,Easy
102:101,Symmetric Tree,https://leetcode.com/problems/symmetric-tree/,FALSE,54.60%,Easy
103:102,Binary Tree Level Order Traversal,https://leetcode.com/problems/binary-tree-level-order-traversal/,FALSE,64.70%,Medium
104:103,Binary Tree Zigzag Level Order Traversal,https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/,FALSE,57.10%,Medium
105:104,Maximum Depth of Binary Tree,https://leetcode.com/problems/maximum-depth-of-binary-tree/,FALSE,74.00%,Easy
...
</persisted-output>
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:18:41.682Z)**_

<think><details><summary>Thought Process</summary>
Let me read the full output file and also search for more specific graph terms.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:18:42.712Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `/home/abhishek/.claude/projects/-home-abhishek-Downloads-experiments-learnings/8a0f207a-8928-4aeb-817e-35a4edc794a8/tool-results/toolu_01BkTG6CEgJgLmsrnbeHmrhc.txt`
```
     1â†’55:54,Spiral Matrix,https://leetcode.com/problems/spiral-matrix/,FALSE,46.40%,Medium
     2â†’60:59,Spiral Matrix II,https://leetcode.com/problems/spiral-matrix-ii/,FALSE,69.70%,Medium
     3â†’63:62,Unique Paths,https://leetcode.com/problems/unique-paths/,FALSE,62.80%,Medium
     4â†’64:63,Unique Paths II,https://leetcode.com/problems/unique-paths-ii/,FALSE,39.50%,Medium
     5â†’65:64,Minimum Path Sum,https://leetcode.com/problems/minimum-path-sum/,FALSE,62.20%,Medium
     6â†’72:71,Simplify Path,https://leetcode.com/problems/simplify-path/,FALSE,40.60%,Medium
     7â†’74:73,Set Matrix Zeroes,https://leetcode.com/problems/set-matrix-zeroes/,FALSE,51.80%,Medium
     8â†’75:74,Search a 2D Matrix,https://leetcode.com/problems/search-a-2d-matrix/,FALSE,48.00%,Medium
     9â†’95:94,Binary Tree Inorder Traversal,https://leetcode.com/problems/binary-tree-inorder-traversal/,FALSE,74.00%,Easy
    10â†’96:95,Unique Binary Search Trees II,https://leetcode.com/problems/unique-binary-search-trees-ii/,FALSE,52.70%,Medium
    11â†’97:96,Unique Binary Search Trees,https://leetcode.com/problems/unique-binary-search-trees/,FALSE,59.80%,Medium
    12â†’99:98,Validate Binary Search Tree,https://leetcode.com/problems/validate-binary-search-tree/,FALSE,32.10%,Medium
    13â†’100:99,Recover Binary Search Tree,https://leetcode.com/problems/recover-binary-search-tree/,FALSE,51.30%,Medium
    14â†’101:100,Same Tree,https://leetcode.com/problems/same-tree/,FALSE,58.50%,Easy
    15â†’102:101,Symmetric Tree,https://leetcode.com/problems/symmetric-tree/,FALSE,54.60%,Easy
    16â†’103:102,Binary Tree Level Order Traversal,https://leetcode.com/problems/binary-tree-level-order-traversal/,FALSE,64.70%,Medium
    17â†’104:103,Binary Tree Zigzag Level Order Traversal,https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/,FALSE,57.10%,Medium
    18â†’105:104,Maximum Depth of Binary Tree,https://leetcode.com/problems/maximum-depth-of-binary-tree/,FALSE,74.00%,Easy
    19â†’106:105,Construct Binary Tree from Preorder and Inorder Traversal,https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/,FALSE,61.80%,Medium
    20â†’107:106,Construct Binary Tree from Inorder and Postorder Traversal,https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/,FALSE,60.30%,Medium
    21â†’108:107,Binary Tree Level Order Traversal II,https://leetcode.com/problems/binary-tree-level-order-traversal-ii/,FALSE,61.40%,Medium
    22â†’109:108,Convert Sorted Array to Binary Search Tree,https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/,FALSE,70.10%,Easy
    23â†’110:109,Convert Sorted List to Binary Search Tree,https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/,FALSE,60.40%,Medium
    24â†’111:110,Balanced Binary Tree,https://leetcode.com/problems/balanced-binary-tree/,FALSE,49.40%,Easy
    25â†’112:111,Minimum Depth of Binary Tree,https://leetcode.com/problems/minimum-depth-of-binary-tree/,FALSE,44.70%,Easy
    26â†’113:112,Path Sum,https://leetcode.com/problems/path-sum/,FALSE,48.50%,Easy
    27â†’114:113,Path Sum II,https://leetcode.com/problems/path-sum-ii/,FALSE,57.20%,Medium
    28â†’115:114,Flatten Binary Tree to Linked List,https://leetcode.com/problems/flatten-binary-tree-to-linked-list/,FALSE,62.10%,Medium
    29â†’125:124,Binary Tree Maximum Path Sum,https://leetcode.com/problems/binary-tree-maximum-path-sum/,FALSE,39.30%,Hard
    30â†’134:133,Clone Graph,https://leetcode.com/problems/clone-graph/,FALSE,53.40%,Medium
    31â†’145:144,Binary Tree Preorder Traversal,https://leetcode.com/problems/binary-tree-preorder-traversal/,FALSE,67.20%,Easy
    32â†’146:145,Binary Tree Postorder Traversal,https://leetcode.com/problems/binary-tree-postorder-traversal/,FALSE,68.40%,Easy
    33â†’157:156,Binary Tree Upside Down,https://leetcode.com/problems/binary-tree-upside-down/,TRUE,62.10%,Medium
    34â†’174:173,Binary Search Tree Iterator,https://leetcode.com/problems/binary-search-tree-iterator/,FALSE,70.00%,Medium
    35â†’184:199,Binary Tree Right Side View,https://leetcode.com/problems/binary-tree-right-side-view/,FALSE,61.80%,Medium
    36â†’185:200,Number of Islands,https://leetcode.com/problems/number-of-islands/,FALSE,57.20%,Medium
    37â†’192:207,Course Schedule,https://leetcode.com/problems/course-schedule/,FALSE,45.40%,Medium
    38â†’193:208,Implement Trie (Prefix Tree),https://leetcode.com/problems/implement-trie-prefix-tree/,FALSE,63.00%,Medium
    39â†’195:210,Course Schedule II,https://leetcode.com/problems/course-schedule-ii/,FALSE,48.70%,Medium
    40â†’207:222,Count Complete Tree Nodes,https://leetcode.com/problems/count-complete-tree-nodes/,FALSE,60.90%,Medium
    41â†’211:226,Invert Binary Tree,https://leetcode.com/problems/invert-binary-tree/,FALSE,75.00%,Easy
    42â†’220:235,Lowest Common Ancestor of a Binary Search Tree,https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/,FALSE,62.00%,Medium
    43â†’221:236,Lowest Common Ancestor of a Binary Tree,https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/,FALSE,59.10%,Medium
    44â†’225:240,Search a 2D Matrix II,https://leetcode.com/problems/search-a-2d-matrix-ii/,FALSE,51.20%,Medium
    45â†’235:250,Count Univalue Subtrees,https://leetcode.com/problems/count-univalue-subtrees/,TRUE,55.50%,Medium
    46â†’240:255,Verify Preorder Sequence in Binary Search Tree,https://leetcode.com/problems/verify-preorder-sequence-in-binary-search-tree/,TRUE,48.30%,Medium
    47â†’242:257,Binary Tree Paths,https://leetcode.com/problems/binary-tree-paths/,FALSE,61.70%,Easy
    48â†’246:261,Graph Valid Tree,https://leetcode.com/problems/graph-valid-tree/,TRUE,47.20%,Medium
    49â†’254:270,Closest Binary Search Tree Value,https://leetcode.com/problems/closest-binary-search-tree-value/,TRUE,54.40%,Easy
    50â†’256:272,Closest Binary Search Tree Value II,https://leetcode.com/problems/closest-binary-search-tree-value-ii/,TRUE,58.50%,Hard
    51â†’270:286,Walls and Gates,https://leetcode.com/problems/walls-and-gates/,TRUE,60.50%,Medium
    52â†’281:297,Serialize and Deserialize Binary Tree,https://leetcode.com/problems/serialize-and-deserialize-binary-tree/,FALSE,55.50%,Hard
    53â†’282:298,Binary Tree Longest Consecutive Sequence,https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/,TRUE,52.90%,Medium
    54â†’289:305,Number of Islands II,https://leetcode.com/problems/number-of-islands-ii/,TRUE,39.60%,Hard
    55â†’294:310,Minimum Height Trees,https://leetcode.com/problems/minimum-height-trees/,FALSE,38.60%,Medium
    56â†’295:311,Sparse Matrix Multiplication,https://leetcode.com/problems/sparse-matrix-multiplication/,TRUE,67.60%,Medium
    57â†’298:314,Binary Tree Vertical Order Traversal,https://leetcode.com/problems/binary-tree-vertical-order-traversal/,TRUE,52.30%,Medium
    58â†’307:323,Number of Connected Components in an Undirected Graph,https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/,TRUE,62.30%,Medium
    59â†’313:329,Longest Increasing Path in a Matrix,https://leetcode.com/problems/longest-increasing-path-in-a-matrix/,FALSE,52.50%,Hard
    60â†’315:331,Verify Preorder Serialization of a Binary Tree,https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/,FALSE,44.70%,Medium
    61â†’317:333,Largest BST Subtree,https://leetcode.com/problems/largest-bst-subtree/,TRUE,42.90%,Medium
    62â†’350:366,Find Leaves of Binary Tree,https://leetcode.com/problems/find-leaves-of-binary-tree/,TRUE,80.30%,Medium
    63â†’362:378,Kth Smallest Element in a Sorted Matrix,https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/,FALSE,61.80%,Medium
    64â†’370:386,Lexicographical Numbers,https://leetcode.com/problems/lexicographical-numbers/,FALSE,61.90%,Medium
    65â†’372:388,Longest Absolute File Path,https://leetcode.com/problems/longest-absolute-file-path/,FALSE,46.70%,Medium
    66â†’410:426,Convert Binary Search Tree to Sorted Doubly Linked List,https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/,TRUE,64.70%,Medium
    67â†’411:427,Construct Quad Tree,https://leetcode.com/problems/construct-quad-tree/,FALSE,74.60%,Medium
    68â†’412:428,Serialize and Deserialize N-ary Tree,https://leetcode.com/problems/serialize-and-deserialize-n-ary-tree/,TRUE,66.10%,Hard
    69â†’413:429,N-ary Tree Level Order Traversal,https://leetcode.com/problems/n-ary-tree-level-order-traversal/,FALSE,70.70%,Medium
    70â†’415:431,Encode N-ary Tree to Binary Tree,https://leetcode.com/problems/encode-n-ary-tree-to-binary-tree/,TRUE,78.90%,Hard
    71â†’421:437,Path Sum III,https://leetcode.com/problems/path-sum-iii/,FALSE,47.80%,Medium
    72â†’424:440,K-th Smallest in Lexicographical Order,https://leetcode.com/problems/k-th-smallest-in-lexicographical-order/,FALSE,31.30%,Hard
    73â†’447:463,Island Perimeter,https://leetcode.com/problems/island-perimeter/,FALSE,69.70%,Easy
    74â†’485:501,Find Mode in Binary Search Tree,https://leetcode.com/problems/find-mode-in-binary-search-tree/,FALSE,49.50%,Easy
    75â†’492:508,Most Frequent Subtree Sum,https://leetcode.com/problems/most-frequent-subtree-sum/,FALSE,65.10%,Medium
    76â†’495:513,Find Bottom Left Tree Value,https://leetcode.com/problems/find-bottom-left-tree-value/,FALSE,67.00%,Medium
    77â†’497:515,Find Largest Value in Each Tree Row,https://leetcode.com/problems/find-largest-value-in-each-tree-row/,FALSE,64.50%,Medium
    78â†’501:519,Random Flip Matrix,https://leetcode.com/problems/random-flip-matrix/,FALSE,40.20%,Medium
    79â†’517:536,Construct Binary Tree from String,https://leetcode.com/problems/construct-binary-tree-from-string/,TRUE,56.30%,Medium
    80â†’519:538,Convert BST to Greater Tree,https://leetcode.com/problems/convert-bst-to-greater-tree/,FALSE,68.00%,Medium
    81â†’523:542,01 Matrix,https://leetcode.com/problems/01-matrix/,FALSE,45.00%,Medium
    82â†’524:543,Diameter of Binary Tree,https://leetcode.com/problems/diameter-of-binary-tree/,FALSE,57.10%,Easy
    83â†’526:545,Boundary of Binary Tree,https://leetcode.com/problems/boundary-of-binary-tree/,TRUE,44.60%,Medium
    84â†’530:549,Binary Tree Longest Consecutive Sequence II,https://leetcode.com/problems/binary-tree-longest-consecutive-sequence-ii/,TRUE,49.50%,Medium
    85â†’538:558,Logical OR of Two Binary Grids Represented as Quad-Trees,https://leetcode.com/problems/logical-or-of-two-binary-grids-represented-as-quad-trees/,FALSE,48.80%,Medium
    86â†’539:559,Maximum Depth of N-ary Tree,https://leetcode.com/problems/maximum-depth-of-n-ary-tree/,FALSE,71.70%,Easy
    87â†’542:562,Longest Line of Consecutive One in Matrix,https://leetcode.com/problems/longest-line-of-consecutive-one-in-matrix/,TRUE,50.30%,Medium
    88â†’543:563,Binary Tree Tilt,https://leetcode.com/problems/binary-tree-tilt/,FALSE,60.20%,Easy
    89â†’546:566,Reshape the Matrix,https://leetcode.com/problems/reshape-the-matrix/,FALSE,63.00%,Easy
    90â†’549:572,Subtree of Another Tree,https://leetcode.com/problems/subtree-of-another-tree/,FALSE,46.50%,Easy
    91â†’552:576,Out of Boundary Paths,https://leetcode.com/problems/out-of-boundary-paths/,FALSE,44.30%,Medium
    92â†’558:589,N-ary Tree Preorder Traversal,https://leetcode.com/problems/n-ary-tree-preorder-traversal/,FALSE,75.80%,Easy
    93â†’559:590,N-ary Tree Postorder Traversal,https://leetcode.com/problems/n-ary-tree-postorder-traversal/,FALSE,77.50%,Easy
    94â†’569:606,Construct String from Binary Tree,https://leetcode.com/problems/construct-string-from-binary-tree/,FALSE,64.20%,Easy
    95â†’573:617,Merge Two Binary Trees,https://leetcode.com/problems/merge-two-binary-trees/,FALSE,78.70%,Easy
    96â†’576:623,Add One Row to Tree,https://leetcode.com/problems/add-one-row-to-tree/,FALSE,59.50%,Medium
    97â†’581:630,Course Schedule III,https://leetcode.com/problems/course-schedule-iii/,FALSE,40.20%,Hard
    98â†’588:637,Average of Levels in Binary Tree,https://leetcode.com/problems/average-of-levels-in-binary-tree/,FALSE,71.70%,Easy
    99â†’603:652,Find Duplicate Subtrees,https://leetcode.com/problems/find-duplicate-subtrees/,FALSE,59.00%,Medium
   100â†’605:654,Maximum Binary Tree,https://leetcode.com/problems/maximum-binary-tree/,FALSE,84.80%,Medium
   101â†’606:655,Print Binary Tree,https://leetcode.com/problems/print-binary-tree/,FALSE,62.20%,Medium
   102â†’607:656,Coin Path,https://leetcode.com/problems/coin-path/,TRUE,31.90%,Hard
   103â†’613:662,Maximum Width of Binary Tree,https://leetcode.com/problems/maximum-width-of-binary-tree/,FALSE,42.70%,Medium
   104â†’614:663,Equal Tree Partition,https://leetcode.com/problems/equal-tree-partition/,TRUE,41.40%,Medium
   105â†’617:666,Path Sum IV,https://leetcode.com/problems/path-sum-iv/,TRUE,59.50%,Medium
   106â†’620:669,Trim a Binary Search Tree,https://leetcode.com/problems/trim-a-binary-search-tree/,FALSE,66.30%,Medium
   107â†’622:671,Second Minimum Node In a Binary Tree,https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/,FALSE,44.10%,Easy
   108â†’626:675,Cut Off Trees for Golf Event,https://leetcode.com/problems/cut-off-trees-for-golf-event/,FALSE,34.10%,Hard
   109â†’638:687,Longest Univalue Path,https://leetcode.com/problems/longest-univalue-path/,FALSE,40.50%,Medium
   110â†’645:694,Number of Distinct Islands,https://leetcode.com/problems/number-of-distinct-islands/,TRUE,60.80%,Medium
   111â†’646:695,Max Area of Island,https://leetcode.com/problems/max-area-of-island/,FALSE,71.80%,Medium
   112â†’651:700,Search in a Binary Search Tree,https://leetcode.com/problems/search-in-a-binary-search-tree/,FALSE,77.90%,Easy
   113â†’652:701,Insert into a Binary Search Tree,https://leetcode.com/problems/insert-into-a-binary-search-tree/,FALSE,74.20%,Medium
   114â†’662:711,Number of Distinct Islands II,https://leetcode.com/problems/number-of-distinct-islands-ii/,TRUE,52.10%,Hard
   115â†’693:742,Closest Leaf in a Binary Tree,https://leetcode.com/problems/closest-leaf-in-a-binary-tree/,TRUE,45.90%,Medium
   116â†’707:756,Pyramid Transition Matrix,https://leetcode.com/problems/pyramid-transition-matrix/,FALSE,52.70%,Medium
   117â†’717:766,Toeplitz Matrix,https://leetcode.com/problems/toeplitz-matrix/,FALSE,68.50%,Easy
   118â†’736:785,Is Graph Bipartite?,https://leetcode.com/problems/is-graph-bipartite/,FALSE,54.50%,Medium
   119â†’748:797,All Paths From Source to Target,https://leetcode.com/problems/all-paths-from-source-to-target/,FALSE,82.30%,Medium
   120â†’765:814,Binary Tree Pruning,https://leetcode.com/problems/binary-tree-pruning/,FALSE,72.40%,Medium
   121â†’768:817,Linked List Components,https://leetcode.com/problems/linked-list-components/,FALSE,57.50%,Medium
   122â†’774:823,Binary Trees With Factors,https://leetcode.com/problems/binary-trees-with-factors/,FALSE,49.70%,Medium
   123â†’778:827,Making A Large Island,https://leetcode.com/problems/making-a-large-island/,FALSE,45.00%,Hard
   124â†’785:834,Sum of Distances in Tree,https://leetcode.com/problems/sum-of-distances-in-tree/,FALSE,59.10%,Hard
   125â†’798:847,Shortest Path Visiting All Nodes,https://leetcode.com/problems/shortest-path-visiting-all-nodes/,FALSE,60.80%,Hard
   126â†’812:861,Score After Flipping Matrix,https://leetcode.com/problems/score-after-flipping-matrix/,FALSE,74.90%,Medium
   127â†’814:863,All Nodes Distance K in Binary Tree,https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/,FALSE,62.40%,Medium
   128â†’815:864,Shortest Path to Get All Keys,https://leetcode.com/problems/shortest-path-to-get-all-keys/,FALSE,45.60%,Hard
   129â†’816:865,Smallest Subtree with all the Deepest Nodes,https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/,FALSE,69.00%,Medium
   130â†’818:867,Transpose Matrix,https://leetcode.com/problems/transpose-matrix/,FALSE,64.60%,Easy
   131â†’823:872,Leaf-Similar Trees,https://leetcode.com/problems/leaf-similar-trees/,FALSE,67.70%,Easy
   132â†’833:882,Reachable Nodes In Subdivided Graph,https://leetcode.com/problems/reachable-nodes-in-subdivided-graph/,FALSE,50.00%,Hard
   133â†’836:885,Spiral Matrix III,https://leetcode.com/problems/spiral-matrix-iii/,FALSE,73.70%,Medium
   134â†’840:889,Construct Binary Tree from Preorder and Postorder Traversal,https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/,FALSE,71.10%,Medium
   135â†’845:894,All Possible Full Binary Trees,https://leetcode.com/problems/all-possible-full-binary-trees/,FALSE,80.00%,Medium
   136â†’848:897,Increasing Order Search Tree,https://leetcode.com/problems/increasing-order-search-tree/,FALSE,78.30%,Easy
   137â†’870:919,Complete Binary Tree Inserter,https://leetcode.com/problems/complete-binary-tree-inserter/,FALSE,64.60%,Medium
   138â†’882:931,Minimum Falling Path Sum,https://leetcode.com/problems/minimum-falling-path-sum/,FALSE,69.20%,Medium
   139â†’902:951,Flip Equivalent Binary Trees,https://leetcode.com/problems/flip-equivalent-binary-trees/,FALSE,66.80%,Medium
   140â†’903:952,Largest Component Size by Common Factor,https://leetcode.com/problems/largest-component-size-by-common-factor/,FALSE,40.10%,Hard
   141â†’909:958,Check Completeness of a Binary Tree,https://leetcode.com/problems/check-completeness-of-a-binary-tree/,FALSE,56.20%,Medium
   142â†’916:965,Univalued Binary Tree,https://leetcode.com/problems/univalued-binary-tree/,FALSE,69.90%,Easy
   143â†’919:968,Binary Tree Cameras,https://leetcode.com/problems/binary-tree-cameras/,FALSE,46.60%,Hard
   144â†’922:971,Flip Binary Tree To Match Preorder Traversal,https://leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal/,FALSE,50.10%,Medium
   145â†’930:979,Distribute Coins in Binary Tree,https://leetcode.com/problems/distribute-coins-in-binary-tree/,FALSE,72.30%,Medium
   146â†’931:980,Unique Paths III,https://leetcode.com/problems/unique-paths-iii/,FALSE,81.60%,Hard
   147â†’938:987,Vertical Order Traversal of a Binary Tree,https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/,FALSE,45.30%,Hard
   148â†’944:993,Cousins in Binary Tree,https://leetcode.com/problems/cousins-in-binary-tree/,FALSE,54.80%,Easy
   149â†’945:994,Rotting Oranges,https://leetcode.com/problems/rotting-oranges/,FALSE,53.10%,Medium
   150â†’949:998,Maximum Binary Tree II,https://leetcode.com/problems/maximum-binary-tree-ii/,FALSE,67.40%,Medium
   151â†’959:1008,Construct Binary Search Tree from Preorder Traversal,https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/,FALSE,81.30%,Medium
   152â†’979:1028,Recover a Tree From Preorder Traversal,https://leetcode.com/problems/recover-a-tree-from-preorder-traversal/,FALSE,73.30%,Hard
   153â†’981:1030,Matrix Cells in Distance Order,https://leetcode.com/problems/matrix-cells-in-distance-order/,FALSE,69.70%,Easy
   154â†’989:1038,Binary Search Tree to Greater Sum Tree,https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/,FALSE,85.60%,Medium
   155â†’1008:1059,All Paths from Source Lead to Destination,https://leetcode.com/problems/all-paths-from-source-lead-to-destination/,TRUE,39.00%,Medium
   156â†’1010:1061,Lexicographically Smallest Equivalent String,https://leetcode.com/problems/lexicographically-smallest-equivalent-string/,FALSE,76.60%,Medium
   157â†’1023:1080,Insufficient Nodes in Root to Leaf Paths,https://leetcode.com/problems/insufficient-nodes-in-root-to-leaf-paths/,FALSE,53.80%,Medium
   158â†’1031:1091,Shortest Path in Binary Matrix,https://leetcode.com/problems/shortest-path-in-binary-matrix/,FALSE,46.40%,Medium
   159â†’1040:1102,Path With Maximum Minimum Value,https://leetcode.com/problems/path-with-maximum-minimum-value/,TRUE,53.30%,Medium
   160â†’1042:1104,Path In Zigzag Labelled Binary Tree,https://leetcode.com/problems/path-in-zigzag-labelled-binary-tree/,FALSE,75.10%,Medium
   161â†’1051:1120,Maximum Average Subtree,https://leetcode.com/problems/maximum-average-subtree/,TRUE,65.60%,Medium
   162â†’1058:1129,Shortest Path with Alternating Colors,https://leetcode.com/problems/shortest-path-with-alternating-colors/,FALSE,48.40%,Medium
   163â†’1059:1130,Minimum Cost Tree From Leaf Values,https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/,FALSE,68.20%,Medium
   164â†’1064:1136,Parallel Courses,https://leetcode.com/problems/parallel-courses/,TRUE,61.40%,Medium
   165â†’1066:1138,Alphabet Board Path,https://leetcode.com/problems/alphabet-board-path/,FALSE,52.00%,Medium
   166â†’1071:1145,Binary Tree Coloring Game,https://leetcode.com/problems/binary-tree-coloring-game/,FALSE,51.80%,Medium
   167â†’1083:1161,Maximum Level Sum of a Binary Tree,https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/,FALSE,66.00%,Medium
   168â†’1085:1163,Last Substring in Lexicographical Order,https://leetcode.com/problems/last-substring-in-lexicographical-order/,FALSE,34.80%,Hard
   169â†’1129:1219,Path with Maximum Gold,https://leetcode.com/problems/path-with-maximum-gold/,FALSE,63.60%,Medium
   170â†’1151:1245,Tree Diameter,https://leetcode.com/problems/tree-diameter/,TRUE,61.50%,Medium
   171â†’1157:1252,Cells with Odd Values in a Matrix,https://leetcode.com/problems/cells-with-odd-values-in-a-matrix/,FALSE,78.50%,Easy
   172â†’1158:1253,Reconstruct a 2-Row Binary Matrix,https://leetcode.com/problems/reconstruct-a-2-row-binary-matrix/,FALSE,44.50%,Medium
   173â†’1159:1254,Number of Closed Islands,https://leetcode.com/problems/number-of-closed-islands/,FALSE,66.90%,Medium
   174â†’1166:1261,Find Elements in a Contaminated Binary Tree,https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/,FALSE,76.50%,Medium
   175â†’1176:1273,Delete Tree Nodes,https://leetcode.com/problems/delete-tree-nodes/,TRUE,61.10%,Medium
   176â†’1185:1284,Minimum Number of Flips to Convert Binary Matrix to Zero Matrix,https://leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/,FALSE,71.80%,Hard
   177â†’1189:1289,Minimum Falling Path Sum II,https://leetcode.com/problems/minimum-falling-path-sum-ii/,FALSE,58.30%,Hard
   178â†’1193:1293,Shortest Path in a Grid with Obstacles Elimination,https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/,FALSE,45.30%,Hard
   179â†’1200:1301,Number of Paths with Max Score,https://leetcode.com/problems/number-of-paths-with-max-score/,FALSE,38.70%,Hard
   180â†’1203:1305,All Elements in Two Binary Search Trees,https://leetcode.com/problems/all-elements-in-two-binary-search-trees/,FALSE,79.90%,Medium
   181â†’1211:1314,Matrix Block Sum,https://leetcode.com/problems/matrix-block-sum/,FALSE,75.50%,Medium
   182â†’1223:1329,Sort the Matrix Diagonally,https://leetcode.com/problems/sort-the-matrix-diagonally/,FALSE,83.30%,Medium
   183â†’1230:1337,The K Weakest Rows in a Matrix,https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/,FALSE,71.80%,Easy
   184â†’1232:1339,Maximum Product of Splitted Binary Tree,https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/,FALSE,47.80%,Medium
   185â†’1242:1351,Count Negative Numbers in a Sorted Matrix,https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/,FALSE,75.50%,Easy
   186â†’1251:1361,Validate Binary Tree Nodes,https://leetcode.com/problems/validate-binary-tree-nodes/,FALSE,39.70%,Medium
   187â†’1256:1367,Linked List in Binary Tree,https://leetcode.com/problems/linked-list-in-binary-tree/,FALSE,43.80%,Medium
   188â†’1257:1368,Minimum Cost to Make at Least One Valid Path in a Grid,https://leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/,FALSE,61.60%,Hard
   189â†’1260:1372,Longest ZigZag Path in a Binary Tree,https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/,FALSE,67.30%,Medium
   190â†’1261:1373,Maximum Sum BST in Binary Tree,https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/,FALSE,39.70%,Hard
   191â†’1266:1379,Find a Corresponding Node of a Binary Tree in a Clone of That Tree,https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/,FALSE,86.40%,Easy
   192â†’1267:1380,Lucky Numbers in a Matrix,https://leetcode.com/problems/lucky-numbers-in-a-matrix/,FALSE,70.60%,Easy
   193â†’1269:1382,Balance a Binary Search Tree,https://leetcode.com/problems/balance-a-binary-search-tree/,FALSE,80.70%,Medium
   194â†’1277:1391,Check if There is a Valid Path in a Grid,https://leetcode.com/problems/check-if-there-is-a-valid-path-in-a-grid/,FALSE,47.40%,Medium
   195â†’1297:1415,The k-th Lexicographical String of All Happy Strings of Length n,https://leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/,FALSE,72.70%,Medium
   196â†’1311:1430,Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree,https://leetcode.com/problems/check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree/,TRUE,46.50%,Medium
   197â†’1319:1439,Find the Kth Smallest Sum of a Matrix With Sorted Rows,https://leetcode.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/,FALSE,61.40%,Hard
   198â†’1322:1443,Minimum Time to Collect All Apples in a Tree,https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/,FALSE,62.60%,Medium
   199â†’1326:1448,Count Good Nodes in Binary Tree,https://leetcode.com/problems/count-good-nodes-in-binary-tree/,FALSE,74.20%,Medium
   200â†’1334:1457,Pseudo-Palindromic Paths in a Binary Tree,https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/,FALSE,67.70%,Medium
   201â†’1338:1462,Course Schedule IV,https://leetcode.com/problems/course-schedule-iv/,FALSE,49.10%,Medium
   202â†’1342:1466,Reorder Routes to Make All Paths Lead to the City Zero,https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/,FALSE,66.60%,Medium
   203â†’1357:1483,Kth Ancestor of a Tree Node,https://leetcode.com/problems/kth-ancestor-of-a-tree-node/,FALSE,33.80%,Hard
   204â†’1358:1485,Clone Binary Tree With Random Pointer,https://leetcode.com/problems/clone-binary-tree-with-random-pointer/,TRUE,80.60%,Medium
   205â†’1362:1489,Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree,https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/,FALSE,52.50%,Hard
   206â†’1363:1490,Clone N-ary Tree,https://leetcode.com/problems/clone-n-ary-tree/,TRUE,83.40%,Medium
   207â†’1367:1494,Parallel Courses II,https://leetcode.com/problems/parallel-courses-ii/,FALSE,30.30%,Hard
   208â†’1368:1496,Path Crossing,https://leetcode.com/problems/path-crossing/,FALSE,56.00%,Easy
   209â†’1377:1506,Find Root of N-Ary Tree,https://leetcode.com/problems/find-root-of-n-ary-tree/,TRUE,78.60%,Medium
   210â†’1384:1514,Path with Maximum Probability,https://leetcode.com/problems/path-with-maximum-probability/,FALSE,48.90%,Medium
   211â†’1386:1516,Move Sub-Tree of N-Ary Tree,https://leetcode.com/problems/move-sub-tree-of-n-ary-tree/,TRUE,63.20%,Hard
   212â†’1388:1519,Number of Nodes in the Sub-Tree With the Same Label,https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/,FALSE,55.30%,Medium
   213â†’1391:1522,Diameter of N-Ary Tree,https://leetcode.com/problems/diameter-of-n-ary-tree/,TRUE,73.60%,Medium
   214â†’1414:1548,The Most Similar Path in a Graph,https://leetcode.com/problems/the-most-similar-path-in-a-graph/,TRUE,58.90%,Hard
   215â†’1418:1553,Minimum Number of Days to Eat N Oranges,https://leetcode.com/problems/minimum-number-of-days-to-eat-n-oranges/,FALSE,34.80%,Hard
   216â†’1431:1568,Minimum Number of Days to Disconnect Island,https://leetcode.com/problems/minimum-number-of-days-to-disconnect-island/,FALSE,46.30%,Hard
   217â†’1434:1572,Matrix Diagonal Sum,https://leetcode.com/problems/matrix-diagonal-sum/,FALSE,82.80%,Easy
   218â†’1441:1579,Remove Max Number of Edges to Keep Graph Fully Traversable,https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/,FALSE,65.40%,Hard
   219â†’1443:1582,Special Positions in a Binary Matrix,https://leetcode.com/problems/special-positions-in-a-binary-matrix/,FALSE,65.20%,Easy
   220â†’1447:1586,Binary Search Tree Iterator II,https://leetcode.com/problems/binary-search-tree-iterator-ii/,TRUE,70.60%,Medium
   221â†’1454:1594,Maximum Non Negative Product in a Matrix,https://leetcode.com/problems/maximum-non-negative-product-in-a-matrix/,FALSE,33.10%,Medium
   222â†’1456:1597,Build Binary Expression Tree From Infix Expression,https://leetcode.com/problems/build-binary-expression-tree-from-infix-expression/,TRUE,62.60%,Hard
   223â†’1461:1602,Find Nearest Right Node in Binary Tree,https://leetcode.com/problems/find-nearest-right-node-in-binary-tree/,TRUE,75.50%,Medium
   224â†’1464:1605,Find Valid Matrix Given Row and Column Sums,https://leetcode.com/problems/find-valid-matrix-given-row-and-column-sums/,FALSE,77.80%,Medium
   225â†’1467:1609,Even Odd Tree,https://leetcode.com/problems/even-odd-tree/,FALSE,54.60%,Medium
   226â†’1470:1612,Check If Two Expression Trees are Equivalent,https://leetcode.com/problems/check-if-two-expression-trees-are-equivalent/,TRUE,70.30%,Medium
   227â†’1474:1617,Count Subtrees With Max Distance Between Cities,https://leetcode.com/problems/count-subtrees-with-max-distance-between-cities/,FALSE,65.90%,Hard
   228â†’1481:1625,Lexicographically Smallest String After Applying Operations,https://leetcode.com/problems/lexicographically-smallest-string-after-applying-operations/,FALSE,65.80%,Medium
   229â†’1483:1627,Graph Connectivity With Threshold,https://leetcode.com/problems/graph-connectivity-with-threshold/,FALSE,46.40%,Hard
   230â†’1484:1628,Design an Expression Tree With Evaluate Function,https://leetcode.com/problems/design-an-expression-tree-with-evaluate-function/,TRUE,82.80%,Medium
   231â†’1487:1631,Path With Minimum Effort,https://leetcode.com/problems/path-with-minimum-effort/,FALSE,55.90%,Medium
   232â†’1488:1632,Rank Transform of a Matrix,https://leetcode.com/problems/rank-transform-of-a-matrix/,FALSE,40.90%,Hard
   233â†’1498:1644,Lowest Common Ancestor of a Binary Tree II,https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/,TRUE,60.10%,Medium
   234â†’1503:1650,Lowest Common Ancestor of a Binary Tree III,https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/,TRUE,77.50%,Medium
   235â†’1512:1660,Correct a Binary Tree,https://leetcode.com/problems/correct-a-binary-tree/,TRUE,72.50%,Medium
   236â†’1517:1666,Change the Root of a Binary Tree,https://leetcode.com/problems/change-the-root-of-a-binary-tree/,TRUE,73.20%,Medium
   237â†’1526:1676,Lowest Common Ancestor of a Binary Tree IV,https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iv/,TRUE,79.50%,Medium
   238â†’1544:1697,Checking Existence of Edge Length Limited Paths,https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/,FALSE,63.10%,Hard
   239â†’1562:1718,Construct the Lexicographically Largest Valid Sequence,https://leetcode.com/problems/construct-the-lexicographically-largest-valid-sequence/,FALSE,52.40%,Medium
   240â†’1563:1719,Number Of Ways To Reconstruct A Tree,https://leetcode.com/problems/number-of-ways-to-reconstruct-a-tree/,FALSE,43.70%,Hard
   241â†’1568:1724,Checking Existence of Edge Length Limited Paths II,https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths-ii/,TRUE,52.40%,Hard
   242â†’1571:1727,Largest Submatrix With Rearrangements,https://leetcode.com/problems/largest-submatrix-with-rearrangements/,FALSE,61.50%,Medium
   243â†’1573:1730,Shortest Path to Get Food,https://leetcode.com/problems/shortest-path-to-get-food/,TRUE,54.20%,Medium
   244â†’1582:1740,Find Distance in a Binary Tree,https://leetcode.com/problems/find-distance-in-a-binary-tree/,TRUE,69.50%,Medium
   245â†’1600:1761,Minimum Degree of a Connected Trio in a Graph,https://leetcode.com/problems/minimum-degree-of-a-connected-trio-in-a-graph/,FALSE,41.50%,Hard
   246â†’1605:1766,Tree of Coprimes,https://leetcode.com/problems/tree-of-coprimes/,FALSE,39.60%,Hard
   247â†’1615:1778,Shortest Path in a Hidden Grid,https://leetcode.com/problems/shortest-path-in-a-hidden-grid/,TRUE,39.10%,Medium
   248â†’1622:1786,Number of Restricted Paths From First to Last Node,https://leetcode.com/problems/number-of-restricted-paths-from-first-to-last-node/,FALSE,39.10%,Medium
   249â†’1626:1791,Find Center of Star Graph,https://leetcode.com/problems/find-center-of-star-graph/,FALSE,83.50%,Easy
   250â†’1638:1804,Implement Trie II (Prefix Tree),https://leetcode.com/problems/implement-trie-ii-prefix-tree/,TRUE,59.70%,Medium
   251â†’1643:1810,Minimum Path Cost in a Hidden Grid,https://leetcode.com/problems/minimum-path-cost-in-a-hidden-grid/,TRUE,54.60%,Medium
   252â†’1684:1857,Largest Color Value in a Directed Graph,https://leetcode.com/problems/largest-color-value-in-a-directed-graph/,FALSE,52.00%,Hard
   253â†’1710:1886,Determine Whether Matrix Can Be Obtained By Rotation,https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/,FALSE,56.10%,Easy
   254â†’1727:1905,Count Sub Islands,https://leetcode.com/problems/count-sub-islands/,FALSE,67.80%,Medium
   255â†’1742:1923,Longest Common Subpath,https://leetcode.com/problems/longest-common-subpath/,FALSE,27.60%,Hard
   256â†’1779:1964,Find the Longest Valid Obstacle Course at Each Position,https://leetcode.com/problems/find-the-longest-valid-obstacle-course-at-each-position/,FALSE,64.10%,Hard
   257â†’1785:1971,Find if Path Exists in Graph,https://leetcode.com/problems/find-if-path-exists-in-graph/,FALSE,51.80%,Easy
   258â†’1788:1975,Maximum Matrix Sum,https://leetcode.com/problems/maximum-matrix-sum/,FALSE,48.50%,Medium
   259â†’1803:1993,Operations on Tree,https://leetcode.com/problems/operations-on-tree/,FALSE,44.10%,Medium
   260â†’1813:2003,Smallest Missing Genetic Value in Each Subtree,https://leetcode.com/problems/smallest-missing-genetic-value-in-each-subtree/,FALSE,44.80%,Hard
   261â†’1814:2005,Subtree Removal Game with Fibonacci Tree,https://leetcode.com/problems/subtree-removal-game-with-fibonacci-tree/,TRUE,62.00%,Hard
   262â†’1828:2021,Brightest Position on Street,https://leetcode.com/problems/brightest-position-on-street/,TRUE,62.20%,Medium
   263â†’1855:2050,Parallel Courses III,https://leetcode.com/problems/parallel-courses-iii/,FALSE,59.10%,Hard
   264â†’1869:2065,Maximum Path Quality of a Graph,https://leetcode.com/problems/maximum-path-quality-of-a-graph/,FALSE,56.90%,Hard
   265â†’1879:2077,Paths in Maze That Lead to Same Room,https://leetcode.com/problems/paths-in-maze-that-lead-to-same-room/,TRUE,55.30%,Medium
   266â†’1896:2096,Step-By-Step Directions From a Binary Tree Node to Another,https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/,FALSE,48.50%,Medium
   267â†’1921:2123,Minimum Operations to Remove Adjacent Ones in Matrix,https://leetcode.com/problems/minimum-operations-to-remove-adjacent-ones-in-matrix/,TRUE,41.10%,Hard
   268â†’1985:2192,All Ancestors of a Node in a Directed Acyclic Graph,https://leetcode.com/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/,FALSE,50.70%,Medium
   269â†’1989:2196,Create Binary Tree From Descriptions,https://leetcode.com/problems/create-binary-tree-from-descriptions/,FALSE,72.30%,Medium
   270â†’1995:2203,Minimum Weighted Subgraph With the Required Paths,https://leetcode.com/problems/minimum-weighted-subgraph-with-the-required-paths/,FALSE,36.10%,Hard
   271â†’1996:2204,Distance to a Cycle in Undirected Graph,https://leetcode.com/problems/distance-to-a-cycle-in-undirected-graph/,TRUE,70.10%,Hard
   272â†’2026:2237,Count Positions on Street With Required Brightness,https://leetcode.com/problems/count-positions-on-street-with-required-brightness/,TRUE,63.80%,Medium
   273â†’2033:2245,Maximum Trailing Zeros in a Cornered Path,https://leetcode.com/problems/maximum-trailing-zeros-in-a-cornered-path/,FALSE,35.20%,Medium
   274â†’2034:2246,Longest Path With Different Adjacent Characters,https://leetcode.com/problems/longest-path-with-different-adjacent-characters/,FALSE,55.50%,Hard
   275â†’2051:2265,Count Nodes Equal to Average of Subtree,https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/,FALSE,85.00%,Medium
   276â†’2053:2267,Check if There Is a Valid Parentheses String Path,https://leetcode.com/problems/check-if-there-is-a-valid-parentheses-string-path/,FALSE,37.90%,Hard
   277â†’2063:2277,Closest Node to Path in Tree,https://leetcode.com/problems/closest-node-to-path-in-tree/,TRUE,63.80%,Hard
   278â†’2088:2304,Minimum Path Cost in a Grid,https://leetcode.com/problems/minimum-path-cost-in-a-grid/,FALSE,65.80%,Medium
   279â†’2096:2313,Minimum Flips in Binary Tree to Get Result,https://leetcode.com/problems/minimum-flips-in-binary-tree-to-get-result/,TRUE,61.90%,Hard
   280â†’2098:2316,Count Unreachable Pairs of Nodes in an Undirected Graph,https://leetcode.com/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/,FALSE,50.60%,Medium
   281â†’2101:2319,Check if Matrix Is X-Matrix,https://leetcode.com/problems/check-if-matrix-is-x-matrix/,FALSE,66.20%,Easy
   282â†’2104:2322,Minimum Score After Removals on a Tree,https://leetcode.com/problems/minimum-score-after-removals-on-a-tree/,FALSE,50.70%,Hard
   283â†’2107:2326,Spiral Matrix IV,https://leetcode.com/problems/spiral-matrix-iv/,FALSE,75.00%,Medium
   284â†’2109:2328,Number of Increasing Paths in a Grid,https://leetcode.com/problems/number-of-increasing-paths-in-a-grid/,FALSE,47.80%,Hard
   285â†’2111:2331,Evaluate Boolean Binary Tree,https://leetcode.com/problems/evaluate-boolean-binary-tree/,FALSE,78.30%,Easy
   286â†’2137:2360,Longest Cycle in a Graph,https://leetcode.com/problems/longest-cycle-in-a-graph/,FALSE,50.60%,Hard
   287â†’2148:2373,Largest Local Values in a Matrix,https://leetcode.com/problems/largest-local-values-in-a-matrix/,FALSE,83.10%,Easy
   288â†’2152:2378,Choose Edges to Maximize Score in a Tree,https://leetcode.com/problems/choose-edges-to-maximize-score-in-a-tree/,TRUE,59.90%,Medium
   289â†’2159:2385,Amount of Time for Binary Tree to Be Infected,https://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/,FALSE,56.90%,Medium
   290â†’2161:2387,Median of a Row Wise Sorted Matrix,https://leetcode.com/problems/median-of-a-row-wise-sorted-matrix/,TRUE,68.20%,Medium
   291â†’2165:2392,Build a Matrix With Conditions,https://leetcode.com/problems/build-a-matrix-with-conditions/,FALSE,59.80%,Hard
   292â†’2187:2415,Reverse Odd Levels of Binary Tree,https://leetcode.com/problems/reverse-odd-levels-of-binary-tree/,FALSE,77.00%,Medium
   293â†’2193:2421,Number of Good Paths,https://leetcode.com/problems/number-of-good-paths/,FALSE,57.30%,Hard
   294â†’2206:2434,Using a Robot to Print the Lexicographically Smallest String,https://leetcode.com/problems/using-a-robot-to-print-the-lexicographically-smallest-string/,FALSE,38.40%,Medium
   295â†’2207:2435,Paths in Matrix Whose Sum Is Divisible by K,https://leetcode.com/problems/paths-in-matrix-whose-sum-is-divisible-by-k/,FALSE,41.90%,Hard
   296â†’2212:2440,Create Components With Same Value,https://leetcode.com/problems/create-components-with-same-value/,FALSE,53.40%,Hard
   297â†’2230:2458,Height of Binary Tree After Subtree Removal Queries,https://leetcode.com/problems/height-of-binary-tree-after-subtree-removal-queries/,FALSE,37.10%,Hard
   298â†’2239:2467,Most Profitable Path in a Tree,https://leetcode.com/problems/most-profitable-path-in-a-tree/,FALSE,48.00%,Medium
   299â†’2243:2471,Minimum Number of Operations to Sort a Binary Tree by Level,https://leetcode.com/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/,FALSE,62.10%,Medium
   300â†’2247:2476,Closest Nodes Queries in a Binary Search Tree,https://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/,FALSE,40.90%,Medium
   301â†’2250:2479,Maximum XOR of Two Non-Overlapping Subtrees,https://leetcode.com/problems/maximum-xor-of-two-non-overlapping-subtrees/,TRUE,46.70%,Hard
   302â†’2262:2492,Minimum Score of a Path Between Two Cities,https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/,FALSE,57.80%,Medium
   303â†’2266:2497,Maximum Star Sum of a Graph,https://leetcode.com/problems/maximum-star-sum-of-a-graph/,FALSE,38.30%,Medium
   304â†’2277:2509,Cycle Length Queries in a Tree,https://leetcode.com/problems/cycle-length-queries-in-a-tree/,FALSE,56.70%,Hard
   305â†’2278:2510,Check if There is a Path With Equal Number of 0's And 1's,https://leetcode.com/problems/check-if-there-is-a-path-with-equal-number-of-0s-and-1s/,TRUE,51.90%,Medium
   306â†’2324:2556,Disconnect Path in a Binary Matrix by at Most One Flip,https://leetcode.com/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/,FALSE,28.40%,Medium
   307â†’2351:2583,Kth Largest Sum in a Binary Tree,https://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/,FALSE,46.90%,Medium
   308â†’2371:2603,Collect Coins in a Tree,https://leetcode.com/problems/collect-coins-in-a-tree/,FALSE,37.60%,Hard
   309â†’2376:2608,Shortest Cycle in a Graph,https://leetcode.com/problems/shortest-cycle-in-a-graph/,FALSE,38.30%,Hard
   310â†’2389:2641,Cousins in Binary Tree II,https://leetcode.com/problems/cousins-in-binary-tree-ii/,FALSE,68.60%,Medium
   311â†’2390:2642,Design Graph With Shortest Path Calculator,https://leetcode.com/problems/design-graph-with-shortest-path-calculator/,FALSE,57.50%,Hard
   312â†’2407:2662,Minimum Cost of a Path With Special Roads,https://leetcode.com/problems/minimum-cost-of-a-path-with-special-roads/,FALSE,34.80%,Medium
   313â†’2408:2663,Lexicographically Smallest Beautiful String,https://leetcode.com/problems/lexicographically-smallest-beautiful-string/,FALSE,39.00%,Hard
   314â†’2413:2673,Make Costs of Paths Equal in a Binary Tree,https://leetcode.com/problems/make-costs-of-paths-equal-in-a-binary-tree/,FALSE,58.90%,Medium
   315â†’2416:2679,Sum in a Matrix,https://leetcode.com/problems/sum-in-a-matrix/,FALSE,59.80%,Medium
   316â†’2422:2685,Count the Number of Complete Components,https://leetcode.com/problems/count-the-number-of-complete-components/,FALSE,67.30%,Medium
   317â†’2423:2689,Extract Kth Character From The Rope Tree,https://leetcode.com/problems/extract-kth-character-from-the-rope-tree/,TRUE,74.30%,Easy
   318â†’2425:2697,Lexicographically Smallest Palindrome,https://leetcode.com/problems/lexicographically-smallest-palindrome/,FALSE,82.00%,Easy
   319â†’2427:2699,Modify Graph Edge Weights,https://leetcode.com/problems/modify-graph-edge-weights/,FALSE,19.50%,Hard
   320â†’2436:2713,Maximum Strictly Increasing Cells in a Matrix,https://leetcode.com/problems/maximum-strictly-increasing-cells-in-a-matrix/,FALSE,22.60%,Hard
   321â†’2437:2714,Find Shortest Path with K Hops,https://leetcode.com/problems/find-shortest-path-with-k-hops/,TRUE,61.40%,Hard
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:18:50.082Z)**_

<think><details><summary>Thought Process</summary>
Excellent! Now I have a comprehensive list of graph-related problems with their exact titles, numbers, difficulty, and acceptance rates. Let me also search for more specific patterns like Dijkstra, Union Find, Topological, etc.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:18:53.142Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 path `/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/leetcode-screenshotter/data/problem_data.csv` pattern `Dijkstra|Union|Topological|Network|Delay|Flight|Connect|Redundant|Province|Word Ladder|Clone|Bipartite|Safe|Accounts`
```
127:126,Word Ladder II,https://leetcode.com/problems/word-ladder-ii/,FALSE,27.50%,Hard
128:127,Word Ladder,https://leetcode.com/problems/word-ladder/,FALSE,37.30%,Hard
134:133,Clone Graph,https://leetcode.com/problems/clone-graph/,FALSE,53.40%,Medium
307:323,Number of Connected Components in an Undirected Graph,https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/,TRUE,62.30%,Medium
528:547,Number of Provinces,https://leetcode.com/problems/number-of-provinces/,FALSE,64.00%,Medium
635:684,Redundant Connection,https://leetcode.com/problems/redundant-connection/,FALSE,62.40%,Medium
636:685,Redundant Connection II,https://leetcode.com/problems/redundant-connection-ii/,FALSE,34.10%,Hard
672:721,Accounts Merge,https://leetcode.com/problems/accounts-merge/,FALSE,56.30%,Medium
694:743,Network Delay Time,https://leetcode.com/problems/network-delay-time/,FALSE,52.10%,Medium
704:753,Cracking the Safe,https://leetcode.com/problems/cracking-the-safe/,FALSE,55.90%,Hard
736:785,Is Graph Bipartite?,https://leetcode.com/problems/is-graph-bipartite/,FALSE,54.50%,Medium
738:787,Cheapest Flights Within K Stops,https://leetcode.com/problems/cheapest-flights-within-k-stops/,FALSE,37.10%,Medium
753:802,Find Eventual Safe States,https://leetcode.com/problems/find-eventual-safe-states/,FALSE,57.30%,Medium
1046:1109,Corporate Flight Bookings,https://leetcode.com/problems/corporate-flight-bookings/,FALSE,60.70%,Medium
1063:1135,Connecting Cities With Minimum Cost,https://leetcode.com/problems/connecting-cities-with-minimum-cost/,TRUE,61.40%,Medium
1088:1167,Minimum Cost to Connect Sticks,https://leetcode.com/problems/minimum-cost-to-connect-sticks/,TRUE,68.60%,Medium
1109:1192,Critical Connections in a Network,https://leetcode.com/problems/critical-connections-in-a-network/,FALSE,54.70%,Hard
1216:1319,Number of Operations to Make Network Connected,https://leetcode.com/problems/number-of-operations-to-make-network-connected/,FALSE,62.20%,Medium
1266:1379,Find a Corresponding Node of a Binary Tree in a Clone of That Tree,https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/,FALSE,86.40%,Easy
1358:1485,Clone Binary Tree With Random Pointer,https://leetcode.com/problems/clone-binary-tree-with-random-pointer/,TRUE,80.60%,Medium
1363:1490,Clone N-ary Tree,https://leetcode.com/problems/clone-n-ary-tree/,TRUE,83.40%,Medium
1431:1568,Minimum Number of Days to Disconnect Island,https://leetcode.com/problems/minimum-number-of-days-to-disconnect-island/,FALSE,46.30%,Hard
1445:1584,Min Cost to Connect All Points,https://leetcode.com/problems/min-cost-to-connect-all-points/,FALSE,64.00%,Medium
1455:1595,Minimum Cost to Connect Two Groups of Points,https://leetcode.com/problems/minimum-cost-to-connect-two-groups-of-points/,FALSE,46.90%,Hard
1472:1615,Maximal Network Rank,https://leetcode.com/problems/maximal-network-rank/,FALSE,58.80%,Medium
1477:1620,Coordinate With Maximum Network Quality,https://leetcode.com/problems/coordinate-with-maximum-network-quality/,FALSE,37.50%,Medium
1483:1627,Graph Connectivity With Threshold,https://leetcode.com/problems/graph-connectivity-with-threshold/,FALSE,46.40%,Hard
1600:1761,Minimum Degree of a Connected Trio in a Graph,https://leetcode.com/problems/minimum-degree-of-a-connected-trio-in-a-graph/,FALSE,41.50%,Hard
1845:2039,The Time When the Network Becomes Idle,https://leetcode.com/problems/the-time-when-the-network-becomes-idle/,FALSE,50.80%,Medium
2324:2556,Disconnect Path in a Binary Matrix by at Most One Flip,https://leetcode.com/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/,FALSE,28.40%,Medium
2396:2651,Calculate Delayed Arrival Time,https://leetcode.com/problems/calculate-delayed-arrival-time/,FALSE,81.80%,Easy
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:18:57.896Z)**_

<think><details><summary>Thought Process</summary>
Now I have all the data I need. Let me also search for a few more specific problems mentioned in the original worksheet.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:19:01.038Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 path `/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/leetcode-screenshotter/data/problem_data.csv` pattern `Surrounded|Pacific|Atlantic|Word Search|Open the Lock|Alien|Minimum Genetic|Reconstruct Itinerary|Campus Bike`
```
No matches found
```
</details></tool-use>

---

_**User (2026-01-25T06:19:02.043Z)**_

[Request interrupted by user for tool use]

_**User (2026-01-25T06:19:08.295Z)**_

continue. 

---

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:19:11.697Z)**_

<think><details><summary>Thought Process</summary>
The user wants me to continue. Let me search for the remaining problems with slightly different patterns.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:19:12.832Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 path `/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/leetcode-screenshotter/data/problem_data.csv` pattern `Surround|Pacific|Word Search|Lock|Genetic|Itinerary|Bike`
```
80:79,Word Search,https://leetcode.com/problems/word-search/,FALSE,40.30%,Medium
131:130,Surrounded Regions,https://leetcode.com/problems/surrounded-regions/,FALSE,37.10%,Medium
197:212,Word Search II,https://leetcode.com/problems/word-search-ii/,FALSE,36.30%,Hard
316:332,Reconstruct Itinerary,https://leetcode.com/problems/reconstruct-itinerary/,FALSE,41.30%,Hard
335:351,Android Unlock Patterns,https://leetcode.com/problems/android-unlock-patterns/,TRUE,51.60%,Medium
401:417,Pacific Atlantic Water Flow,https://leetcode.com/problems/pacific-atlantic-water-flow/,FALSE,54.50%,Medium
417:433,Minimum Genetic Mutation,https://leetcode.com/problems/minimum-genetic-mutation/,FALSE,52.50%,Medium
703:752,Open the Lock,https://leetcode.com/problems/open-the-lock/,FALSE,55.70%,Medium
1006:1057,Campus Bikes,https://leetcode.com/problems/campus-bikes/,TRUE,57.60%,Medium
1015:1066,Campus Bikes II,https://leetcode.com/problems/campus-bikes-ii/,TRUE,54.90%,Medium
1113:1199,Minimum Time to Build Blocks,https://leetcode.com/problems/minimum-time-to-build-blocks/,TRUE,41.00%,Hard
1211:1314,Matrix Block Sum,https://leetcode.com/problems/matrix-block-sum/,FALSE,75.50%,Medium
1236:1344,Angle Between Hands of a Clock,https://leetcode.com/problems/angle-between-hands-of-a-clock/,FALSE,63.30%,Medium
1756:1938,Maximum Genetic Difference Query,https://leetcode.com/problems/maximum-genetic-difference-query/,FALSE,39.80%,Hard
1813:2003,Smallest Missing Genetic Value in Each Subtree,https://leetcode.com/problems/smallest-missing-genetic-value-in-each-subtree/,FALSE,44.80%,Hard
2153:2379,Minimum Recolors to Get K Consecutive Black Blocks,https://leetcode.com/problems/minimum-recolors-to-get-k-consecutive-black-blocks/,FALSE,57.80%,Easy
2209:2437,Number of Valid Clock Times,https://leetcode.com/problems/number-of-valid-clock-times/,FALSE,43.50%,Easy
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:19:17.054Z)**_

<think><details><summary>Thought Process</summary>
Now I have all the data I need. Let me also get a few more specific problems that were in the original 30-day worksheet.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:19:18.757Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 path `/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/leetcode-screenshotter/data/problem_data.csv` pattern `Copy List|Random Pointer|Possible Bipartition|City.*Neighbor|Find the City`
```
139:138,Copy List with Random Pointer,https://leetcode.com/problems/copy-list-with-random-pointer/,FALSE,51.70%,Medium
837:886,Possible Bipartition,https://leetcode.com/problems/possible-bipartition/,FALSE,50.10%,Medium
1228:1334,Find the City With the Smallest Number of Neighbors at a Threshold Distance,https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/,FALSE,55.40%,Medium
1358:1485,Clone Binary Tree With Random Pointer,https://leetcode.com/problems/clone-binary-tree-with-random-pointer/,TRUE,80.60%,Medium
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:19:22.866Z)**_

<think><details><summary>Thought Process</summary>
Now I have all the data. Let me also search for a few more from the original worksheet.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:19:24.456Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 path `/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/leetcode-screenshotter/data/problem_data.csv` pattern `Satisfiability|Equality|Map.*Highest|Far.*Land|Destination City|Sub.*Folder`
```
941:990,Satisfiability of Equality Equations,https://leetcode.com/problems/satisfiability-of-equality-equations/,FALSE,50.50%,Medium
1084:1162,As Far from Land as Possible,https://leetcode.com/problems/as-far-from-land-as-possible/,FALSE,51.80%,Medium
1141:1233,Remove Sub-Folders from the Filesystem,https://leetcode.com/problems/remove-sub-folders-from-the-filesystem/,FALSE,65.60%,Medium
1316:1436,Destination City,https://leetcode.com/problems/destination-city/,FALSE,77.30%,Easy
1604:1765,Map of Highest Peak,https://leetcode.com/problems/map-of-highest-peak/,FALSE,60.50%,Medium
1802:1992,Find All Groups of Farmland,https://leetcode.com/problems/find-all-groups-of-farmland/,FALSE,68.30%,Medium
2198:2426,Number of Pairs Satisfying Inequality,https://leetcode.com/problems/number-of-pairs-satisfying-inequality/,FALSE,43.20%,Hard
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:19:29.095Z)**_

<think><details><summary>Thought Process</summary>
Now I have all the data I need. Let me also check for the 2D Grid Cycle detection problem mentioned in the original worksheet.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:19:30.442Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 path `/home/abhishek/Downloads/delittt/2026-01-06/TheEssay/leetcode-screenshotter/data/problem_data.csv` pattern `Cycle.*2D|2D.*Cycle|Detect Cycle|Enclave`
```
971:1020,Number of Enclaves,https://leetcode.com/problems/number-of-enclaves/,FALSE,68.70%,Medium
1423:1559,Detect Cycles in 2D Grid,https://leetcode.com/problems/detect-cycles-in-2d-grid/,FALSE,48.10%,Medium
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:19:35.013Z)**_

<think><details><summary>Thought Process</summary>
Now I have all the data I need. Let me update the Graph Mastery file with precise question numbers and titles from the CSV data.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:19:35.545Z)**_

Now let me update the file with precise data from the CSV.

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:21:54.219Z)**_

<tool-use data-tool-type="write" data-tool-name="Write"><details>
<summary>Tool use: **Write**</summary>

```md
# Graph Mastery: Question-Wise Path

## Legend
| Symbol | Meaning |
|--------|---------|
| â­ | Must-do (interview essential) |
| ğŸ”‘ | Key insight problem |
| ğŸ“ | Pattern introduction |
| ğŸ’ | Premium problem |
| â†’ | Leads to / progression |

---

# Phase 1: Foundations (Days 1-7)

## Module 1.1: Graph Representation
**Goal:** Build any graph from scratch

### Q1: LC 1971 - Find if Path Exists in Graph ğŸ“
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Easy | 51.80% | No |

**Pattern:** Graph construction + basic traversal
**Before solving:**
- Can you build adjacency list from edge list?
- What's the difference between directed vs undirected representation?

\```python
# Template: Build adjacency list
def build_graph(n, edges, directed=False):
    adj = [[] for _ in range(n)]
    for u, v in edges:
        adj[u].append(v)
        if not directed:
            adj[v].append(u)
    return adj
\```

**Checkpoint:** Solve this in <5 mins including graph construction.

---

## Module 1.2: DFS Mastery
**Goal:** Write DFS in sleep, understand stack behavior

### Q2: LC 797 - All Paths From Source to Target â­ğŸ“
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 82.30% | No |

**Pattern:** DFS path enumeration
**Key insight:** When do you need to backtrack vs when visited stays marked?
- Here: **Backtrack** (same node can appear in different paths)
- Connected components: **Stay marked** (just counting)

\```python
# Template: DFS with path tracking (backtracking)
def dfs_paths(node, target, adj, path, result):
    if node == target:
        result.append(path[:])
        return
    for neighbor in adj[node]:
        path.append(neighbor)
        dfs_paths(neighbor, target, adj, path, result)
        path.pop()  # backtrack
\```

### Q3: LC 547 - Number of Provinces â­ğŸ”‘
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 64.00% | No |

**Pattern:** Connected components via DFS
**Key insight:** Each DFS call "floods" one component. Count the floods.

\```python
# Template: Count connected components
def count_components(n, adj):
    visited = set()
    count = 0
    for node in range(n):
        if node not in visited:
            dfs(node, adj, visited)
            count += 1
    return count
\```

**Warning:** This problem gives adjacency MATRIX, not list. Convert or adapt.

### Q4: LC 695 - Max Area of Island â­
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 71.80% | No |

**Pattern:** DFS on grid returning value
**Key insight:** DFS returns area count, sum up 1 + recursive calls.

\```python
# Template: DFS on grid with return value
def dfs_grid(grid, r, c, visited):
    if r < 0 or r >= len(grid) or c < 0 or c >= len(grid[0]):
        return 0
    if (r, c) in visited or grid[r][c] == 0:
        return 0
    visited.add((r, c))
    return 1 + sum(dfs_grid(grid, r+dr, c+dc, visited)
                   for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)])
\```

---

## Module 1.3: BFS Mastery
**Goal:** Understand why BFS gives shortest path in unweighted graphs

### Q5: LC 1091 - Shortest Path in Binary Matrix â­â­ğŸ“
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 46.40% | No |

**Pattern:** BFS shortest path in grid
**Key insight:** First time BFS reaches a cell = shortest distance (unweighted).

\```python
# Template: BFS shortest path
from collections import deque

def bfs_shortest(grid, start, end):
    if grid[start[0]][start[1]] == 1:
        return -1

    queue = deque([(start[0], start[1], 1)])  # (r, c, distance)
    visited = {start}
    directions = [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]

    while queue:
        r, c, dist = queue.popleft()
        if (r, c) == end:
            return dist
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]):
                if (nr, nc) not in visited and grid[nr][nc] == 0:
                    visited.add((nr, nc))
                    queue.append((nr, nc, dist + 1))
    return -1
\```

### Q6: LC 542 - 01 Matrix â­â­
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 45.00% | No |

**Pattern:** Multi-source BFS
**Key insight:** Start BFS from ALL zeros simultaneously. Distance propagates outward.

### Q7: LC 1162 - As Far from Land as Possible
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 51.80% | No |

**Pattern:** Multi-source BFS (inverse of 542)

### Q8: LC 994 - Rotting Oranges â­â­â­ğŸ”‘
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 53.10% | No |

**Pattern:** Multi-source BFS + level tracking
**Core technique:**
1. Add ALL rotten oranges to queue initially
2. Process level by level
3. Track time = number of levels

\```python
# Template: Multi-source BFS with level tracking
def multi_source_bfs(grid, sources):
    queue = deque(sources)  # all sources added initially
    time = 0

    while queue:
        for _ in range(len(queue)):  # process current level
            r, c = queue.popleft()
            for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)]:
                nr, nc = r + dr, c + dc
                if valid(nr, nc) and should_process(grid[nr][nc]):
                    grid[nr][nc] = mark_processed
                    queue.append((nr, nc))
        if queue:  # more levels to process
            time += 1
    return time
\```

### Q9: LC 286 - Walls and Gates ğŸ’
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 60.50% | Yes |

**Pattern:** Multi-source BFS from gates

### Q10: LC 1765 - Map of Highest Peak
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 60.50% | No |

**Pattern:** Multi-source BFS from water cells

---

## Module 1.4: Grid as Graph
**Goal:** Navigate any grid problem with confidence

### Q11: LC 200 - Number of Islands â­â­â­â­â­ğŸ“
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 57.20% | No |

**Pattern:** Connected components on grid
**This is THE grid-graph problem.** Master this, everything else is variation.

\```python
# Core technique: "Sink" the island as you visit
def numIslands(grid):
    count = 0
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            if grid[r][c] == '1':
                sink_island(grid, r, c)  # DFS that marks visited by changing to '0'
                count += 1
    return count
\```

### Q12: LC 463 - Island Perimeter
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Easy | 69.70% | No |

**Pattern:** Grid counting (different from traversal)
**Insight:** Each land cell contributes 4 - (number of land neighbors).

### Q13: LC 1254 - Number of Closed Islands
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 66.90% | No |

**Pattern:** "Touched boundary" detection
**Key insight:** Island is NOT closed if any DFS reaches boundary.

### Q14: LC 1020 - Number of Enclaves
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 68.70% | No |

**Pattern:** Similar to closed islands - count land not connected to boundary

---

## Module 1.5: Clone Problems
**Goal:** Handle node references correctly

### Q15: LC 133 - Clone Graph â­â­â­â­â­ğŸ”‘
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 53.40% | No |

**Pattern:** HashMap oldâ†’new mapping
**Key insight:** Build clone as you traverse, lookup prevents infinite loops.

\```python
# Template: Graph cloning
def cloneGraph(node):
    if not node:
        return None

    old_to_new = {}

    def dfs(node):
        if node in old_to_new:
            return old_to_new[node]

        copy = Node(node.val)
        old_to_new[node] = copy  # map BEFORE recursing

        for neighbor in node.neighbors:
            copy.neighbors.append(dfs(neighbor))

        return copy

    return dfs(node)
\```

### Q16: LC 138 - Copy List with Random Pointer
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 51.70% | No |

**Pattern:** Same HashMap technique for linked list

---

# Phase 2: Cycles & Ordering (Days 8-14)

## Module 2.1: Cycle Detection - Undirected
**Goal:** Detect cycles using parent tracking

### Q17: LC 684 - Redundant Connection â­â­â­â­ğŸ“
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 62.40% | No |

**Pattern:** Find the edge that creates a cycle
**Two approaches:**
1. DFS with parent tracking
2. Union-Find (better for this problem)

\```python
# Template: Cycle detection in undirected (DFS)
def has_cycle_undirected(node, parent, adj, visited):
    visited.add(node)
    for neighbor in adj[node]:
        if neighbor == parent:
            continue  # don't go back to parent
        if neighbor in visited:
            return True  # cycle found!
        if has_cycle_undirected(neighbor, node, adj, visited):
            return True
    return False
\```

### Q18: LC 261 - Graph Valid Tree â­â­â­â­ğŸ’
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 47.20% | Yes |

**Pattern:** Tree = connected + no cycle
**Checks:**
1. n-1 edges (necessary but not sufficient)
2. All nodes reachable from node 0
3. No cycle

---

## Module 2.2: Cycle Detection - Directed
**Goal:** Master three-color algorithm

### Q19: LC 207 - Course Schedule â­â­â­â­â­ğŸ“ğŸ”‘
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 45.40% | No |

**Pattern:** Detect cycle in directed graph
**THE core problem for topological sort/cycle detection.**

\```python
# Template: Three-color cycle detection
# WHITE=0 (unvisited), GRAY=1 (in current path), BLACK=2 (done)
def has_cycle_directed(node, adj, color):
    color[node] = 1  # GRAY - currently exploring

    for neighbor in adj[node]:
        if color[neighbor] == 1:  # back edge to node in current path
            return True
        if color[neighbor] == 0:  # unvisited
            if has_cycle_directed(neighbor, adj, color):
                return True

    color[node] = 2  # BLACK - done exploring
    return False
\```

**Interview phrase:** "I'm using the three-color algorithm. Gray nodes are in the current DFS path. If we reach a gray node, we've found a back edge, which means a cycle."

### Q20: LC 802 - Find Eventual Safe States
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 57.30% | No |

**Pattern:** Reverse cycle detection
**Insight:** Safe = not part of any cycle. Find all nodes that are BLACK after DFS.

---

## Module 2.3: Topological Sort
**Goal:** Know both approaches cold

### Q21: LC 210 - Course Schedule II â­â­â­â­â­ğŸ“
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 48.70% | No |

**Pattern:** Topological ordering

**Approach 1: DFS Post-order (reverse)**
\```python
def topo_dfs(n, adj):
    color = [0] * n
    order = []

    def dfs(node):
        color[node] = 1
        for neighbor in adj[node]:
            if color[neighbor] == 1:
                return False  # cycle
            if color[neighbor] == 0:
                if not dfs(neighbor):
                    return False
        color[node] = 2
        order.append(node)  # post-order
        return True

    for i in range(n):
        if color[i] == 0:
            if not dfs(i):
                return []  # cycle exists

    return order[::-1]  # reverse post-order
\```

### Q22: LC 210 - Course Schedule II (Kahn's) â­â­â­â­â­
**Approach 2: BFS with in-degree**
\```python
def topo_kahn(n, adj):
    in_degree = [0] * n
    for u in range(n):
        for v in adj[u]:
            in_degree[v] += 1

    queue = deque([i for i in range(n) if in_degree[i] == 0])
    order = []

    while queue:
        node = queue.popleft()
        order.append(node)
        for neighbor in adj[node]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)

    return order if len(order) == n else []  # cycle if not all processed
\```

**When to use which:**
- DFS: When you need to detect cycle + order together
- Kahn's: When you need level-by-level processing (parallel courses)

### Q23: LC 1462 - Course Schedule IV
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 49.10% | No |

**Pattern:** Topological sort + reachability queries

### Q24: LC 310 - Minimum Height Trees ğŸ”‘
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 38.60% | No |

**Pattern:** Kahn's from leaves inward
**Insight:** Keep removing leaves until 1-2 nodes remain. Those are the centers.

### Q25: LC 2050 - Parallel Courses III
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Hard | 59.10% | No |

**Pattern:** Kahn's + track longest path to each node

### Q26: LC 1136 - Parallel Courses ğŸ’
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 61.40% | Yes |

**Pattern:** Kahn's with level tracking for minimum semesters

---

## Module 2.4: Build Graph from Constraints

### Q27: LC 269 - Alien Dictionary â­â­â­â­ğŸ”‘ğŸ’
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Hard | ~35% | Yes |

**Pattern:** Extract edges from ordering, then topo sort
**Key insight:** Compare adjacent words to find ONE edge per pair.

\```python
# Extract edges from word ordering
def extract_edges(words):
    edges = []
    for i in range(len(words) - 1):
        w1, w2 = words[i], words[i+1]
        for c1, c2 in zip(w1, w2):
            if c1 != c2:
                edges.append((c1, c2))  # c1 comes before c2
                break
        else:
            if len(w1) > len(w2):  # "abc" before "ab" is invalid
                return None
    return edges
\```

---

## Module 2.5: Bipartite Graphs

### Q28: LC 785 - Is Graph Bipartite? â­â­â­ğŸ“
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 54.50% | No |

**Pattern:** Two-coloring
**Insight:** Bipartite âŸº no odd-length cycles âŸº 2-colorable

\```python
# Template: Bipartite check
def is_bipartite(adj, n):
    color = [-1] * n

    for start in range(n):
        if color[start] != -1:
            continue
        queue = deque([start])
        color[start] = 0

        while queue:
            node = queue.popleft()
            for neighbor in adj[node]:
                if color[neighbor] == color[node]:
                    return False  # same color = not bipartite
                if color[neighbor] == -1:
                    color[neighbor] = 1 - color[node]
                    queue.append(neighbor)
    return True
\```

### Q29: LC 886 - Possible Bipartition
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 50.10% | No |

**Pattern:** Bipartite on implicit graph
**Build graph:** If A dislikes B, they must be in different groups.

---

# Phase 3: Union-Find & Shortest Paths (Days 15-21)

## Module 3.1: Union-Find

### Template: Union-Find with Path Compression
\```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
        self.components = n

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # path compression
        return self.parent[x]

    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px == py:
            return False  # already connected

        # union by rank
        if self.rank[px] < self.rank[py]:
            px, py = py, px
        self.parent[py] = px
        if self.rank[px] == self.rank[py]:
            self.rank[px] += 1

        self.components -= 1
        return True
\```

### Q30: LC 323 - Number of Connected Components in an Undirected Graph â­â­â­â­ğŸ“ğŸ’
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 62.30% | Yes |

**Pattern:** Basic Union-Find application
**Compare:** DFS also works. UF is better for dynamic connectivity.

### Q31: LC 684 - Redundant Connection (revisit with UF) â­â­â­â­
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 62.40% | No |

**Pattern:** First edge that connects already-connected nodes
**With UF:** Process edges in order. First `union()` that returns False = answer.

### Q32: LC 547 - Number of Provinces (revisit with UF) â­â­â­
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 64.00% | No |

**Pattern:** Connected components - compare DFS vs UF approach

### Q33: LC 1319 - Number of Operations to Make Network Connected
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 62.20% | No |

**Pattern:** Count components, check if enough extra edges exist

### Q34: LC 721 - Accounts Merge â­â­â­ğŸ”‘
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 56.30% | No |

**Pattern:** Union-Find with string mapping
**Key:** Map each email to an index, union emails within same account.

### Q35: LC 990 - Satisfiability of Equality Equations
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 50.50% | No |

**Pattern:** Process == first (union), then check != (should not be same root)

### Q36: LC 1579 - Remove Max Number of Edges to Keep Graph Fully Traversable
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Hard | 65.40% | No |

**Pattern:** Two Union-Find instances (Alice & Bob) + greedy edge removal

---

## Module 3.2: Dijkstra's Algorithm

### Core Understanding
**When to use:** Weighted graph + non-negative weights + single-source shortest path

**Why it works:** When we pop a node from min-heap, its distance is final. Any alternative path through a farther node can only add non-negative cost.

**Why negative edges break it:** A "farther" node could provide a shortcut via negative edge.

### Template: Dijkstra
\```python
import heapq

def dijkstra(n, adj, source):
    dist = [float('inf')] * n
    dist[source] = 0
    heap = [(0, source)]

    while heap:
        d, node = heapq.heappop(heap)

        if d > dist[node]:  # stale entry
            continue

        for neighbor, weight in adj[node]:
            new_dist = d + weight
            if new_dist < dist[neighbor]:
                dist[neighbor] = new_dist
                heapq.heappush(heap, (new_dist, neighbor))

    return dist
\```

### Q37: LC 743 - Network Delay Time â­â­â­â­ğŸ“
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 52.10% | No |

**Pattern:** Basic Dijkstra
**Answer:** Max of all distances (time for signal to reach farthest node)

### Q38: LC 787 - Cheapest Flights Within K Stops â­â­â­ğŸ”‘
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 37.10% | No |

**Pattern:** Modified Dijkstra with state = (cost, node, stops)
**Key:** Can't just skip stale entries. Node might be reached with fewer stops later.

\```python
# Modified state: (cost, node, stops_remaining)
def cheapest_k_stops(n, flights, src, dst, k):
    adj = defaultdict(list)
    for u, v, w in flights:
        adj[u].append((v, w))

    heap = [(0, src, k + 1)]  # (cost, node, stops_remaining)

    while heap:
        cost, node, stops = heapq.heappop(heap)

        if node == dst:
            return cost

        if stops > 0:
            for neighbor, price in adj[node]:
                heapq.heappush(heap, (cost + price, neighbor, stops - 1))

    return -1
\```

### Q39: LC 1631 - Path With Minimum Effort â­â­â­
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 55.90% | No |

**Pattern:** Dijkstra on grid with custom weight
**Weight:** max absolute difference along path (not sum)

### Q40: LC 1514 - Path with Maximum Probability
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 48.90% | No |

**Pattern:** Dijkstra with max-heap (or negate probabilities)

---

## Module 3.3: Bellman-Ford & Floyd-Warshall

### When to use
| Algorithm | Use case | Complexity |
|-----------|----------|------------|
| Dijkstra | Single-source, non-negative weights | O((V+E) log V) |
| Bellman-Ford | Single-source, handles negative weights | O(V Ã— E) |
| Floyd-Warshall | All-pairs shortest path | O(VÂ³) |

### Q41: LC 787 - Cheapest Flights (Bellman-Ford approach)
**Why it works here:** K stops = K+1 edges = K+1 relaxation rounds

### Q42: LC 1334 - Find the City With the Smallest Number of Neighbors at a Threshold Distance
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 55.40% | No |

**Pattern:** Floyd-Warshall to get all-pairs, then filter by threshold

---

# Phase 4: Advanced Patterns (Days 22-27)

## Module 4.1: Backtracking on Graphs

### Q43: LC 79 - Word Search â­â­â­â­ğŸ“
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 40.30% | No |

**Pattern:** DFS with backtracking
**Key difference from regular DFS:** Unmark visited after exploring (same cell can be in different paths)

\```python
def exist(board, word):
    def dfs(r, c, idx):
        if idx == len(word):
            return True
        if r < 0 or r >= len(board) or c < 0 or c >= len(board[0]):
            return False
        if board[r][c] != word[idx]:
            return False

        temp = board[r][c]
        board[r][c] = '#'  # mark visited

        found = any(dfs(r+dr, c+dc, idx+1)
                   for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)])

        board[r][c] = temp  # backtrack
        return found

    for r in range(len(board)):
        for c in range(len(board[0])):
            if dfs(r, c, 0):
                return True
    return False
\```

### Q44: LC 980 - Unique Paths III â­â­â­
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Hard | 81.60% | No |

**Pattern:** Backtracking + count all valid paths
**Must visit:** All empty cells exactly once

### Q45: LC 1066 - Campus Bikes II ğŸ’
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 54.90% | Yes |

**Pattern:** Backtracking with bitmask DP optimization

---

## Module 4.2: Trie + Graph

### Q46: LC 212 - Word Search II â­â­â­â­ğŸ”‘
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Hard | 36.30% | No |

**Pattern:** Trie optimization for multiple word search
**Key insight:** Build Trie of words, DFS on grid while traversing Trie simultaneously

### Q47: LC 1233 - Remove Sub-Folders from the Filesystem
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 65.60% | No |

**Pattern:** Trie for path matching

---

## Module 4.3: Advanced Grid Problems

### Q48: LC 130 - Surrounded Regions â­â­â­â­ğŸ“
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 37.10% | No |

**Pattern:** Boundary-connected DFS
**Insight:** Mark 'O's connected to boundary. Everything else gets captured.

### Q49: LC 417 - Pacific Atlantic Water Flow â­â­â­â­ğŸ”‘
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 54.50% | No |

**Pattern:** Reverse DFS from oceans
**Key insight:** Instead of "can water flow to ocean?", ask "where can ocean reach?"
Start DFS from all ocean borders, find intersection.

### Q50: LC 1559 - Detect Cycles in 2D Grid
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 48.10% | No |

**Pattern:** Cycle detection on grid (4-directional)

### Q51: LC 1905 - Count Sub Islands
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 67.80% | No |

**Pattern:** DFS with validation against parent grid

---

## Module 4.4: Transformation Graphs

### Q52: LC 127 - Word Ladder â­â­â­â­ğŸ“
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Hard | 37.30% | No |

**Pattern:** BFS on implicit graph (words are nodes)
**Key insight:** Graph isn't given. Each word connects to words differing by 1 char.

\```python
def ladderLength(beginWord, endWord, wordList):
    wordSet = set(wordList)
    if endWord not in wordSet:
        return 0

    queue = deque([(beginWord, 1)])
    visited = {beginWord}

    while queue:
        word, length = queue.popleft()

        if word == endWord:
            return length

        for i in range(len(word)):
            for c in 'abcdefghijklmnopqrstuvwxyz':
                next_word = word[:i] + c + word[i+1:]
                if next_word in wordSet and next_word not in visited:
                    visited.add(next_word)
                    queue.append((next_word, length + 1))

    return 0
\```

### Q53: LC 126 - Word Ladder II
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Hard | 27.50% | No |

**Pattern:** BFS for shortest path + backtracking for all paths

### Q54: LC 433 - Minimum Genetic Mutation
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 52.50% | No |

**Pattern:** Same as Word Ladder with 4-char alphabet (A,C,G,T)

### Q55: LC 752 - Open the Lock
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 55.70% | No |

**Pattern:** BFS on state space (4-digit lock combinations)

---

## Module 4.5: Minimum Spanning Tree

### Q56: LC 1584 - Min Cost to Connect All Points â­â­â­ğŸ“
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 64.00% | No |

**Pattern:** Kruskal's with Union-Find

\```python
def minCostConnectPoints(points):
    n = len(points)
    edges = []

    for i in range(n):
        for j in range(i+1, n):
            dist = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])
            edges.append((dist, i, j))

    edges.sort()
    uf = UnionFind(n)
    cost = 0

    for d, u, v in edges:
        if uf.union(u, v):
            cost += d
            if uf.components == 1:
                break

    return cost
\```

### Q57: LC 1135 - Connecting Cities With Minimum Cost ğŸ’
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Medium | 61.40% | Yes |

**Pattern:** Classic MST with Kruskal's

---

## Module 4.6: Advanced Graph Patterns

### Q58: LC 332 - Reconstruct Itinerary ğŸ”‘
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Hard | 41.30% | No |

**Pattern:** Eulerian path (Hierholzer's algorithm)
**Key:** Visit all edges exactly once, lexicographically smallest

### Q59: LC 1436 - Destination City
| Difficulty | Acceptance | Premium |
|------------|------------|---------|
| Easy | 77.30% | No |

**Pattern:** Find node with in-degree > 0 and out-degree = 0

---

# Quick Reference: Pattern Recognition

| Keywords | Pattern | First Problem to Try |
|----------|---------|---------------------|
| "shortest path" + unweighted | BFS | LC 1091 |
| "shortest path" + weighted | Dijkstra | LC 743 |
| "all paths" | DFS backtracking | LC 797 |
| "number of islands/components" | DFS flood fill | LC 200 |
| "rotting/spreading" | Multi-source BFS | LC 994 |
| "course schedule" / "prerequisites" | Topological sort | LC 207 |
| "valid tree" | n-1 edges + connected + no cycle | LC 261 |
| "bipartite" / "two groups" | 2-coloring BFS/DFS | LC 785 |
| "redundant edge" | Union-Find | LC 684 |
| "minimum cost to connect" | MST (Kruskal/Prim) | LC 1584 |
| "word ladder" / "transformation" | BFS on implicit graph | LC 127 |
| "surrounded" / "boundary" | DFS from boundary | LC 130 |
| "within K stops" | Modified Dijkstra/Bellman-Ford | LC 787 |
| "all pairs distance" | Floyd-Warshall | LC 1334 |

---

# Complete Problem List by Day

## Week 1: Foundations
| Day | Focus | Problems |
|-----|-------|----------|
| 1 | Graph construction | 1971 Find if Path Exists in Graph |
| 2 | DFS | 797 All Paths From Source to Target, 547 Number of Provinces, 695 Max Area of Island |
| 3 | BFS | 1091 Shortest Path in Binary Matrix, 542 01 Matrix, 1162 As Far from Land as Possible |
| 4 | Grid DFS | 200 Number of Islands, 463 Island Perimeter, 1254 Number of Closed Islands |
| 5 | Multi-source BFS | 994 Rotting Oranges, 286 Walls and GatesğŸ’, 1765 Map of Highest Peak |
| 6 | Clone problems | 133 Clone Graph, 138 Copy List with Random Pointer |
| 7 | Review | Redo hardest from each day |

## Week 2: Cycles & Ordering
| Day | Focus | Problems |
|-----|-------|----------|
| 8 | Undirected cycle | 684 Redundant Connection, 261 Graph Valid TreeğŸ’ |
| 9 | Directed cycle | 207 Course Schedule, 802 Find Eventual Safe States |
| 10 | Topo sort (DFS) | 210 Course Schedule II, 1462 Course Schedule IV |
| 11 | Topo sort (Kahn's) | 210 Course Schedule II, 310 Minimum Height Trees, 2050 Parallel Courses III |
| 12 | Constraint graphs | 269 Alien DictionaryğŸ’ |
| 13 | Bipartite | 785 Is Graph Bipartite?, 886 Possible Bipartition |
| 14 | Review | Mixed practice |

## Week 3: Union-Find & Shortest Paths
| Day | Focus | Problems |
|-----|-------|----------|
| 15 | Union-Find basics | Template implementation |
| 16 | UF applications | 323 Number of Connected ComponentsğŸ’, 684 Redundant Connection, 547 Number of Provinces |
| 17 | Advanced UF | 721 Accounts Merge, 990 Satisfiability of Equality Equations, 1579 Remove Max Edges |
| 18 | Dijkstra theory | Template implementation |
| 19 | Dijkstra applications | 743 Network Delay Time, 787 Cheapest Flights K Stops, 1631 Path With Min Effort |
| 20 | Bellman-Ford | 787 (redo), 1334 Find the City |
| 21 | Speed practice | Timed problems |

## Week 4: Advanced & Mock
| Day | Focus | Problems |
|-----|-------|----------|
| 22 | Backtracking | 79 Word Search, 980 Unique Paths III, 1066 Campus Bikes IIğŸ’ |
| 23 | Trie + Graph | 212 Word Search II, 1233 Remove Sub-Folders |
| 24 | Complex grids | 130 Surrounded Regions, 417 Pacific Atlantic Water Flow, 1559 Detect Cycles 2D, 1905 Count Sub Islands |
| 25 | Transformation graphs | 127 Word Ladder, 433 Minimum Genetic Mutation, 752 Open the Lock |
| 26 | MST | 1584 Min Cost to Connect All Points, 1135 Connecting CitiesğŸ’ |
| 27 | Advanced patterns | 332 Reconstruct Itinerary, 1436 Destination City |
| 28-30 | Mock interviews | Random selection |

---

# Success Metrics Checklist

- [ ] Can recognize pattern in <30 seconds
- [ ] Can code DFS template without reference
- [ ] Can code BFS template without reference
- [ ] Can code Union-Find without reference
- [ ] Can code Dijkstra without reference
- [ ] Can code Topo Sort (both) without reference
- [ ] Can explain time/space complexity for each
- [ ] Can handle follow-up variations
- [ ] Complete 50+ problems

```
```
The file /home/abhishek/Downloads/experiments/learnings/Graph Mastery - Question Path.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
     1â†’# Graph Mastery: Question-Wise Path
     2â†’
     3â†’## Legend
     4â†’| Symbol | Meaning |
     5â†’|--------|---------|
     6â†’| â­ | Must-do (interview essential) |
     7â†’| ğŸ”‘ | Key insight problem |
     8â†’| ğŸ“ | Pattern introduction |
     9â†’| ğŸ’ | Premium problem |
    10â†’| â†’ | Leads to / progression |
    11â†’
    12â†’---
    13â†’
    14â†’# Phase 1: Foundations (Days 1-7)
    15â†’
    16â†’## Module 1.1: Graph Representation
    17â†’**Goal:** Build any graph from scratch
    18â†’
    19â†’### Q1: LC 1971 - Find if Path Exists in Graph ğŸ“
    20â†’| Difficulty | Acceptance | Premium |
    21â†’|------------|------------|---------|
    22â†’| Easy | 51.80% | No |
    23â†’
    24â†’**Pattern:** Graph construction + basic traversal
    25â†’**Before solving:**
    26â†’- Can you build adjacency list from edge list?
    27â†’- What's the difference between directed vs undirected representation?
    28â†’
    29â†’```python
    30â†’# Template: Build adjacency list
    31â†’def build_graph(n, edges, directed=False):
    32â†’    adj = [[] for _ in range(n)]
    33â†’    for u, v in edges:
    34â†’        adj[u].append(v)
    35â†’        if not directed:
    36â†’            adj[v].append(u)
    37â†’    return adj
    38â†’```
    39â†’
    40â†’**Checkpoint:** Solve this in <5 mins including graph construction.
    41â†’
    42â†’---
    43â†’
    44â†’## Module 1.2: DFS Mastery
    45â†’**Goal:** Write DFS in sleep, understand stack behavior
    46â†’
    47â†’### Q2: LC 797 - All Paths From Source to Target â­ğŸ“
    48â†’| Difficulty | Acceptance | Premium |
    49â†’|------------|------------|---------|
    50â†’| Medium | 82.30% | No |
    51â†’
    52â†’**Pattern:** DFS path enumeration
    53â†’**Key insight:** When do you need to backtrack vs when visited stays marked?
    54â†’- Here: **Backtrack** (same node can appear in different paths)
    55â†’- Connected components: **Stay marked** (just counting)
    56â†’
    57â†’```python
    58â†’# Template: DFS with path tracking (backtracking)
    59â†’def dfs_paths(node, target, adj, path, result):
    60â†’    if node == target:
    61â†’        result.append(path[:])
    62â†’        return
    63â†’    for neighbor in adj[node]:
    64â†’        path.append(neighbor)
    65â†’        dfs_paths(neighbor, target, adj, path, result)
    66â†’        path.pop()  # backtrack
    67â†’```
    68â†’
    69â†’### Q3: LC 547 - Number of Provinces â­ğŸ”‘
    70â†’| Difficulty | Acceptance | Premium |
    71â†’|------------|------------|---------|
    72â†’| Medium | 64.00% | No |
    73â†’
    74â†’**Pattern:** Connected components via DFS
    75â†’**Key insight:** Each DFS call "floods" one component. Count the floods.
    76â†’
    77â†’```python
    78â†’# Template: Count connected components
    79â†’def count_components(n, adj):
    80â†’    visited = set()
    81â†’    count = 0
    82â†’    for node in range(n):
    83â†’        if node not in visited:
    84â†’            dfs(node, adj, visited)
    85â†’            count += 1
    86â†’    return count
    87â†’```
    88â†’
    89â†’**Warning:** This problem gives adjacency MATRIX, not list. Convert or adapt.
    90â†’
    91â†’### Q4: LC 695 - Max Area of Island â­
    92â†’| Difficulty | Acceptance | Premium |
    93â†’|------------|------------|---------|
    94â†’| Medium | 71.80% | No |
    95â†’
    96â†’**Pattern:** DFS on grid returning value
    97â†’**Key insight:** DFS returns area count, sum up 1 + recursive calls.
    98â†’
    99â†’```python
   100â†’# Template: DFS on grid with return value
   101â†’def dfs_grid(grid, r, c, visited):
   102â†’    if r < 0 or r >= len(grid) or c < 0 or c >= len(grid[0]):
   103â†’        return 0
   104â†’    if (r, c) in visited or grid[r][c] == 0:
   105â†’        return 0
   106â†’    visited.add((r, c))
   107â†’    return 1 + sum(dfs_grid(grid, r+dr, c+dc, visited)
   108â†’                   for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)])
   109â†’```
   110â†’
   111â†’---
   112â†’
   113â†’## Module 1.3: BFS Mastery
   114â†’**Goal:** Understand why BFS gives shortest path in unweighted graphs
   115â†’
   116â†’### Q5: LC 1091 - Shortest Path in Binary Matrix â­â­ğŸ“
   117â†’| Difficulty | Acceptance | Premium |
   118â†’|------------|------------|---------|
   119â†’| Medium | 46.40% | No |
   120â†’
   121â†’**Pattern:** BFS shortest path in grid
   122â†’**Key insight:** First time BFS reaches a cell = shortest distance (unweighted).
   123â†’
   124â†’```python
   125â†’# Template: BFS shortest path
   126â†’from collections import deque
   127â†’
   128â†’def bfs_shortest(grid, start, end):
   129â†’    if grid[start[0]][start[1]] == 1:
   130â†’        return -1
   131â†’
   132â†’    queue = deque([(start[0], start[1], 1)])  # (r, c, distance)
   133â†’    visited = {start}
   134â†’    directions = [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]
   135â†’
   136â†’    while queue:
   137â†’        r, c, dist = queue.popleft()
   138â†’        if (r, c) == end:
   139â†’            return dist
   140â†’        for dr, dc in directions:
   141â†’            nr, nc = r + dr, c + dc
   142â†’            if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]):
   143â†’                if (nr, nc) not in visited and grid[nr][nc] == 0:
   144â†’                    visited.add((nr, nc))
   145â†’                    queue.append((nr, nc, dist + 1))
   146â†’    return -1
   147â†’```
   148â†’
   149â†’### Q6: LC 542 - 01 Matrix â­â­
   150â†’| Difficulty | Acceptance | Premium |
   151â†’|------------|------------|---------|
   152â†’| Medium | 45.00% | No |
   153â†’
   154â†’**Pattern:** Multi-source BFS
   155â†’**Key insight:** Start BFS from ALL zeros simultaneously. Distance propagates outward.
   156â†’
   157â†’### Q7: LC 1162 - As Far from Land as Possible
   158â†’| Difficulty | Acceptance | Premium |
   159â†’|------------|------------|---------|
   160â†’| Medium | 51.80% | No |
   161â†’
   162â†’**Pattern:** Multi-source BFS (inverse of 542)
   163â†’
   164â†’### Q8: LC 994 - Rotting Oranges â­â­â­ğŸ”‘
   165â†’| Difficulty | Acceptance | Premium |
   166â†’|------------|------------|---------|
   167â†’| Medium | 53.10% | No |
   168â†’
   169â†’**Pattern:** Multi-source BFS + level tracking
   170â†’**Core technique:**
   171â†’1. Add ALL rotten oranges to queue initially
   172â†’2. Process level by level
   173â†’3. Track time = number of levels
   174â†’
   175â†’```python
   176â†’# Template: Multi-source BFS with level tracking
   177â†’def multi_source_bfs(grid, sources):
   178â†’    queue = deque(sources)  # all sources added initially
   179â†’    time = 0
   180â†’
   181â†’    while queue:
   182â†’        for _ in range(len(queue)):  # process current level
   183â†’            r, c = queue.popleft()
   184â†’            for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)]:
   185â†’                nr, nc = r + dr, c + dc
   186â†’                if valid(nr, nc) and should_process(grid[nr][nc]):
   187â†’                    grid[nr][nc] = mark_processed
   188â†’                    queue.append((nr, nc))
   189â†’        if queue:  # more levels to process
   190â†’            time += 1
   191â†’    return time
   192â†’```
   193â†’
   194â†’### Q9: LC 286 - Walls and Gates ğŸ’
   195â†’| Difficulty | Acceptance | Premium |
   196â†’|------------|------------|---------|
   197â†’| Medium | 60.50% | Yes |
   198â†’
   199â†’**Pattern:** Multi-source BFS from gates
   200â†’
   201â†’### Q10: LC 1765 - Map of Highest Peak
   202â†’| Difficulty | Acceptance | Premium |
   203â†’|------------|------------|---------|
   204â†’| Medium | 60.50% | No |
   205â†’
   206â†’**Pattern:** Multi-source BFS from water cells
   207â†’
   208â†’---
   209â†’
   210â†’## Module 1.4: Grid as Graph
   211â†’**Goal:** Navigate any grid problem with confidence
   212â†’
   213â†’### Q11: LC 200 - Number of Islands â­â­â­â­â­ğŸ“
   214â†’| Difficulty | Acceptance | Premium |
   215â†’|------------|------------|---------|
   216â†’| Medium | 57.20% | No |
   217â†’
   218â†’**Pattern:** Connected components on grid
   219â†’**This is THE grid-graph problem.** Master this, everything else is variation.
   220â†’
   221â†’```python
   222â†’# Core technique: "Sink" the island as you visit
   223â†’def numIslands(grid):
   224â†’    count = 0
   225â†’    for r in range(len(grid)):
   226â†’        for c in range(len(grid[0])):
   227â†’            if grid[r][c] == '1':
   228â†’                sink_island(grid, r, c)  # DFS that marks visited by changing to '0'
   229â†’                count += 1
   230â†’    return count
   231â†’```
   232â†’
   233â†’### Q12: LC 463 - Island Perimeter
   234â†’| Difficulty | Acceptance | Premium |
   235â†’|------------|------------|---------|
   236â†’| Easy | 69.70% | No |
   237â†’
   238â†’**Pattern:** Grid counting (different from traversal)
   239â†’**Insight:** Each land cell contributes 4 - (number of land neighbors).
   240â†’
   241â†’### Q13: LC 1254 - Number of Closed Islands
   242â†’| Difficulty | Acceptance | Premium |
   243â†’|------------|------------|---------|
   244â†’| Medium | 66.90% | No |
   245â†’
   246â†’**Pattern:** "Touched boundary" detection
   247â†’**Key insight:** Island is NOT closed if any DFS reaches boundary.
   248â†’
   249â†’### Q14: LC 1020 - Number of Enclaves
   250â†’| Difficulty | Acceptance | Premium |
   251â†’|------------|------------|---------|
   252â†’| Medium | 68.70% | No |
   253â†’
   254â†’**Pattern:** Similar to closed islands - count land not connected to boundary
   255â†’
   256â†’---
   257â†’
   258â†’## Module 1.5: Clone Problems
   259â†’**Goal:** Handle node references correctly
   260â†’
   261â†’### Q15: LC 133 - Clone Graph â­â­â­â­â­ğŸ”‘
   262â†’| Difficulty | Acceptance | Premium |
   263â†’|------------|------------|---------|
   264â†’| Medium | 53.40% | No |
   265â†’
   266â†’**Pattern:** HashMap oldâ†’new mapping
   267â†’**Key insight:** Build clone as you traverse, lookup prevents infinite loops.
   268â†’
   269â†’```python
   270â†’# Template: Graph cloning
   271â†’def cloneGraph(node):
   272â†’    if not node:
   273â†’        return None
   274â†’
   275â†’    old_to_new = {}
   276â†’
   277â†’    def dfs(node):
   278â†’        if node in old_to_new:
   279â†’            return old_to_new[node]
   280â†’
   281â†’        copy = Node(node.val)
   282â†’        old_to_new[node] = copy  # map BEFORE recursing
   283â†’
   284â†’        for neighbor in node.neighbors:
   285â†’            copy.neighbors.append(dfs(neighbor))
   286â†’
   287â†’        return copy
   288â†’
   289â†’    return dfs(node)
   290â†’```
   291â†’
   292â†’### Q16: LC 138 - Copy List with Random Pointer
   293â†’| Difficulty | Acceptance | Premium |
   294â†’|------------|------------|---------|
   295â†’| Medium | 51.70% | No |
   296â†’
   297â†’**Pattern:** Same HashMap technique for linked list
   298â†’
   299â†’---
   300â†’
   301â†’# Phase 2: Cycles & Ordering (Days 8-14)
   302â†’
   303â†’## Module 2.1: Cycle Detection - Undirected
   304â†’**Goal:** Detect cycles using parent tracking
   305â†’
   306â†’### Q17: LC 684 - Redundant Connection â­â­â­â­ğŸ“
   307â†’| Difficulty | Acceptance | Premium |
   308â†’|------------|------------|---------|
   309â†’| Medium | 62.40% | No |
   310â†’
   311â†’**Pattern:** Find the edge that creates a cycle
   312â†’**Two approaches:**
   313â†’1. DFS with parent tracking
   314â†’2. Union-Find (better for this problem)
   315â†’
   316â†’```python
   317â†’# Template: Cycle detection in undirected (DFS)
   318â†’def has_cycle_undirected(node, parent, adj, visited):
   319â†’    visited.add(node)
   320â†’    for neighbor in adj[node]:
   321â†’        if neighbor == parent:
   322â†’            continue  # don't go back to parent
   323â†’        if neighbor in visited:
   324â†’            return True  # cycle found!
   325â†’        if has_cycle_undirected(neighbor, node, adj, visited):
   326â†’            return True
   327â†’    return False
   328â†’```
   329â†’
   330â†’### Q18: LC 261 - Graph Valid Tree â­â­â­â­ğŸ’
   331â†’| Difficulty | Acceptance | Premium |
   332â†’|------------|------------|---------|
   333â†’| Medium | 47.20% | Yes |
   334â†’
   335â†’**Pattern:** Tree = connected + no cycle
   336â†’**Checks:**
   337â†’1. n-1 edges (necessary but not sufficient)
   338â†’2. All nodes reachable from node 0
   339â†’3. No cycle
   340â†’
   341â†’---
   342â†’
   343â†’## Module 2.2: Cycle Detection - Directed
   344â†’**Goal:** Master three-color algorithm
   345â†’
   346â†’### Q19: LC 207 - Course Schedule â­â­â­â­â­ğŸ“ğŸ”‘
   347â†’| Difficulty | Acceptance | Premium |
   348â†’|------------|------------|---------|
   349â†’| Medium | 45.40% | No |
   350â†’
   351â†’**Pattern:** Detect cycle in directed graph
   352â†’**THE core problem for topological sort/cycle detection.**
   353â†’
   354â†’```python
   355â†’# Template: Three-color cycle detection
   356â†’# WHITE=0 (unvisited), GRAY=1 (in current path), BLACK=2 (done)
   357â†’def has_cycle_directed(node, adj, color):
   358â†’    color[node] = 1  # GRAY - currently exploring
   359â†’
   360â†’    for neighbor in adj[node]:
   361â†’        if color[neighbor] == 1:  # back edge to node in current path
   362â†’            return True
   363â†’        if color[neighbor] == 0:  # unvisited
   364â†’            if has_cycle_directed(neighbor, adj, color):
   365â†’                return True
   366â†’
   367â†’    color[node] = 2  # BLACK - done exploring
   368â†’    return False
   369â†’```
   370â†’
   371â†’**Interview phrase:** "I'm using the three-color algorithm. Gray nodes are in the current DFS path. If we reach a gray node, we've found a back edge, which means a cycle."
   372â†’
   373â†’### Q20: LC 802 - Find Eventual Safe States
   374â†’| Difficulty | Acceptance | Premium |
   375â†’|------------|------------|---------|
   376â†’| Medium | 57.30% | No |
   377â†’
   378â†’**Pattern:** Reverse cycle detection
   379â†’**Insight:** Safe = not part of any cycle. Find all nodes that are BLACK after DFS.
   380â†’
   381â†’---
   382â†’
   383â†’## Module 2.3: Topological Sort
   384â†’**Goal:** Know both approaches cold
   385â†’
   386â†’### Q21: LC 210 - Course Schedule II â­â­â­â­â­ğŸ“
   387â†’| Difficulty | Acceptance | Premium |
   388â†’|------------|------------|---------|
   389â†’| Medium | 48.70% | No |
   390â†’
   391â†’**Pattern:** Topological ordering
   392â†’
   393â†’**Approach 1: DFS Post-order (reverse)**
   394â†’```python
   395â†’def topo_dfs(n, adj):
   396â†’    color = [0] * n
   397â†’    order = []
   398â†’
   399â†’    def dfs(node):
   400â†’        color[node] = 1
   401â†’        for neighbor in adj[node]:
   402â†’            if color[neighbor] == 1:
   403â†’                return False  # cycle
   404â†’            if color[neighbor] == 0:
   405â†’                if not dfs(neighbor):
   406â†’                    return False
   407â†’        color[node] = 2
   408â†’        order.append(node)  # post-order
   409â†’        return True
   410â†’
   411â†’    for i in range(n):
   412â†’        if color[i] == 0:
   413â†’            if not dfs(i):
   414â†’                return []  # cycle exists
   415â†’
   416â†’    return order[::-1]  # reverse post-order
   417â†’```
   418â†’
   419â†’### Q22: LC 210 - Course Schedule II (Kahn's) â­â­â­â­â­
   420â†’**Approach 2: BFS with in-degree**
   421â†’```python
   422â†’def topo_kahn(n, adj):
   423â†’    in_degree = [0] * n
   424â†’    for u in range(n):
   425â†’        for v in adj[u]:
   426â†’            in_degree[v] += 1
   427â†’
   428â†’    queue = deque([i for i in range(n) if in_degree[i] == 0])
   429â†’    order = []
   430â†’
   431â†’    while queue:
   432â†’        node = queue.popleft()
   433â†’        order.append(node)
   434â†’        for neighbor in adj[node]:
   435â†’            in_degree[neighbor] -= 1
   436â†’            if in_degree[neighbor] == 0:
   437â†’                queue.append(neighbor)
   438â†’
   439â†’    return order if len(order) == n else []  # cycle if not all processed
   440â†’```
   441â†’
   442â†’**When to use which:**
   443â†’- DFS: When you need to detect cycle + order together
   444â†’- Kahn's: When you need level-by-level processing (parallel courses)
   445â†’
   446â†’### Q23: LC 1462 - Course Schedule IV
   447â†’| Difficulty | Acceptance | Premium |
   448â†’|------------|------------|---------|
   449â†’| Medium | 49.10% | No |
   450â†’
   451â†’**Pattern:** Topological sort + reachability queries
   452â†’
   453â†’### Q24: LC 310 - Minimum Height Trees ğŸ”‘
   454â†’| Difficulty | Acceptance | Premium |
   455â†’|------------|------------|---------|
   456â†’| Medium | 38.60% | No |
   457â†’
   458â†’**Pattern:** Kahn's from leaves inward
   459â†’**Insight:** Keep removing leaves until 1-2 nodes remain. Those are the centers.
   460â†’
   461â†’### Q25: LC 2050 - Parallel Courses III
   462â†’| Difficulty | Acceptance | Premium |
   463â†’|------------|------------|---------|
   464â†’| Hard | 59.10% | No |
   465â†’
   466â†’**Pattern:** Kahn's + track longest path to each node
   467â†’
   468â†’### Q26: LC 1136 - Parallel Courses ğŸ’
   469â†’| Difficulty | Acceptance | Premium |
   470â†’|------------|------------|---------|
   471â†’| Medium | 61.40% | Yes |
   472â†’
   473â†’**Pattern:** Kahn's with level tracking for minimum semesters
   474â†’
   475â†’---
   476â†’
   477â†’## Module 2.4: Build Graph from Constraints
   478â†’
   479â†’### Q27: LC 269 - Alien Dictionary â­â­â­â­ğŸ”‘ğŸ’
   480â†’| Difficulty | Acceptance | Premium |
   481â†’|------------|------------|---------|
   482â†’| Hard | ~35% | Yes |
   483â†’
   484â†’**Pattern:** Extract edges from ordering, then topo sort
   485â†’**Key insight:** Compare adjacent words to find ONE edge per pair.
   486â†’
   487â†’```python
   488â†’# Extract edges from word ordering
   489â†’def extract_edges(words):
   490â†’    edges = []
   491â†’    for i in range(len(words) - 1):
   492â†’        w1, w2 = words[i], words[i+1]
   493â†’        for c1, c2 in zip(w1, w2):
   494â†’            if c1 != c2:
   495â†’                edges.append((c1, c2))  # c1 comes before c2
   496â†’                break
   497â†’        else:
   498â†’            if len(w1) > len(w2):  # "abc" before "ab" is invalid
   499â†’                return None
   500â†’    return edges
   501â†’```
   502â†’
   503â†’---
   504â†’
   505â†’## Module 2.5: Bipartite Graphs
   506â†’
   507â†’### Q28: LC 785 - Is Graph Bipartite? â­â­â­ğŸ“
   508â†’| Difficulty | Acceptance | Premium |
   509â†’|------------|------------|---------|
   510â†’| Medium | 54.50% | No |
   511â†’
   512â†’**Pattern:** Two-coloring
   513â†’**Insight:** Bipartite âŸº no odd-length cycles âŸº 2-colorable
   514â†’
   515â†’```python
   516â†’# Template: Bipartite check
   517â†’def is_bipartite(adj, n):
   518â†’    color = [-1] * n
   519â†’
   520â†’    for start in range(n):
   521â†’        if color[start] != -1:
   522â†’            continue
   523â†’        queue = deque([start])
   524â†’        color[start] = 0
   525â†’
   526â†’        while queue:
   527â†’            node = queue.popleft()
   528â†’            for neighbor in adj[node]:
   529â†’                if color[neighbor] == color[node]:
   530â†’                    return False  # same color = not bipartite
   531â†’                if color[neighbor] == -1:
   532â†’                    color[neighbor] = 1 - color[node]
   533â†’                    queue.append(neighbor)
   534â†’    return True
   535â†’```
   536â†’
   537â†’### Q29: LC 886 - Possible Bipartition
   538â†’| Difficulty | Acceptance | Premium |
   539â†’|------------|------------|---------|
   540â†’| Medium | 50.10% | No |
   541â†’
   542â†’**Pattern:** Bipartite on implicit graph
   543â†’**Build graph:** If A dislikes B, they must be in different groups.
   544â†’
   545â†’---
   546â†’
   547â†’# Phase 3: Union-Find & Shortest Paths (Days 15-21)
   548â†’
   549â†’## Module 3.1: Union-Find
   550â†’
   551â†’### Template: Union-Find with Path Compression
   552â†’```python
   553â†’class UnionFind:
   554â†’    def __init__(self, n):
   555â†’        self.parent = list(range(n))
   556â†’        self.rank = [0] * n
   557â†’        self.components = n
   558â†’
   559â†’    def find(self, x):
   560â†’        if self.parent[x] != x:
   561â†’            self.parent[x] = self.find(self.parent[x])  # path compression
   562â†’        return self.parent[x]
   563â†’
   564â†’    def union(self, x, y):
   565â†’        px, py = self.find(x), self.find(y)
   566â†’        if px == py:
   567â†’            return False  # already connected
   568â†’
   569â†’        # union by rank
   570â†’        if self.rank[px] < self.rank[py]:
   571â†’            px, py = py, px
   572â†’        self.parent[py] = px
   573â†’        if self.rank[px] == self.rank[py]:
   574â†’            self.rank[px] += 1
   575â†’
   576â†’        self.components -= 1
   577â†’        return True
   578â†’```
   579â†’
   580â†’### Q30: LC 323 - Number of Connected Components in an Undirected Graph â­â­â­â­ğŸ“ğŸ’
   581â†’| Difficulty | Acceptance | Premium |
   582â†’|------------|------------|---------|
   583â†’| Medium | 62.30% | Yes |
   584â†’
   585â†’**Pattern:** Basic Union-Find application
   586â†’**Compare:** DFS also works. UF is better for dynamic connectivity.
   587â†’
   588â†’### Q31: LC 684 - Redundant Connection (revisit with UF) â­â­â­â­
   589â†’| Difficulty | Acceptance | Premium |
   590â†’|------------|------------|---------|
   591â†’| Medium | 62.40% | No |
   592â†’
   593â†’**Pattern:** First edge that connects already-connected nodes
   594â†’**With UF:** Process edges in order. First `union()` that returns False = answer.
   595â†’
   596â†’### Q32: LC 547 - Number of Provinces (revisit with UF) â­â­â­
   597â†’| Difficulty | Acceptance | Premium |
   598â†’|------------|------------|---------|
   599â†’| Medium | 64.00% | No |
   600â†’
   601â†’**Pattern:** Connected components - compare DFS vs UF approach
   602â†’
   603â†’### Q33: LC 1319 - Number of Operations to Make Network Connected
   604â†’| Difficulty | Acceptance | Premium |
   605â†’|------------|------------|---------|
   606â†’| Medium | 62.20% | No |
   607â†’
   608â†’**Pattern:** Count components, check if enough extra edges exist
   609â†’
   610â†’### Q34: LC 721 - Accounts Merge â­â­â­ğŸ”‘
   611â†’| Difficulty | Acceptance | Premium |
   612â†’|------------|------------|---------|
   613â†’| Medium | 56.30% | No |
   614â†’
   615â†’**Pattern:** Union-Find with string mapping
   616â†’**Key:** Map each email to an index, union emails within same account.
   617â†’
   618â†’### Q35: LC 990 - Satisfiability of Equality Equations
   619â†’| Difficulty | Acceptance | Premium |
   620â†’|------------|------------|---------|
   621â†’| Medium | 50.50% | No |
   622â†’
   623â†’**Pattern:** Process == first (union), then check != (should not be same root)
   624â†’
   625â†’### Q36: LC 1579 - Remove Max Number of Edges to Keep Graph Fully Traversable
   626â†’| Difficulty | Acceptance | Premium |
   627â†’|------------|------------|---------|
   628â†’| Hard | 65.40% | No |
   629â†’
   630â†’**Pattern:** Two Union-Find instances (Alice & Bob) + greedy edge removal
   631â†’
   632â†’---
   633â†’
   634â†’## Module 3.2: Dijkstra's Algorithm
   635â†’
   636â†’### Core Understanding
   637â†’**When to use:** Weighted graph + non-negative weights + single-source shortest path
   638â†’
   639â†’**Why it works:** When we pop a node from min-heap, its distance is final. Any alternative path through a farther node can only add non-negative cost.
   640â†’
   641â†’**Why negative edges break it:** A "farther" node could provide a shortcut via negative edge.
   642â†’
   643â†’### Template: Dijkstra
   644â†’```python
   645â†’import heapq
   646â†’
   647â†’def dijkstra(n, adj, source):
   648â†’    dist = [float('inf')] * n
   649â†’    dist[source] = 0
   650â†’    heap = [(0, source)]
   651â†’
   652â†’    while heap:
   653â†’        d, node = heapq.heappop(heap)
   654â†’
   655â†’        if d > dist[node]:  # stale entry
   656â†’            continue
   657â†’
   658â†’        for neighbor, weight in adj[node]:
   659â†’            new_dist = d + weight
   660â†’            if new_dist < dist[neighbor]:
   661â†’                dist[neighbor] = new_dist
   662â†’                heapq.heappush(heap, (new_dist, neighbor))
   663â†’
   664â†’    return dist
   665â†’```
   666â†’
   667â†’### Q37: LC 743 - Network Delay Time â­â­â­â­ğŸ“
   668â†’| Difficulty | Acceptance | Premium |
   669â†’|------------|------------|---------|
   670â†’| Medium | 52.10% | No |
   671â†’
   672â†’**Pattern:** Basic Dijkstra
   673â†’**Answer:** Max of all distances (time for signal to reach farthest node)
   674â†’
   675â†’### Q38: LC 787 - Cheapest Flights Within K Stops â­â­â­ğŸ”‘
   676â†’| Difficulty | Acceptance | Premium |
   677â†’|------------|------------|---------|
   678â†’| Medium | 37.10% | No |
   679â†’
   680â†’**Pattern:** Modified Dijkstra with state = (cost, node, stops)
   681â†’**Key:** Can't just skip stale entries. Node might be reached with fewer stops later.
   682â†’
   683â†’```python
   684â†’# Modified state: (cost, node, stops_remaining)
   685â†’def cheapest_k_stops(n, flights, src, dst, k):
   686â†’    adj = defaultdict(list)
   687â†’    for u, v, w in flights:
   688â†’        adj[u].append((v, w))
   689â†’
   690â†’    heap = [(0, src, k + 1)]  # (cost, node, stops_remaining)
   691â†’
   692â†’    while heap:
   693â†’        cost, node, stops = heapq.heappop(heap)
   694â†’
   695â†’        if node == dst:
   696â†’            return cost
   697â†’
   698â†’        if stops > 0:
   699â†’            for neighbor, price in adj[node]:
   700â†’                heapq.heappush(heap, (cost + price, neighbor, stops - 1))
   701â†’
   702â†’    return -1
   703â†’```
   704â†’
   705â†’### Q39: LC 1631 - Path With Minimum Effort â­â­â­
   706â†’| Difficulty | Acceptance | Premium |
   707â†’|------------|------------|---------|
   708â†’| Medium | 55.90% | No |
   709â†’
   710â†’**Pattern:** Dijkstra on grid with custom weight
   711â†’**Weight:** max absolute difference along path (not sum)
   712â†’
   713â†’### Q40: LC 1514 - Path with Maximum Probability
   714â†’| Difficulty | Acceptance | Premium |
   715â†’|------------|------------|---------|
   716â†’| Medium | 48.90% | No |
   717â†’
   718â†’**Pattern:** Dijkstra with max-heap (or negate probabilities)
   719â†’
   720â†’---
   721â†’
   722â†’## Module 3.3: Bellman-Ford & Floyd-Warshall
   723â†’
   724â†’### When to use
   725â†’| Algorithm | Use case | Complexity |
   726â†’|-----------|----------|------------|
   727â†’| Dijkstra | Single-source, non-negative weights | O((V+E) log V) |
   728â†’| Bellman-Ford | Single-source, handles negative weights | O(V Ã— E) |
   729â†’| Floyd-Warshall | All-pairs shortest path | O(VÂ³) |
   730â†’
   731â†’### Q41: LC 787 - Cheapest Flights (Bellman-Ford approach)
   732â†’**Why it works here:** K stops = K+1 edges = K+1 relaxation rounds
   733â†’
   734â†’### Q42: LC 1334 - Find the City With the Smallest Number of Neighbors at a Threshold Distance
   735â†’| Difficulty | Acceptance | Premium |
   736â†’|------------|------------|---------|
   737â†’| Medium | 55.40% | No |
   738â†’
   739â†’**Pattern:** Floyd-Warshall to get all-pairs, then filter by threshold
   740â†’
   741â†’---
   742â†’
   743â†’# Phase 4: Advanced Patterns (Days 22-27)
   744â†’
   745â†’## Module 4.1: Backtracking on Graphs
   746â†’
   747â†’### Q43: LC 79 - Word Search â­â­â­â­ğŸ“
   748â†’| Difficulty | Acceptance | Premium |
   749â†’|------------|------------|---------|
   750â†’| Medium | 40.30% | No |
   751â†’
   752â†’**Pattern:** DFS with backtracking
   753â†’**Key difference from regular DFS:** Unmark visited after exploring (same cell can be in different paths)
   754â†’
   755â†’```python
   756â†’def exist(board, word):
   757â†’    def dfs(r, c, idx):
   758â†’        if idx == len(word):
   759â†’            return True
   760â†’        if r < 0 or r >= len(board) or c < 0 or c >= len(board[0]):
   761â†’            return False
   762â†’        if board[r][c] != word[idx]:
   763â†’            return False
   764â†’
   765â†’        temp = board[r][c]
   766â†’        board[r][c] = '#'  # mark visited
   767â†’
   768â†’        found = any(dfs(r+dr, c+dc, idx+1)
   769â†’                   for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)])
   770â†’
   771â†’        board[r][c] = temp  # backtrack
   772â†’        return found
   773â†’
   774â†’    for r in range(len(board)):
   775â†’        for c in range(len(board[0])):
   776â†’            if dfs(r, c, 0):
   777â†’                return True
   778â†’    return False
   779â†’```
   780â†’
   781â†’### Q44: LC 980 - Unique Paths III â­â­â­
   782â†’| Difficulty | Acceptance | Premium |
   783â†’|------------|------------|---------|
   784â†’| Hard | 81.60% | No |
   785â†’
   786â†’**Pattern:** Backtracking + count all valid paths
   787â†’**Must visit:** All empty cells exactly once
   788â†’
   789â†’### Q45: LC 1066 - Campus Bikes II ğŸ’
   790â†’| Difficulty | Acceptance | Premium |
   791â†’|------------|------------|---------|
   792â†’| Medium | 54.90% | Yes |
   793â†’
   794â†’**Pattern:** Backtracking with bitmask DP optimization
   795â†’
   796â†’---
   797â†’
   798â†’## Module 4.2: Trie + Graph
   799â†’
   800â†’### Q46: LC 212 - Word Search II â­â­â­â­ğŸ”‘
   801â†’| Difficulty | Acceptance | Premium |
   802â†’|------------|------------|---------|
   803â†’| Hard | 36.30% | No |
   804â†’
   805â†’**Pattern:** Trie optimization for multiple word search
   806â†’**Key insight:** Build Trie of words, DFS on grid while traversing Trie simultaneously
   807â†’
   808â†’### Q47: LC 1233 - Remove Sub-Folders from the Filesystem
   809â†’| Difficulty | Acceptance | Premium |
   810â†’|------------|------------|---------|
   811â†’| Medium | 65.60% | No |
   812â†’
   813â†’**Pattern:** Trie for path matching
   814â†’
   815â†’---
   816â†’
   817â†’## Module 4.3: Advanced Grid Problems
   818â†’
   819â†’### Q48: LC 130 - Surrounded Regions â­â­â­â­ğŸ“
   820â†’| Difficulty | Acceptance | Premium |
   821â†’|------------|------------|---------|
   822â†’| Medium | 37.10% | No |
   823â†’
   824â†’**Pattern:** Boundary-connected DFS
   825â†’**Insight:** Mark 'O's connected to boundary. Everything else gets captured.
   826â†’
   827â†’### Q49: LC 417 - Pacific Atlantic Water Flow â­â­â­â­ğŸ”‘
   828â†’| Difficulty | Acceptance | Premium |
   829â†’|------------|------------|---------|
   830â†’| Medium | 54.50% | No |
   831â†’
   832â†’**Pattern:** Reverse DFS from oceans
   833â†’**Key insight:** Instead of "can water flow to ocean?", ask "where can ocean reach?"
   834â†’Start DFS from all ocean borders, find intersection.
   835â†’
   836â†’### Q50: LC 1559 - Detect Cycles in 2D Grid
   837â†’| Difficulty | Acceptance | Premium |
   838â†’|------------|------------|---------|
   839â†’| Medium | 48.10% | No |
   840â†’
   841â†’**Pattern:** Cycle detection on grid (4-directional)
   842â†’
   843â†’### Q51: LC 1905 - Count Sub Islands
   844â†’| Difficulty | Acceptance | Premium |
   845â†’|------------|------------|---------|
   846â†’| Medium | 67.80% | No |
   847â†’
   848â†’**Pattern:** DFS with validation against parent grid
   849â†’
   850â†’---
   851â†’
   852â†’## Module 4.4: Transformation Graphs
   853â†’
   854â†’### Q52: LC 127 - Word Ladder â­â­â­â­ğŸ“
   855â†’| Difficulty | Acceptance | Premium |
   856â†’|------------|------------|---------|
   857â†’| Hard | 37.30% | No |
   858â†’
   859â†’**Pattern:** BFS on implicit graph (words are nodes)
   860â†’**Key insight:** Graph isn't given. Each word connects to words differing by 1 char.
   861â†’
   862â†’```python
   863â†’def ladderLength(beginWord, endWord, wordList):
   864â†’    wordSet = set(wordList)
   865â†’    if endWord not in wordSet:
   866â†’        return 0
   867â†’
   868â†’    queue = deque([(beginWord, 1)])
   869â†’    visited = {beginWord}
   870â†’
   871â†’    while queue:
   872â†’        word, length = queue.popleft()
   873â†’
   874â†’        if word == endWord:
   875â†’            return length
   876â†’
   877â†’        for i in range(len(word)):
   878â†’            for c in 'abcdefghijklmnopqrstuvwxyz':
   879â†’                next_word = word[:i] + c + word[i+1:]
   880â†’                if next_word in wordSet and next_word not in visited:
   881â†’                    visited.add(next_word)
   882â†’                    queue.append((next_word, length + 1))
   883â†’
   884â†’    return 0
   885â†’```
   886â†’
   887â†’### Q53: LC 126 - Word Ladder II
   888â†’| Difficulty | Acceptance | Premium |
   889â†’|------------|------------|---------|
   890â†’| Hard | 27.50% | No |
   891â†’
   892â†’**Pattern:** BFS for shortest path + backtracking for all paths
   893â†’
   894â†’### Q54: LC 433 - Minimum Genetic Mutation
   895â†’| Difficulty | Acceptance | Premium |
   896â†’|------------|------------|---------|
   897â†’| Medium | 52.50% | No |
   898â†’
   899â†’**Pattern:** Same as Word Ladder with 4-char alphabet (A,C,G,T)
   900â†’
   901â†’### Q55: LC 752 - Open the Lock
   902â†’| Difficulty | Acceptance | Premium |
   903â†’|------------|------------|---------|
   904â†’| Medium | 55.70% | No |
   905â†’
   906â†’**Pattern:** BFS on state space (4-digit lock combinations)
   907â†’
   908â†’---
   909â†’
   910â†’## Module 4.5: Minimum Spanning Tree
   911â†’
   912â†’### Q56: LC 1584 - Min Cost to Connect All Points â­â­â­ğŸ“
   913â†’| Difficulty | Acceptance | Premium |
   914â†’|------------|------------|---------|
   915â†’| Medium | 64.00% | No |
   916â†’
   917â†’**Pattern:** Kruskal's with Union-Find
   918â†’
   919â†’```python
   920â†’def minCostConnectPoints(points):
   921â†’    n = len(points)
   922â†’    edges = []
   923â†’
   924â†’    for i in range(n):
   925â†’        for j in range(i+1, n):
   926â†’            dist = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1])
   927â†’            edges.append((dist, i, j))
   928â†’
   929â†’    edges.sort()
   930â†’    uf = UnionFind(n)
   931â†’    cost = 0
   932â†’
   933â†’    for d, u, v in edges:
   934â†’        if uf.union(u, v):
   935â†’            cost += d
   936â†’            if uf.components == 1:
   937â†’                break
   938â†’
   939â†’    return cost
   940â†’```
   941â†’
   942â†’### Q57: LC 1135 - Connecting Cities With Minimum Cost ğŸ’
   943â†’| Difficulty | Acceptance | Premium |
   944â†’|------------|------------|---------|
   945â†’| Medium | 61.40% | Yes |
   946â†’
   947â†’**Pattern:** Classic MST with Kruskal's
   948â†’
   949â†’---
   950â†’
   951â†’## Module 4.6: Advanced Graph Patterns
   952â†’
   953â†’### Q58: LC 332 - Reconstruct Itinerary ğŸ”‘
   954â†’| Difficulty | Acceptance | Premium |
   955â†’|------------|------------|---------|
   956â†’| Hard | 41.30% | No |
   957â†’
   958â†’**Pattern:** Eulerian path (Hierholzer's algorithm)
   959â†’**Key:** Visit all edges exactly once, lexicographically smallest
   960â†’
   961â†’### Q59: LC 1436 - Destination City
   962â†’| Difficulty | Acceptance | Premium |
   963â†’|------------|------------|---------|
   964â†’| Easy | 77.30% | No |
   965â†’
   966â†’**Pattern:** Find node with in-degree > 0 and out-degree = 0
   967â†’
   968â†’---
   969â†’
   970â†’# Quick Reference: Pattern Recognition
   971â†’
   972â†’| Keywords | Pattern | First Problem to Try |
   973â†’|----------|---------|---------------------|
   974â†’| "shortest path" + unweighted | BFS | LC 1091 |
   975â†’| "shortest path" + weighted | Dijkstra | LC 743 |
   976â†’| "all paths" | DFS backtracking | LC 797 |
   977â†’| "number of islands/components" | DFS flood fill | LC 200 |
   978â†’| "rotting/spreading" | Multi-source BFS | LC 994 |
   979â†’| "course schedule" / "prerequisites" | Topological sort | LC 207 |
   980â†’| "valid tree" | n-1 edges + connected + no cycle | LC 261 |
   981â†’| "bipartite" / "two groups" | 2-coloring BFS/DFS | LC 785 |
   982â†’| "redundant edge" | Union-Find | LC 684 |
   983â†’| "minimum cost to connect" | MST (Kruskal/Prim) | LC 1584 |
   984â†’| "word ladder" / "transformation" | BFS on implicit graph | LC 127 |
   985â†’| "surrounded" / "boundary" | DFS from boundary | LC 130 |
   986â†’| "within K stops" | Modified Dijkstra/Bellman-Ford | LC 787 |
   987â†’| "all pairs distance" | Floyd-Warshall | LC 1334 |
   988â†’
   989â†’---
   990â†’
   991â†’# Complete Problem List by Day
   992â†’
   993â†’## Week 1: Foundations
   994â†’| Day | Focus | Problems |
   995â†’|-----|-------|----------|
   996â†’| 1 | Graph construction | 1971 Find if Path Exists in Graph |
   997â†’| 2 | DFS | 797 All Paths From Source to Target, 547 Number of Provinces, 695 Max Area of Island |
   998â†’| 3 | BFS | 1091 Shortest Path in Binary Matrix, 542 01 Matrix, 1162 As Far from Land as Possible |
   999â†’| 4 | Grid DFS | 200 Number of Islands, 463 Island Perimeter, 1254 Number of Closed Islands |
  1000â†’| 5 | Multi-source BFS | 994 Rotting Oranges, 286 Walls and GatesğŸ’, 1765 Map of Highest Peak |
  1001â†’| 6 | Clone problems | 133 Clone Graph, 138 Copy List with Random Pointer |
  1002â†’| 7 | Review | Redo hardest from each day |
  1003â†’
  1004â†’## Week 2: Cycles & Ordering
  1005â†’| Day | Focus | Problems |
  1006â†’|-----|-------|----------|
  1007â†’| 8 | Undirected cycle | 684 Redundant Connection, 261 Graph Valid TreeğŸ’ |
  1008â†’| 9 | Directed cycle | 207 Course Schedule, 802 Find Eventual Safe States |
  1009â†’| 10 | Topo sort (DFS) | 210 Course Schedule II, 1462 Course Schedule IV |
  1010â†’| 11 | Topo sort (Kahn's) | 210 Course Schedule II, 310 Minimum Height Trees, 2050 Parallel Courses III |
  1011â†’| 12 | Constraint graphs | 269 Alien DictionaryğŸ’ |
  1012â†’| 13 | Bipartite | 785 Is Graph Bipartite?, 886 Possible Bipartition |
  1013â†’| 14 | Review | Mixed practice |
  1014â†’
  1015â†’## Week 3: Union-Find & Shortest Paths
  1016â†’| Day | Focus | Problems |
  1017â†’|-----|-------|----------|
  1018â†’| 15 | Union-Find basics | Template implementation |
  1019â†’| 16 | UF applications | 323 Number of Connected ComponentsğŸ’, 684 Redundant Connection, 547 Number of Provinces |
  1020â†’| 17 | Advanced UF | 721 Accounts Merge, 990 Satisfiability of Equality Equations, 1579 Remove Max Edges |
  1021â†’| 18 | Dijkstra theory | Template implementation |
  1022â†’| 19 | Dijkstra applications | 743 Network Delay Time, 787 Cheapest Flights K Stops, 1631 Path With Min Effort |
  1023â†’| 20 | Bellman-Ford | 787 (redo), 1334 Find the City |
  1024â†’| 21 | Speed practice | Timed problems |
  1025â†’
  1026â†’## Week 4: Advanced & Mock
  1027â†’| Day | Focus | Problems |
  1028â†’|-----|-------|----------|
  1029â†’| 22 | Backtracking | 79 Word Search, 980 Unique Paths III, 1066 Campus Bikes IIğŸ’ |
  1030â†’| 23 | Trie + Graph | 212 Word Search II, 1233 Remove Sub-Folders |
  1031â†’| 24 | Complex grids | 130 Surrounded Regions, 417 Pacific Atlantic Water Flow, 1559 Detect Cycles 2D, 1905 Count Sub Islands |
  1032â†’| 25 | Transformation graphs | 127 Word Ladder, 433 Minimum Genetic Mutation, 752 Open the Lock |
  1033â†’| 26 | MST | 1584 Min Cost to Connect All Points, 1135 Connecting CitiesğŸ’ |
  1034â†’| 27 | Advanced patterns | 332 Reconstruct Itinerary, 1436 Destination City |
  1035â†’| 28-30 | Mock interviews | Random selection |
  1036â†’
  1037â†’---
  1038â†’
  1039â†’# Success Metrics Checklist
  1040â†’
  1041â†’- [ ] Can recognize pattern in <30 seconds
  1042â†’- [ ] Can code DFS template without reference
  1043â†’- [ ] Can code BFS template without reference
  1044â†’- [ ] Can code Union-Find without reference
  1045â†’- [ ] Can code Dijkstra without reference
  1046â†’- [ ] Can code Topo Sort (both) without reference
  1047â†’- [ ] Can explain time/space complexity for each
  1048â†’- [ ] Can handle follow-up variations
  1049â†’- [ ] Complete 50+ problems
  1050â†’
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:22:00.361Z)**_

<think><details><summary>Thought Process</summary>
The file has been updated with all the precise question numbers, titles, difficulty levels, and acceptance rates from the CSV data. Now I should summarize what was done for the user.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-25T06:22:06.258Z)**_

Done. Updated **Graph Mastery - Question Path.md** with precise data from CSV:

**Enhancements made:**
1. **59 problems** organized with exact LC numbers & titles
2. **Difficulty/Acceptance/Premium** tables for each problem
3. **ğŸ’ symbol** marks Premium problems (LC 261, 269, 286, 323, 1066, 1135, 1136)
4. **Complete daily problem list** with exact titles
5. **Pattern recognition table** â†’ keywords map to first problem to try

**Structure:**
- Phase 1: Foundations (Q1-Q16) â†’ DFS/BFS/Grid basics
- Phase 2: Cycles & Ordering (Q17-Q29) â†’ Cycle detection, Topo sort, Bipartite
- Phase 3: Union-Find & Shortest Paths (Q30-Q42) â†’ UF, Dijkstra, Bellman-Ford
- Phase 4: Advanced (Q43-Q59) â†’ Backtracking, Trie+Graph, MST, Eulerian

File location: `/home/abhishek/Downloads/experiments/learnings/Graph Mastery - Question Path.md`
